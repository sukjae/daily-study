# [부스트캠프 멤버십 10일차]

## 오늘의 배움

### Express에서 미들웨어를 테스트하는 방법

Node 진영에서 사용할 수 있는 많은 테스트 라이브러리 들이 존재한다. 

그중에서 나는 FE와의 통일성을 위하여 Jest를 정하였고, 다행히 이 도구가 어느정도 범용적인 용도를 갖고 있어 서버에서도 무난하게 녹아들 수 있었다. 

그러나 Server쪽의 테스트를 처음 접해보고, 그 중에서도 Middleware에 대해 처음 접해보니 테스트 코드를 어떻게 작성해야 하는지에 대한 의문이 들었다. 

테스트 코드, 그 중에서도 유닛 테스트를 작성하려 하는데 함수와는 다른 접근을 취해야 할 것 같았다 .

예를 들어, 다음과 같은 코드가 있다고 가정하자. 

```js
const doesBodyExist = (req, res, next) => {
  if (!req.body || isEmpty(req.body)) {
    return res.status(400).json({});
  }
  next();
};

export default doesBodyExist;
```

사실 따지고 보면, 그냥 보통의 함수 이지만 req, res,next를 전달받아서 next를 호출하거나 res를 호출하는 형태의 미들웨어이다. 

next는 어찌보면 Callback이라 볼 수 있기 때문에 무언가 로직을 삽입할 수 있지만, res는 그 속의 객체, 그리고 그 속의 객체에 접근해야 한다. 

처음에는 기타 라이브러리를 통해  인자의 mock을 생성하는 방법을 고민하였다. 그러나, 간단한 유닛테스트에 아직까지 별도의 모듈 설치의 필요성을 느끼지 못하여 제외하였다. 

그 다음에 생각한 방법이 supertest를 활용하여 app을 테스트 하듯 하는 방식이였다. 

이 경우에 매 테스트마다 다음과 같이 app 전체를 불러와야 한다. 

```js
import request from 'supertest';
const app = require('../app'); // our Node application
//...
describe('api 테스트', () => {
  test('GET: api가 열려있어야 한다', async () => {
    await request(app).get(url).expect(200);
  });
//...
})
```

이 방식의 가장 큰 단점은, 테스트가 너무 무거워 진다는 것이다. 

통합테스트를 위해서 이렇게 작성하는 것은 무방하나, 각각의 기능을 테스트 하기 위한 유닛테스트에서는 적절치 않아 보였다 .

그래서 나는 결론적으로 Jest의 기본적인 기능을 활용하여 임의의 mock을 생성하여 테스트 코드를 작성하였다. 

이 경우 jest를 벗어나서 추가로 종속적인 모듈을 설치하지 않아서 좋고, 가벼워서 더욱 좋다. 

이 방식의 핵심은, middleware를 단순히 인자 3개를 받는 보통의 함수로 생각하는 것이다. 

그러니깐, 우리의 Middleware는 인자 3개를 받고, 상황에 따라 아래 두 가지중 하나의 행동을 하는 함수이다. 

1. next(3번째 인자)로 전달된 함수를 실행한다 (별 이상이 없어서 다음 middleware로 넘어가는 상황)
2. res 의 어떠한 method에  어떠한 값을 넣어 실행한다. (보통 200, 400 등의 http status code이다)

```js
import doesBodyExist from '../middlewares/checkBody';

describe('Middleware: 테스팅', () => {
  describe('req.body 확인용 테스트', () => {
    const res = {
      status: jest.fn(() => ({
        json: jest.fn(),
      })),
    };
  
  test('body가 있으면 next가 실행된다', async () => {
      const req = {
        body: 'hi',
      };
      const next = jest.fn();
      await doesBodyExist(req, res, next);
      expect(next).toBeCalled();
    });
  });
//..
})
```

다른 더 좋은 방법이 있을지 모르지만, 지금으로서는 나에게는 위 방법이 최선인것 같다. 

## 오늘의 고민들

### 스크럼

기존에 작성하였던 유저 스토리와, 이에 대한 백로그를 수정하였다.  크게 정해진 규칙 없이, 내 입맛대로 변형을 주었다. 

기존의 유저스토리에서는 FE에 대한 고려만 하고, 서버측 고려는 하지 않았다.  보통 유저 스토리는 유저의 관점에서 작성되므로 FE에 대한 내용만이 언급된다. 

나는 Server쪽의 내용을 정리하기 위해 `유저 스토리` 와 `비하인드 스토리` 로 나누어 정리하였다. 

이렇게 되면 유저 스토리에서는 유저와 App간의 인터렉션에 대해 정의할 수 있고, 

비하인드 스토리에서 App과 App간의 인터렉션에 대해 정의할 수 있다. 

지금으로서는 기능명세서를 스프린트 백로그 속에 포함 시켰지만, 갈수록 유저 스토리가 비대해져 가는것을 느낀다.  추후에는 이 부분을 따로 관리하는 방법에 대해 고민하도록 해야겠다. 

### Server 측의 테스트에 대한 고민

오늘부터 TDD의 원칙에 맞춰 코드 작성을 시작하였다. 

선 코드 작성 후 테스트 작성이 아닌, 빨간불, 초록불, 리펙토링의 순서를 지키고자 노력하였다. 

어제 가장 작은 기능 단위 부터 큰 덩어리인 API로의 순서로 TDD를 하려 하였는데, 필요한 기능을 사전에 모두 정의내리기 어려워서 더 논리적이고 순차적으로 접근할 수 있도록 큰것(api단위의 테스트)에서 작은것(세부 기능, 미들웨어 테스트) 으로 테스트를 점점 세분화 하는 시도를 하였다. 

작성을 하며 떠오른 두가지 생각이 있었다. 

첫번째는, 이렇게 코드를 작성하다 보니 내가 TDD를 하는것인지 BDD를 하는것인지 햇갈리기 시작했다. 

이 부분에 대한 명확한 이해가 없어서 생기는 혼란이라 판단되어, 추후 다시 한번 BDD와 TDD를 비교 분석해야 겠다. 

둘쨰로 내가 작성하는 테스트 코드가 충분한 커버리지를 갖고 있는지에 대한 의문이였다. 

시간을 들여 열심히 코드를 작성하였는데, 너무 큰 틈들이 듬성듬성 있으면 그것은 사실상 무의미한 시도라 생각한다. 

이 부분에 대해 어떻게 하면 적당히 납득할만한 커버리지를 갖는 테스트를 작성할 수 있는지 고민이 필요하다. 

### 함수나 미들웨어는 어느정도로 파편화하여야 할까

함수나 미들웨어를 아주 작은 단위로 세분화할 수 있다. 

오늘 내가 내린 결정은, 단위 테스트가 가능할 정도의 수준으로 코드를 나누는게 좋겠다는 결론을 내렸다. 

이러한 방법이 단위테스트에도 좋지만, 코드의 재 사용성에도 좋을 것이라는 판단 에서이다.

### 테스트를 한글로

지난번에 어디선가 테스트 코드에 대한 문장을 한글로 작성하는 것에 대해 들은적이 있다. 

외국인들과 협업을 해야할 때나, 많은 이들이 참고해야 하는 Commit message의 경우 최대한 영어를 사용함이 좋지만, 

버그가 발생하였을 때, 문제에 대한 빠른 판단이 필요한 경우에는 모국어를 사용하는게 좋다는 생각이 든다. 

다수의 인원이 모국어가 영어가 아닌 상태에서, 실질적인 문제에 대한 원인과 힌트를 어색한 번역투의 영어로 작성하여 혼선을 주기보다는 명확한 해석이 가능하도록 모국어로 작성하는게 좋겠다. 

## 오늘의 회고

전반적으로 만족스러운 하루였다. 

너무 느러지지도 않고, 너무 조급하지 않게 코드를 작성할 수 있었다. 

지난날들 처럼 거대한 산에 가로막혀 아무것도 못하는 상황이 되지 않도록, 최대한 잘게 잘게 세분화하여 점진적으로 코드를 작성하려 노력했다. 

그 결과 코드의 작성 과정에서 오는 스트레스가 많이 줄어든것 같아 만족스럽다. 

물론 아직 납기일에 코드를 완성해야 하는 부담감이 있어 무작정 코드 작성을 시작해야 하는게 아닌가 하는 ㄴ걱정은 있지만, 나를 믿고 최대한 많은 내용을 배워가기 위해 도전하고 있다. 

물론 결과가 중요하지만, 그 과정 또한 중요하다. 

항상 매 순간 최선을 다하자.