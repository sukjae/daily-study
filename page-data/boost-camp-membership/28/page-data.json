{"componentChunkName":"component---src-templates-blog-post-js","path":"/boost-camp-membership/28/","result":{"data":{"site":{"siteMetadata":{"title":"Daily Study | Sukjae"}},"markdownRemark":{"id":"f0cda74b-687a-52dc-85ef-4700a032a9e5","excerpt":"Kubernetes 삽질기 2 구상중인 k8s + AWS 인프라 구성 v1  햇갈리는 부분 정리 K8s에 쓰일 docker image는 어느 레벨까지 dockerlize가 되어야 할까 드는 생각들은, os위에 node, 그리고 그 위에 Express App…","html":"<h2>Kubernetes 삽질기 2</h2>\n<h2>구상중인 k8s + AWS 인프라 구성 v1</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/daily-study/static/c873dff1aec1397af8353e0d34ae0e7c/d69c4/pole-infra-v1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 73.64864864864865%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAADOElEQVQ4y41UeUhTcRz/vG0+55y6rV0q6TLLFiYddFBUFBV0UEaFdEAEneukg4yCooOKwi47DHVzOufUtbTD/knwj6ggKqKbkooKJNQoInPb+/Z9m+uyoB/vw/f3vu/z+7zv9R4A5DCUf4PyH37h7352QwOotX0QoHxU0UZ4aTWqaU0PHLJVsDX6yWG9QA6TP+LrDQ/zvbQBLikfSDZbUUnX+aYbzmAnnKGPcIU/oYI62XYoKqR2S43UnlkXtYJLakcvhD8w/yvKuhrkOE34ueLw59rbzhTizTLGJEA7Hoa8icDcU+CowGLAxoae02pOXaUxa/00R1/WuVtV3jWCSYNNVV07NWfbVuI/1zFfc2zLL483W3Q+akzzE6nlOjqlxXkXpS+pPqkZC92pcW7JwiVJSoseUHMKakSBFD+pYkpTiKMdvywOiljKqx5F0hVqyIj9jybg/NdMnPk4xlYXvqKrpwVyJ+Nyp9hQUGRQ9h/dTwc+WkuWhEqpXlcttXANV8TEI4JZe64pIndOaZu+kSi+IvQcsw/pf8lMxKm2QrO3O4CjrzZHPDVk0VRJzQav9IwFHVGaUjQRh9v/9LNoQzyUiiOvpqL027Atchr2hwp0kACtVbteQPpaAYOXaIS+EW4TpbDgLRZ8y4KbYm82/FZhFy03VQc7Ej3SRRx4OdTolZ5a66gDe+7PuDon/9yNdVvfuecvKcH+B7m6ohcjxYpQbZKHbsBNy6NtmX8gt2+A9qb6wkU8Uxn8IM/gCe5LKH7vQOGt9LSa0PqMAG3HomO5KYceFA+qDd7RHH580F76erfe9XlhYmWo2egNt3Igq6IZr3SOsTfSbe7sYx7icb8GmyLX7edSiyWdgcxL9EVZ3OaWHaqblIwnJGZcprWZftoVpS11jrVdoHvZ9eEXKAlGBJOL34i6JlJgx12kFTaoZhHJDRM1x1vLB/q6WsUjz0/KvPgW0mN6od3oKJuX7u0eB8HOg11weojtEp3IDlApD3XOv4ZXkC9zdo5gzpoM68CsH37rgGw2w+V9wcxp8jDB1vO3ELnNSfz5yKOi6w2BK4BERgJDC0Eh+2WuRqFUWgWlahTvR30HYfNZGbyh39YAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"pole infra v1\"\n        title=\"pole infra v1\"\n        src=\"/daily-study/static/c873dff1aec1397af8353e0d34ae0e7c/fcda8/pole-infra-v1.png\"\n        srcset=\"/daily-study/static/c873dff1aec1397af8353e0d34ae0e7c/12f09/pole-infra-v1.png 148w,\n/daily-study/static/c873dff1aec1397af8353e0d34ae0e7c/e4a3f/pole-infra-v1.png 295w,\n/daily-study/static/c873dff1aec1397af8353e0d34ae0e7c/fcda8/pole-infra-v1.png 590w,\n/daily-study/static/c873dff1aec1397af8353e0d34ae0e7c/efc66/pole-infra-v1.png 885w,\n/daily-study/static/c873dff1aec1397af8353e0d34ae0e7c/d69c4/pole-infra-v1.png 1002w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h2>햇갈리는 부분 정리</h2>\n<h2>K8s에 쓰일 docker image는 어느 레벨까지 dockerlize가 되어야 할까</h2>\n<p>드는 생각들은, os위에 node, 그리고 그 위에 Express App이 올라가게 된다.</p>\n<p>이 과정에서 우리는</p>\n<ol>\n<li>node 까지의 서버를 dockerlize할 수 있고,</li>\n<li>express app까지 모두 dockerlize할 수 있다.</li>\n</ol>\n<p>둘간의 장단점이 보이기는 하지만, 어떤 선택지가 최적인지는 감이 오지 않는다.</p>\n<p>1번 방식의 경우에는, os/node 의 버전이 업그레이드 되거나, 설치해야 할 도구들이 있을 경우만 image가 빌드되는 형태로 생각된다. 그 이후 express app은 aws의 EFS과 같은 방식으로 하나의 폴더를 여러 instance가 공유하거나, s3에서 ebs로 하나씩 옮겨서(copy) 서비스 하는 방식이 떠오른다. 어차피, 운영중에 사용자에 의해 서비스의 코드가 변하지 않을 것이다.</p>\n<p>예상되는 장단점은 다음과 같다</p>\n<p>장점</p>\n<ul>\n<li>image build를 매번할 필요가 없다</li>\n<li>production과 dev(local) 환경의 통일이 용이할듯 하다</li>\n</ul>\n<p>단점</p>\n<ul>\n<li>두가지 환경을 모두 관리해야 한다. 1) image 저장소, 2) 소스 코드 저장소</li>\n<li>배포에 부가적인 작업이 동반된다 (복사, 등)</li>\n</ul>\n<p>두 방법중에, 1번 방법이 현재로 나에게 가장 적합한듯한 이유는, dev환경에서의 k8s &#x26; docker 를 이용한 서비스 개발이 어떻게 진행되어야 하는지 감이 안오기 때문이다.</p>\n<p>production의 상황에서는 k8s가 build된 image를 pull해서 인프라를 구성하는데, local dev 환경에서 해당 k8s 파일로 provision하면, 최신 image만 사용되기 때문에 추가적으로 해당 image를 수정하기 위해 어떤 작업이 동반되어야 하는지 감이 안온다.</p>\n<p>어떤 image를 수정하기 위해서는 우리가 local에서 개발하는 경험처럼 source code를 바꾸고 실행시키는 빠른 feedback이 필요한데 보통의 k8s의 경우에는 source code 변경 → image build → image push → image pull → provision의 과정이 매번 동반될 것 같기 때문이다. 우리가 local에서 hot reload와 같은 방식이 어려워지게 되고, 이는 개발 경험에 치명적인 영향을 끼칠것이다. (express app에 대한 소스코드가 살짝만 바뀌어도, 위 작업이 모두 동반되어야 하므로…)</p>\n<p>가장 이상적인 환경은, express까지 image화 하여 k8s에서는 ECR에서 받아 provision만 하면 되는 상황일 것이다.\n이 프로세스는 원격에서는 어느정도 잡혀져 있지만, 로컬에서는 어떻게 되어야 하는지 알아보는 중이다.</p>\n<p>⇒ 이 부분에 대해 현재는 2번의 방법을 유지하면서 minikube + <code class=\"language-text\">eval $(minikube docker-env)</code> 조합으로 알아보고 있는 중이다. 이 방법을 사용하게 되면, 원격의 이미지 저장소로 push pull 과정 없이 local에서 build한 image를 k8s에서 그대로 사용할 수 있을것으로 기대된다.</p>","frontmatter":{"title":"부스트캠프 2019 맴버쉽 28","date":"September 22, 2019"}}},"pageContext":{"slug":"/boost-camp-membership/28/","previous":{"fields":{"slug":"/boost-camp-membership/27/"},"frontmatter":{"title":"부스트캠프 2019 맴버쉽 27"}},"next":{"fields":{"slug":"/read-a-book/TDD-kent-beck-day1/"},"frontmatter":{"title":"Test Driven Development 1"}}}}}