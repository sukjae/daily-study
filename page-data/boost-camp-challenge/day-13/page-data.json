{"componentChunkName":"component---src-templates-blog-post-js","path":"/boost-camp-challenge/day-13/","result":{"data":{"site":{"siteMetadata":{"title":"Daily Study | Sukjae"}},"markdownRemark":{"id":"29322242-701a-51fa-8216-9583dc1f1c2c","excerpt":"피어 세션 중 생각 정리 전날 구현한 코드에 대해 다시 한번 정리하는 시간을 갖습니다 Model-Controller 기능 구현을 용이하게 하고, 구조화 하기 위해 Model/Controller/Util/Starte…","html":"<h2>피어 세션 중 생각 정리</h2>\n<blockquote>\n<p>전날 구현한 코드에 대해 다시 한번 정리하는 시간을 갖습니다</p>\n</blockquote>\n<h3>[Model-Controller]</h3>\n<blockquote>\n<p>기능 구현을 용이하게 하고, 구조화 하기 위해 Model/Controller/Util/Starte 로 파일구조를 나눴다.</p>\n</blockquote>\n<ul>\n<li><code class=\"language-text\">Model</code>은 데이터에 직접 접근하는 모든 작업을 수행한다.</li>\n<li><code class=\"language-text\">Model</code>에서 데이터는 로컬 변수를 사용했지만, DB와 같은 역할이 있을거라 가정하고 대부분의 에러를 호출한다.</li>\n<li><code class=\"language-text\">Controller</code>는 전반적인 명령 수행을 위한 로직이 swtich 문으로 분기 되어있다.</li>\n<li><code class=\"language-text\">Controller</code>에서는 직접 데이터를 접근할 수 없고, 오직 <code class=\"language-text\">Model</code>을 통해서만 전달받아 사용할 수 있다.</li>\n<li><code class=\"language-text\">Controller</code>속에 <code class=\"language-text\">View</code>를 담당하는 부분이 존재하며, 이는 <code class=\"language-text\">View</code>로 변화를 시켜줘야 하지만, 시간상의 제약으로 처리하지 못했다.</li>\n<li><code class=\"language-text\">Error</code>를 호출하는 쪽은 <code class=\"language-text\">Model</code>이므로, <code class=\"language-text\">Controller</code>에서는 필히 <code class=\"language-text\">try-catch</code>문으로 에러를 핸들링 해줘야 하는 입장이다.</li>\n<li><code class=\"language-text\">Error</code>를 호출하는 입장과 사용하는 입장의 구분이 명확하니, 불필요한 <code class=\"language-text\">Error</code>의 중복이 발생되지 않았다.</li>\n</ul>\n<h3>[Immutable]</h3>\n<blockquote>\n<p>모든 데이터를 처리하는 함수는 Immutable한 데이터의 흐름을 가져가도록 노력했다.</p>\n</blockquote>\n<ul>\n<li>함수는 순수하게 작성하기 위해 노력했다.</li>\n<li>이를 위해 사이드 이펙트를 최소화 하려 노력했고, 그 수단으로 Immutable한 데이터 접근을 수행하였다.</li>\n<li>새로운 배열을 반환하는 <code class=\"language-text\">reduce</code>, <code class=\"language-text\">filter</code>, <code class=\"language-text\">map</code>등의 기능을 활용하였다.</li>\n<li>편의를 위해 Shallow Copy를 통한 새로운 배열/객체(데이터)의 반환을 사용하였다.</li>\n<li>그러나, 연산에 필요한 배열/객체(데이터)의 구조가 복잡해 질수록 이를 처리하기 위한 로직이 복잡해 졌다.</li>\n<li>spread-syntax를 최대한 활용하여 변수들의 사용을 최소화 하였지만, 여전히 코드를 읽기 난해하다.</li>\n<li>\n<p>이 부분을 해결하기 위해선</p>\n<ul>\n<li>추후에 별도의 immutable 라이브러리를 사용하거나</li>\n<li>배열/객체 데이터의 중첩된 구조를 분리하여 관계형으로(<code class=\"language-text\">key</code> 사용) 만드는 방법 등이 있을것 같다.</li>\n</ul>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n  <span class=\"token operator\">...</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> x<span class=\"token punctuation\">.</span>folder_name <span class=\"token operator\">!==</span> folder_name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">...</span>copiedFolder<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    files<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n      <span class=\"token operator\">...</span>copiedFolder<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>files<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> x<span class=\"token punctuation\">.</span>file_name <span class=\"token operator\">!==</span> file_name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">{</span>\n        <span class=\"token operator\">...</span>copiedFile<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n        status<span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre></div>\n<blockquote>\n<p>코드 예시: 해석이 난해하지만, 변수 사용을 줄여봤다.</p>\n</blockquote>\n<h3>[상수의 활용]</h3>\n<blockquote>\n<p>데이터를 처리하는데 있어 오타등의 이유로 인한 에러를 방지하기 위해 상수 사용</p>\n</blockquote>\n<ul>\n<li>계속해서 사용되고, 접근하기 위한 <code class=\"language-text\">key</code>값으로 사용되는 <code class=\"language-text\">String</code>형태의 데이터를 따로 상수로 관리하였다.</li>\n<li>이와 같이 사용하면, <code class=\"language-text\">local</code>과 같이 의미는 같지만, 형태가 다른 문자열을 작성하는 실수를 방지할 수 있다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token constant\">LOCAL</span> <span class=\"token operator\">=</span> <span class=\"token string\">'LOCAL'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token constant\">REMOTE</span> <span class=\"token operator\">=</span> <span class=\"token string\">'REMOTE'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token constant\">WORKING</span> <span class=\"token operator\">=</span> <span class=\"token string\">'WORKING'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token constant\">STAGING</span> <span class=\"token operator\">=</span> <span class=\"token string\">'STAGING'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token constant\">COMMITED</span> <span class=\"token operator\">=</span> <span class=\"token string\">'COMMITED'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>이와 더불어 위 상수들을 배열로 만들어, 옵션들의 선택의 폭을 줄였다.(enum과 같은 느낌?)</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> locationOptions <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token constant\">LOCAL</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">REMOTE</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> statusOptions <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token constant\">WORKING</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">STAGING</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">COMMITED</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//...</span>\n<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>statusOptions<span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span>status<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//...  some logic</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>챌린지 중 느낀것</h2>\n<blockquote>\n<p>오늘 작성한 내용중 [자바스크립트 비동기] 에 대한 정리는 추가로 수정하여 데일리 스터디에 넣도록 한다. </p>\n</blockquote>\n<h3>구현 전 학습</h3>\n<p>오늘은 JS에서 중요한 비동기에 대한 개념이 나왔다. </p>\n<p>일전에 학습한 내용이였지만, 어제처럼 섣불리 구현하고 싶진 않았다. </p>\n<p>어제는 기술에 대한 학습을 충분히 하지 않고,구현을 하는데 급급했다.  이로 인해서 어느정도 구현을 하였지만, 기억에 남는 지식이 얼마 없었다. </p>\n<p>그래서 오늘은 안내에 나온 학습목표를 위한 내용을 충분히 숙지하고, 구현을 시작하였다. </p>\n<p>좀 어려운 개념이라 구현을 너무 늦게 시작한 감도 없지 않아 있지만 (오후 3시쯤 시작),  어느정도 성공적으로 마무리 지었다. </p>\n<p>과제가 너무 어렵게 나오면 이런식으로 하지 못하겠지만, 가능한 학습과 구현의 밸런스를 맞춰가며 적당하게 타협을 보고 싶다.(너무 한쪽으로만 가고 싶지 않다)</p>\n<p>앞서 언급 하였듯이, 오늘은 코드를 구현하기 전에 기술에대해 다시한번 조사를 시작하였다. </p>\n<p>일단, 내가 얕게 알고 있는 지식으로는 과제에서 나온 형태의 Event Loop에 대한 설명이 살짝 잘못 된 설명이라는 것을 알고 있다. </p>\n<p>이에 대해 확실히 정리하기 위해 계속해서 학습을 하였다. </p>\n<p>그러나 안타깝게도, 용어의 난해함과 내용이 너무 추상적이여서 충분히 이해를 하지 못했다. </p>\n<p>하지만, 이해하려 노력하는 과정에서도 많은 배움을 얻을 수 있었다. </p>\n<h3>구현 하며 느낀점</h3>\n<p><code class=\"language-text\">setTimeout</code> <code class=\"language-text\">setInterval</code> 등의 기능들을 활용하여 비동기/동기를 오가며 문제를 해결했다. </p>\n<p>남들은 신기하도록 쉽게 해결 하지만, 나는 구현에 큰 어려움을 겪었다 ㅠㅠ</p>\n<p>그럼에도 구현을 하며 비동기에 대한 이해가 늘어 난것 같다. </p>\n<p>특히 오늘 느낀것중 가장 큰 배움은 다음과 같다. </p>\n<ul>\n<li>서로 다른 무한 루프를 돌리는 방법</li>\n<li>서로 다른 무한 루프가 돌아가는 중에 다음 줄을 실행하는 방법</li>\n<li>그러면서 비동기도 생각하는 방법</li>\n</ul>\n<h4>[서로 다른 무한 루프를 돌리는 방법]</h4>\n<p>이 부분은 <code class=\"language-text\">setInterval</code> 을 하면 된다. </p>\n<p><code class=\"language-text\">while</code> 등의 방법으로 무한 루프를 돌리면, 루프 밖을 나가 다른것을 실행하러 나가면 이를 다시 돌아올 방법이 마땅치 않다. </p>\n<p>이 상황에서 <code class=\"language-text\">setInterval</code>을 하면, <code class=\"language-text\">clear</code> 하지 않는 이상 계속 해서 실행 되기 때문에 무한루프와 같은 효과를 낼 수 있고, 이는 여러개 사용이 가능하다. </p>\n<h4>[서로 다른 무한 루프가 돌아가는 중에 다음 줄을 실행하는 방법]</h4>\n<p>앞서 설명한  맥락과 같다.  </p>\n<p>그런데 여기서 다음 실행할 코드를 비동기라 생각하고, 이 코드에 대한 순서를 고려한다면 구현이 좀 어려워진다. </p>\n<p>위의 <code class=\"language-text\">setInterval</code> 은 비동기 호출로서 </p>\n<ul>\n<li>다음에 동기가 나오면 동기를 먼저 실행하고,</li>\n<li>다음에 비동기가 나오면, 나오는 순간 바로 큐로 올려버린다.</li>\n</ul>\n<p>우리의 구현의 경우에는 두개의 무한루프를 돌리면서</p>\n<p>두 개 모두 루프를 벗어나 다른것을 실행할 수 있어야 했고</p>\n<p>그러면서 외부의 비동기 함수는 바로 큐로 올리면 안되고, 무한 루프 속 루프가 한차례 돌아간 후에 올려야 한다. </p>\n<p>여기서 마지막 부분에 대한 구현이 가장 어려웠다.  그 이유는</p>\n<ul>\n<li>\n<p>동시에 두개의 무한 루프를 돌리기 위해 <code class=\"language-text\">setInterval</code> 을 사용하면</p>\n<ul>\n<li>밖의 루프(<code class=\"language-text\">setInterval</code>) 와 내부의 루프 (<code class=\"language-text\">while</code> 등) 으로 구분되서 작동해야 한다.</li>\n<li>그런데, 밖의 루프가 interval time에 의해서 계속 실행되므로</li>\n<li>밖의 개수만큼 새로운 내부 루프가 생성된다.</li>\n<li>이로 인해 로직이 꼬이고, 진정한 무한루프에 빠져 버린다…</li>\n</ul>\n</li>\n<li>\n<p>만약에 밖의 루프(<code class=\"language-text\">setInterval</code>)만을 활용하여 코드를 작성하면</p>\n<ul>\n<li>외부에 있는 비동기 함수들이 바로 큐에 쌓여서</li>\n<li><code class=\"language-text\">setInterval</code> 과 시작선이 같아지고, 그것은 이번 구현 조건에 부합하지 않았다.</li>\n</ul>\n</li>\n</ul>\n<p>결국 나는 편법과 같은 방법을 사용해서 구현했고, 내일 다른 이들은 어떻게 구현했을지 기대 된다.</p>\n<h4>[나의 구현 방법 정리]</h4>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">outterFunc</span><span class=\"token punctuation\">(</span>time <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> count <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token comment\">// 어떤 조건</span>\n  <span class=\"token keyword\">let</span> lastTime <span class=\"token operator\">=</span> time<span class=\"token punctuation\">;</span> \n  <span class=\"token comment\">// ...클로져로 내부 변수</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>count <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// ... some logic</span>\n      count <span class=\"token operator\">-=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n      lastTime <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// 탈출 조건</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>count <span class=\"token operator\">===</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> lastTime <span class=\"token operator\">></span> <span class=\"token number\">5000</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// ...some logic</span>\n      process<span class=\"token punctuation\">.</span><span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// 현재 함수에서 벗어나 재귀로 새롭게 호출</span>\n    <span class=\"token comment\">// 단, 이 함수는 setTimeout 을 통해 한번 비동기로 실행</span>\n    <span class=\"token comment\">// 그러므로, 맨 처음 시작에서는 위의 코드로 동기적으로 실행되지만</span>\n    <span class=\"token comment\">// 그 다음부터는 비동기로 실행되고, 이 이후에 나오는 코드를 큐에 쌓을 수 있다</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>count <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">outterFunc</span><span class=\"token punctuation\">(</span>lastTime<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">outterFunc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h2>오전 시간에 느낀것</h2>\n<h3>위치 메서드</h3>\n<p><code class=\"language-text\">indexOf</code> 를 사용시에 주의해야 할 부분이 있다. </p>\n<p>그 것은 이 연산이 <code class=\"language-text\">===</code> 연산을 수행하여 값을 반환한다는 점이다. </p>\n<p>즉, 우리가 서로 다른 배열, 객체를 비교 연산자로 제공하면, 이를 찾지 못한다. </p>\n<p>이를 사용하는데 주의하도록 하자. </p>\n<p>예시)</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> p1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>name<span class=\"token operator\">:</span><span class=\"token string\">'lee'</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> p2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span>name<span class=\"token operator\">:</span><span class=\"token string\">'lee'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">const</span> p3 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>p1<span class=\"token punctuation\">]</span>\n\np2<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span>p1<span class=\"token punctuation\">)</span> <span class=\"token comment\">// -1 , 없음</span>\np3<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span>p1<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 0 , index 0 에 존재</span></code></pre></div>\n<h3>배열의 변환</h3>\n<p>배열의 기능을 이용하여 다양한 기본 자료구조를 구현할 수 있다. </p>\n<p>우리가 알고 있는 <code class=\"language-text\">push</code> <code class=\"language-text\">pop</code> <code class=\"language-text\">shift</code> <code class=\"language-text\">unshift</code> 를 사용하면 된다. </p>\n<p>stack 구조 : <code class=\"language-text\">push</code> + <code class=\"language-text\">pop</code></p>\n<p>queue(FIFO) 구조 : <code class=\"language-text\">push</code> + <code class=\"language-text\">shift</code></p>\n<p>LIFO 구조 : <code class=\"language-text\">pop</code> + <code class=\"language-text\">unshift</code> </p>\n<p>이때 주의해야 할 점이 있는데, <code class=\"language-text\">unshift</code> 연산자는 받은 인자를 한번에 처리한다. </p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> arr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\narr<span class=\"token punctuation\">.</span><span class=\"token function\">unshift</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"fist\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"second\"</span><span class=\"token punctuation\">)</span>\n\narr <span class=\"token comment\">//['first','second']</span></code></pre></div>\n<p>앞에서 하나씩 앞에 넣어서 second, first 순서가 될 수 있을거라 착각하면 안된다.</p>\n<p>이 오해는 다음과 같은 방향으로 갈거라 오해해서 생겼다.</p>\n<p><code class=\"language-text\">a → [ ]</code> </p>\n<p><code class=\"language-text\">→ [a]</code> </p>\n<p><code class=\"language-text\">b → [a]</code> </p>\n<p><code class=\"language-text\">→ [b,a]</code> </p>\n<p>결론은 아니다 다음과 같이 움직인다</p>\n<p><code class=\"language-text\">a,b → [ ]</code></p>\n<p><code class=\"language-text\">→ [a,b]</code></p>\n<h2>회고</h2>\n<p>오늘은 실수를 너무 많이 했다. </p>\n<p>master 브랜치에 issue를 올리고…</p>\n<p>master 브랜치에 PR을 보내버렸다…</p>\n<p>안되는 날은 뭘 해도 안되나 보다. </p>\n<p>오늘 실수를 다시 반복하지 않도록 항상 조심하자. </p>\n<p>피곤하다는 말로 변명을 할 수 없다.</p>","frontmatter":{"title":"부스트캠프 2019 챌린지 13일차","date":"July 31, 2019"}}},"pageContext":{"slug":"/boost-camp-challenge/day-13/","previous":{"fields":{"slug":"/boost-camp-challenge/day-12/"},"frontmatter":{"title":"부스트캠프 2019 챌린지 12일차"}},"next":{"fields":{"slug":"/daily/2019-08-01/"},"frontmatter":{"title":"ReactJS 와 HTML canvas 사용하여 사진 위에 그림 그리기"}}}}}