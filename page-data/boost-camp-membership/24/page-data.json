{"componentChunkName":"component---src-templates-blog-post-js","path":"/boost-camp-membership/24/","result":{"data":{"site":{"siteMetadata":{"title":"Daily Study | Sukjae"}},"markdownRemark":{"id":"89490b3e-ac2a-5fa7-934d-c66b64a5bc42","excerpt":"Socket.IO 삽질기 2 부스트 캠프 프로젝트 중에 채팅 기능을 구현해야 했고, 그 기술로 웹소켓을 선정하였다. \n개인적으로 두가지 후보를 고민하였는데, 하나는 AWS의 api gateway에서 제공하는 websocket이고, 다른 하나는 socket.io…","html":"<h2>Socket.IO 삽질기 2</h2>\n<p>부스트 캠프 프로젝트 중에 채팅 기능을 구현해야 했고, 그 기술로 웹소켓을 선정하였다.\n개인적으로 두가지 후보를 고민하였는데, 하나는 AWS의 api gateway에서 제공하는 websocket이고, 다른 하나는 socket.io였다. </p>\n<p>전자는 서버리스라는 매력 때문에 사용해보고 싶었고, 후자는 Node를 사용하는 현 상황에서 적합해 보였다. </p>\n<p>결국 Socket.IO를 사용하게 되었고, 그 과정에서 개인적으로 느낀점들을 적어본다. </p>\n<h2>Socket.IO에서 namespace와 room의 차이</h2>\n<p>처음에 들었던 느낌은, namespace라는 prefix와 같은 것이 존재하고, 그 내부에 room을 둘 수 있는 구조라 생각했엇다.\n그래서, 직감적으로 들었던 생각들은, namespace를 <code class=\"language-text\">/chat</code>으로 두고, 그 이후에 <code class=\"language-text\">roomId</code>를 room으로 둠으로서 두 유저간의 private chat을 구현할 수 있지 않을까 생각하였다. </p>\n<p>둘이 항상 같이 쓰일 것이라 생각하였지만, namespace와 room은 쓰이는 용도에서 차이가 있었다. (사실 항상 같이 쓰이긴 한다)</p>\n<p>작성된지 조금 지난 글이지만, 둘의 차이를 어느정도 짐작할 수 있는 글이 있다 .</p>\n<p><a href=\"https://stackoverflow.com/a/11751954/5755608\">socket.io rooms or namespacing?, 2015</a></p>\n<p>이 내용을 정리하면 다음과 같다 .</p>\n<h3>공통점</h3>\n<ul>\n<li>둘 모두 서버에서 생성된다</li>\n<li>복수의 namespace와 복수의 room은 같은 connection 위에 존재한다</li>\n<li>해당 namespace/room에 연결된 사용자에 한해서만 메세지가 전달된다.</li>\n</ul>\n<h3>namespaces 의 특징</h3>\n<ul>\n<li>client에서(사용자에 의해) 연결이 시작된다</li>\n<li>사용자는 서버에서 namespace가 이미 존재한 경우에만 연결할 수 있다.</li>\n<li>auth 관련 기능을 사용할 수 있다</li>\n</ul>\n<h3>room의 특징</h3>\n<ul>\n<li>서버쪽에서만 연결할 수 있다. </li>\n<li>namespace에 속해있다. (global)</li>\n</ul>\n<p>이 내용속에서 내가 가져갈 중요한 정보는, namespace는 client, room은 server 측에서 연결이 이루어진다는 것이다. </p>\n<h2>연결을 동적으로 만들 수 없을까</h2>\n<p>나의 첫 아이디어는, (유저(구매자) + 유저(판매자) + 상품) 를 통하여 채팅ID를 생성하고, 그 채팅Id를 room 으로서 사용하려 하였다. </p>\n<p>namespace는 일단은 chat을 두었는데, 채팅 ID는 사용자가 만들기 전까지 알 수 없었다.\n모든 가능성을 다 만들어 두고 하드코딩 할 수 없는 노릇이고, 이를 동적으로 만들 방법이 필요하였다 </p>\n<p>그 해결법이 잘 보이지 않았는데, 그 이유는 namespace/room 모두 string 형태로 하드코딩 하여 이벤트를 등록하는 형태였다.\n바보같지만, 처음에는 하드코딩되어 있으므로 그 부분을 변수로 치환할 생각을 못하고 서버 코드를 작성시 무조건 지정해 주어야 하는지 알았다. </p>\n<p>이 부분은 반은 맞고 반은 틀렸는데, 그 이유는 namespace의 경우는 생각한것 처럼 처음 생성시 string 형태로 지정해 줘야 하는 반면,\nroom의 경우에는 약간의 트릭을 가미하면 동적으로 string을 전달할 수 있었다. </p>\n<p>즉, 사용자에게 어떤 값을 받거나, 서버측에서 추가적으로 값을 생성하여 room의 string을 대체할 수 있었다. </p>\n<p>간단한 방법이지만, 이 방법을 찾기까지 시간이 많이 걸렸다. 그 이유는 이러한 방식이 생소했기 때문도 있는것 같다.\n결론적으로, 다음과 같은 스타일로 작성해 볼 수 있다. </p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// # 서버</span>\n<span class=\"token comment\">// namespace : chat 생성</span>\n<span class=\"token keyword\">const</span> chatIO <span class=\"token operator\">=</span> io<span class=\"token punctuation\">.</span><span class=\"token function\">of</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/chat'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 일단은 chat으로 연결을 함</span>\nchatIO<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'connection'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">socket</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 연결한 뒤, 사용자로 부터 emit을 받아서 입장</span>\n  socket<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'enterRoom'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">roomId</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 기존의 socket에 leave하는 부분은 일단 생략</span>\n    <span class=\"token comment\">// 사용자가 emit한 정보에 포함되어 있는 roomId를 토대로 room을 생성 및 등록</span>\n    socket<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span>roomId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 여기서 사용자가 message를 emit하면, 아래 callback이 실행</span>\n    socket<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'message'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">msg</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 이 부분이 중요</span>\n      <span class=\"token comment\">// 사용자 중에서 chat/roomId에 연결고리를 갖는 사용자에 한해서</span>\n      <span class=\"token comment\">// 전달 받았던 메세지를 돌려 보냄</span>\n      chatIO<span class=\"token punctuation\">.</span><span class=\"token function\">to</span><span class=\"token punctuation\">(</span>roomId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">emit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'message'</span><span class=\"token punctuation\">,</span> msg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// # 클라이언트</span>\nsocket<span class=\"token punctuation\">.</span>current <span class=\"token operator\">=</span> <span class=\"token function\">socketIOClient</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">http://localhost:5000/chat</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nsocket<span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">.</span><span class=\"token function\">emit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'enterRoom'</span><span class=\"token punctuation\">,</span> roomId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>코드를 살펴보면, 굉장히 난해하다…\n일단 위에서 말했듯이, </p>\n<ol>\n<li>namespace는 정적으로만 생성 가능하다</li>\n<li>room은 동적으로 생성이 가능하다. (존재하는 sockets에 join하는 방법이다)</li>\n<li>사용자는 namespace에 연결을 시도할 수 있다</li>\n<li>사용자는 room에 연결을 시도할 수 없다</li>\n<li>room은 오로지 서버에서 연결을 시도할 수 있다</li>\n</ol>\n<p>3~5번의 내용을 바탕으로 위 코드를 본다면, 편법이 보인다. </p>\n<ol>\n<li>사용자는 클라이언트에서 일단 chat(namespace)에 연결하고</li>\n<li>enterRoom에 roomId를 emit하고</li>\n<li>서버는 사용자가 emit한 enterRoom에서 roomId를 전달받아서</li>\n<li>동적으로 socket에 room을 등록한다</li>\n</ol>\n<p>마지막으로 중요한 특징이 있는데, <a href=\"https://stackoverflow.com/a/30442764/5755608\">참고</a></p>\n<p>클라이언트에서는\nnamespace의 경우에는 emit을 할 수 있는 반면,\nroom의 경우에는 특정 room으로 emit할 수 없다</p>\n<p>서버에서는\nnamespace,room 을 갖는 유저 모두에게 emit할 수 있다.</p>\n<h2>socket.io에서 인증은 어떻게?</h2>\n<p>일단 connection을 하기 위한 인증은 <a href=\"https://socket.io/docs/migrating-from-0-9/#Authentication-differences\">공식문서</a>에서도 나와있다. </p>\n<p>socket.io는 middleware를 제공하며, io connection 이전에 유저의 auth를 확인하는 로직을 넣어주면 된다. </p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">io<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">socket<span class=\"token punctuation\">,</span> next</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> handshakeData <span class=\"token operator\">=</span> socket<span class=\"token punctuation\">.</span>request<span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// make sure the handshake data looks good as before</span>\n  <span class=\"token comment\">// if error do this:</span>\n    <span class=\"token comment\">// next(new Error('not authorized'));</span>\n  <span class=\"token comment\">// else just call next</span>\n  <span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이 부분에서, JWT와 같은 방식을 사용해 유저의 기본적인 AuthN을 확인할 수 있다. </p>\n<p>또, 이 <code class=\"language-text\">io.use</code> 를 활용하여, 각가의 namespace 이전에도 별도의 로직을(middleware를) 넣을 수 있으니, 그 활용법이 다양하다. </p>\n<h2>그렇다면 권한은?</h2>\n<p>문제는 AuthZ이다. </p>\n<p>일차적으로 사용자 인증정보를 확인하여 connection을 만들어 주었으나, 우리의 채팅 서비스의 경우에는 판매자/구매자 만이 해당 채팅방에 들어갈 권리를 가져야 한다.\n아무런 방어책도 없는 상황에서는 roomId만 안다면 누구나 chat 에 들어갈 수 있으므로 적합하지 않다. </p>\n<p>이 방법에 대해서는 아직 그 해결법을 찾고 있는 중이지만, 세가지 방법이 있을 것 같다. 물론, 비효율적인 방법이 포함되어 있으므로 이해 바란다.(일단 선 구현!)</p>\n<ol>\n<li>매 요청마다 비동기적으로 roomId를 DB에서 조회하여 판매자/구매자 ID를 받아오고 요청과 비교한다</li>\n<li>사용자가 enterRoom을 하는 최초의 순간에만 비동기적으로 roomId를 DB에서 조회하여 판매자/구매자 ID를 받아오고 요청과 비교한다</li>\n<li>사용자가 채탕방에 입장하는 순간(재입장 포함) 클라이언트로 oauth 토큰이 발급되고, 그 토큰안에는 roomId가 포함되어 있어 매 요청마다 권한을 확인한다</li>\n</ol>\n<p>첫번째 방법은, 서버에 너무 부담이 크다. 물론 구현은 너무 쉽다… 하지만 패스!</p>\n<p>두번째 방법은 괜찮은 방법인듯 하고, 어느정도 최소한의 보안적인 측면을 만족하는 듯 하다.\n이 과정을 위해서는 보안적인 소켓 통신이 필요하고 <a href=\"https://stackoverflow.com/a/6601067\">다음과 같은 세팅을 할 수 있다.</a></p>\n<p>마지막 방법은 토큰의 만료시간이 존재한다는 점에서 두번째 보다는 조금 더 나은것 같기도 하다. 그러나, 별도의 OAuth 시스템을 구축해야 하고, 매 요청마다 검증을 해야 하므로 까다로운 방법이다. 과연 그 노력대비 얻는 부수 효과가 어느정도 일지 고민이다. </p>\n<p>일단 세가지 옵션중에서 잠재적으로 두번째 옵션을 선택하였다. 이 부분은 차차 더 고민하도록 한다. </p>","frontmatter":{"title":"부스트캠프 2019 맴버쉽 24","date":"September 18, 2019"}}},"pageContext":{"slug":"/boost-camp-membership/24/","previous":{"fields":{"slug":"/boost-camp-membership/23/"},"frontmatter":{"title":"부스트캠프 2019 맴버쉽 23"}},"next":{"fields":{"slug":"/boost-camp-membership/25/"},"frontmatter":{"title":"부스트캠프 2019 맴버쉽 25"}}}}}