{"componentChunkName":"component---src-templates-blog-post-js","path":"/boost-camp-membership/8/","result":{"data":{"site":{"siteMetadata":{"title":"Daily Study | Sukjae"}},"markdownRemark":{"id":"a48819af-bca5-5e98-a9f6-2868e3f84f0a","excerpt":"오늘의 배움 Express에서 미들웨어를 테스트하는 방법 Node 진영에서 사용할 수 있는 많은 테스트 라이브러리 들이 존재한다. 그중에서 나는 FE와의 통일성을 위하여 Jest…","html":"<h2>오늘의 배움</h2>\n<h3>Express에서 미들웨어를 테스트하는 방법</h3>\n<p>Node 진영에서 사용할 수 있는 많은 테스트 라이브러리 들이 존재한다.</p>\n<p>그중에서 나는 FE와의 통일성을 위하여 Jest를 정하였고, 다행히 이 도구가 어느정도 범용적인 용도를 갖고 있어 서버에서도 무난하게 녹아들 수 있었다.</p>\n<p>그러나 Server쪽의 테스트를 처음 접해보고, 그 중에서도 Middleware에 대해 처음 접해보니 테스트 코드를 어떻게 작성해야 하는지에 대한 의문이 들었다.</p>\n<p>테스트 코드, 그 중에서도 유닛 테스트를 작성하려 하는데 함수와는 다른 접근을 취해야 할 것 같았다 .</p>\n<p>예를 들어, 다음과 같은 코드가 있다고 가정하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">doesBodyExist</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">req<span class=\"token punctuation\">,</span> res<span class=\"token punctuation\">,</span> next</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>req<span class=\"token punctuation\">.</span>body <span class=\"token operator\">||</span> <span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span>req<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> res<span class=\"token punctuation\">.</span><span class=\"token function\">status</span><span class=\"token punctuation\">(</span><span class=\"token number\">400</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> doesBodyExist</code></pre></div>\n<p>사실 따지고 보면, 그냥 보통의 함수 이지만 req, res,next를 전달받아서 next를 호출하거나 res를 호출하는 형태의 미들웨어이다.</p>\n<p>next는 어찌보면 Callback이라 볼 수 있기 때문에 무언가 로직을 삽입할 수 있지만, res는 그 속의 객체, 그리고 그 속의 객체에 접근해야 한다.</p>\n<p>처음에는 기타 라이브러리를 통해 인자의 mock을 생성하는 방법을 고민하였다. 그러나, 간단한 유닛테스트에 아직까지 별도의 모듈 설치의 필요성을 느끼지 못하여 제외하였다.</p>\n<p>그 다음에 생각한 방법이 supertest를 활용하여 app을 테스트 하듯 하는 방식이였다.</p>\n<p>이 경우에 매 테스트마다 다음과 같이 app 전체를 불러와야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> request <span class=\"token keyword\">from</span> <span class=\"token string\">\"supertest\"</span>\n<span class=\"token keyword\">const</span> app <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"../app\"</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// our Node application</span>\n<span class=\"token comment\">//...</span>\n<span class=\"token function\">describe</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"api 테스트\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"GET: api가 열려있어야 한다\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">await</span> <span class=\"token function\">request</span><span class=\"token punctuation\">(</span>app<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">expect</span><span class=\"token punctuation\">(</span><span class=\"token number\">200</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token comment\">//...</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>이 방식의 가장 큰 단점은, 테스트가 너무 무거워 진다는 것이다.</p>\n<p>통합테스트를 위해서 이렇게 작성하는 것은 무방하나, 각각의 기능을 테스트 하기 위한 유닛테스트에서는 적절치 않아 보였다 .</p>\n<p>그래서 나는 결론적으로 Jest의 기본적인 기능을 활용하여 임의의 mock을 생성하여 테스트 코드를 작성하였다.</p>\n<p>이 경우 jest를 벗어나서 추가로 종속적인 모듈을 설치하지 않아서 좋고, 가벼워서 더욱 좋다.</p>\n<p>이 방식의 핵심은, middleware를 단순히 인자 3개를 받는 보통의 함수로 생각하는 것이다.</p>\n<p>그러니깐, 우리의 Middleware는 인자 3개를 받고, 상황에 따라 아래 두 가지중 하나의 행동을 하는 함수이다.</p>\n<ol>\n<li>next(3번째 인자)로 전달된 함수를 실행한다 (별 이상이 없어서 다음 middleware로 넘어가는 상황)</li>\n<li>res 의 어떠한 method에 어떠한 값을 넣어 실행한다. (보통 200, 400 등의 http status code이다)</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> doesBodyExist <span class=\"token keyword\">from</span> <span class=\"token string\">\"../middlewares/checkBody\"</span>\n\n<span class=\"token function\">describe</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Middleware: 테스팅\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">describe</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"req.body 확인용 테스트\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> res <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n      status<span class=\"token operator\">:</span> jest<span class=\"token punctuation\">.</span><span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n        json<span class=\"token operator\">:</span> jest<span class=\"token punctuation\">.</span><span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"body가 있으면 next가 실행된다\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> req <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n        body<span class=\"token operator\">:</span> <span class=\"token string\">\"hi\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token keyword\">const</span> next <span class=\"token operator\">=</span> jest<span class=\"token punctuation\">.</span><span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">await</span> <span class=\"token function\">doesBodyExist</span><span class=\"token punctuation\">(</span>req<span class=\"token punctuation\">,</span> res<span class=\"token punctuation\">,</span> next<span class=\"token punctuation\">)</span>\n      <span class=\"token function\">expect</span><span class=\"token punctuation\">(</span>next<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toBeCalled</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token comment\">//..</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>다른 더 좋은 방법이 있을지 모르지만, 지금으로서는 나에게는 위 방법이 최선인것 같다.</p>\n<h2>오늘의 고민들</h2>\n<h3>스크럼</h3>\n<p>기존에 작성하였던 유저 스토리와, 이에 대한 백로그를 수정하였다. 크게 정해진 규칙 없이, 내 입맛대로 변형을 주었다.</p>\n<p>기존의 유저스토리에서는 FE에 대한 고려만 하고, 서버측 고려는 하지 않았다. 보통 유저 스토리는 유저의 관점에서 작성되므로 FE에 대한 내용만이 언급된다.</p>\n<p>나는 Server쪽의 내용을 정리하기 위해 <code class=\"language-text\">유저 스토리</code> 와 <code class=\"language-text\">비하인드 스토리</code> 로 나누어 정리하였다.</p>\n<p>이렇게 되면 유저 스토리에서는 유저와 App간의 인터렉션에 대해 정의할 수 있고,</p>\n<p>비하인드 스토리에서 App과 App간의 인터렉션에 대해 정의할 수 있다.</p>\n<p>지금으로서는 기능명세서를 스프린트 백로그 속에 포함 시켰지만, 갈수록 유저 스토리가 비대해져 가는것을 느낀다. 추후에는 이 부분을 따로 관리하는 방법에 대해 고민하도록 해야겠다.</p>\n<h3>Server 측의 테스트에 대한 고민</h3>\n<p>오늘부터 TDD의 원칙에 맞춰 코드 작성을 시작하였다.</p>\n<p>선 코드 작성 후 테스트 작성이 아닌, 빨간불, 초록불, 리펙토링의 순서를 지키고자 노력하였다.</p>\n<p>어제 가장 작은 기능 단위 부터 큰 덩어리인 API로의 순서로 TDD를 하려 하였는데, 필요한 기능을 사전에 모두 정의내리기 어려워서 더 논리적이고 순차적으로 접근할 수 있도록 큰것(api단위의 테스트)에서 작은것(세부 기능, 미들웨어 테스트) 으로 테스트를 점점 세분화 하는 시도를 하였다.</p>\n<p>작성을 하며 떠오른 두가지 생각이 있었다.</p>\n<p>첫번째는, 이렇게 코드를 작성하다 보니 내가 TDD를 하는것인지 BDD를 하는것인지 햇갈리기 시작했다.</p>\n<p>이 부분에 대한 명확한 이해가 없어서 생기는 혼란이라 판단되어, 추후 다시 한번 BDD와 TDD를 비교 분석해야 겠다.</p>\n<p>둘쨰로 내가 작성하는 테스트 코드가 충분한 커버리지를 갖고 있는지에 대한 의문이였다.</p>\n<p>시간을 들여 열심히 코드를 작성하였는데, 너무 큰 틈들이 듬성듬성 있으면 그것은 사실상 무의미한 시도라 생각한다.</p>\n<p>이 부분에 대해 어떻게 하면 적당히 납득할만한 커버리지를 갖는 테스트를 작성할 수 있는지 고민이 필요하다.</p>\n<h3>함수나 미들웨어는 어느정도로 파편화하여야 할까</h3>\n<p>함수나 미들웨어를 아주 작은 단위로 세분화할 수 있다.</p>\n<p>오늘 내가 내린 결정은, 단위 테스트가 가능할 정도의 수준으로 코드를 나누는게 좋겠다는 결론을 내렸다.</p>\n<p>이러한 방법이 단위테스트에도 좋지만, 코드의 재 사용성에도 좋을 것이라는 판단 에서이다.</p>\n<h3>테스트를 한글로</h3>\n<p>지난번에 어디선가 테스트 코드에 대한 문장을 한글로 작성하는 것에 대해 들은적이 있다.</p>\n<p>외국인들과 협업을 해야할 때나, 많은 이들이 참고해야 하는 Commit message의 경우 최대한 영어를 사용함이 좋지만,</p>\n<p>버그가 발생하였을 때, 문제에 대한 빠른 판단이 필요한 경우에는 모국어를 사용하는게 좋다는 생각이 든다.</p>\n<p>다수의 인원이 모국어가 영어가 아닌 상태에서, 실질적인 문제에 대한 원인과 힌트를 어색한 번역투의 영어로 작성하여 혼선을 주기보다는 명확한 해석이 가능하도록 모국어로 작성하는게 좋겠다.</p>\n<h2>오늘의 회고</h2>\n<p>전반적으로 만족스러운 하루였다.</p>\n<p>너무 느러지지도 않고, 너무 조급하지 않게 코드를 작성할 수 있었다.</p>\n<p>지난날들 처럼 거대한 산에 가로막혀 아무것도 못하는 상황이 되지 않도록, 최대한 잘게 잘게 세분화하여 점진적으로 코드를 작성하려 노력했다.</p>\n<p>그 결과 코드의 작성 과정에서 오는 스트레스가 많이 줄어든것 같아 만족스럽다.</p>\n<p>물론 아직 납기일에 코드를 완성해야 하는 부담감이 있어 무작정 코드 작성을 시작해야 하는게 아닌가 하는 ㄴ걱정은 있지만, 나를 믿고 최대한 많은 내용을 배워가기 위해 도전하고 있다.</p>\n<p>물론 결과가 중요하지만, 그 과정 또한 중요하다.</p>\n<p>항상 매 순간 최선을 다하자.</p>","frontmatter":{"title":"부스트캠프 2019 맴버쉽 8","date":"September 02, 2019"}}},"pageContext":{"slug":"/boost-camp-membership/8/","previous":{"fields":{"slug":"/boost-camp-membership/7/"},"frontmatter":{"title":"부스트캠프 2019 맴버쉽 7"}},"next":{"fields":{"slug":"/boost-camp-membership/9/"},"frontmatter":{"title":"부스트캠프 2019 맴버쉽 9"}}}}}