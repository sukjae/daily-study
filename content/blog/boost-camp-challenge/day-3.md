---
title: 부스트캠프 2019 챌린지 3일차
date: "2019-07-17T00:00:00Z"
---

## 피어 세션 중 느낀것

오늘 역시 새로운 용어들을 많이 들었고, 다른 이들의 생각과 고민의 흔적을 들어볼 수 있었다. 

그중에 몇가지 기억에 남는 토론을 적는다. 


### thorw & try catch

에러를 핸들링 하기 위해서 try catch로 묶어주는 것이 좋은 디자인 패턴일까에 대한 고민이였다. 

나는 이 부분에 대해서 프런트앤드와 관련해서는 사용자의 앱이 crash될 수 있기 때문에 try catch로 묶기보단 console.error등의 방법을 쓰는게 나을것 같다는 생각을 전달 하였다. 


### 빈 객체를 만들고 외부에서 정의하는 패턴

> 이 부분은 아직 검증을 하지는 못했으니, 주말에 찾아봐야 한다.

어떤분이 다음과 같은 방식으로 코드를 작성하여 여쭤보았다 .

    const obj = {}
    obj.someMethod = function(){}
    obj.someProp = 1

내가 원래 주로 하던 방법은 obj을 정의하면서 method와 property를 정의하는것 이였는데, 

위 패턴의 용도를 알게 되었다. 

가장 중요하게는 서로 다른 메서드에서 서로를 참조할때 문제가 발생할 수 있다고 한다. 

예를들어 다음과 같은 상황을 얘기하는 것 같다.

```js
    const obj = {
    someMethod:function(){
    console.log(this.someOtherMethod())
    },
    someOtherMethod:function(){}
    }
```

그러나 빈 객체를 먼저 정의하고, 그 객체에 메소드를 이어 붙인다면, 순서를 잘 맞출 수 있을것이다. 

그러나 내가 들었던 생각은 

1. 어차피 호이스팅 되지 않던가? 객체안에서는 안되나?
2. 객체 안은 일단 생성하면 서로 참조할 수 있게 되지 않을까?

더 알아봐야 할듯 하다. 그러나 재밋는 발상이다. 


### monkey patch

대충 검색해 보았을때, 이에 대해 안티패턴, 폴리필 등의 키워드로 검색된다. 

오늘은 시간이 없어 제대로 알아보진 못했지만, 간단하게 들은 내용으로는 런타임에서 함수의 속성을 바꿔 다른 기능을 사용할 수 있게 하는 패턴인것 같다. 

내가 구현한 코드에 대해서 위 방법이라고 언급하셔서 찾아보려 한다. 

물론, 나는 이 몽키패치를 염두에 두고 개발한것은 아니였다. (위 정의만 봤을때는 내가 고려한 방법은 아닌것 같다. )

내가 고려한 방법은 함수형 프로그래밍에서 curried function을 사용하여 

- 같은 로그를 여러 함수들이 공유를 하며 사용할 수 있다
- 로그를 위한 장치는 다양한 방법들을 부착 시킬 수 있다

를 목표로 구현했었다. 

물론 내 생각대로 작성되지 않아 오해가 있을 수 있겠으나, 이 또한 나의 부족함이니 더 연구해보도록 하겠다. 


### 전략 패턴, 팩토리 패턴

이 부분은 주말에 꼭 찾아보도록 하겠다. 



## 챌린지 중 느낀것

### 재귀에 대한 학습 필요성

막상 재귀 함수를 작성하려 하니 생각보다 원활하게 작성이 되지 않았다 .

return을 쌓아가며 최종 반환값을 기대하는 방식으로 짜야 할것 같음에도 

잘 되지 않아 클로저를 통한 변수 공유를 시도하였다.

물론 마지막에는 코드가 잘 나온것 같다. 

코드를 작성하며 재귀와 reduce를 사용함에 있어

reducer가 갑자기 떠올랐다. 그리고 문득 든 생각이, 

어차피 acc로 다음 인자를 전달받고, 이 acc는 계속 변화할 수 있고 단지 다음에 대한 refer의 용도라면

매 순간 재귀를 돌릴 때 마다 합성된 값을 acc로 넘겨, 최종적으로 이 값을 전달받으면 되지 않는가 라는 생각이 들었고

옮은 생각 이였다. 

이 패턴은 내가 redux를  활용하며 당연스래 사용하던 패턴이였는데, 쌩으로 구현하며 내 부족함을 또 한번 느끼게 되었다.


### reduce에 대한 고찰

Array클래스에 있는 다양한 내장함수를 새로이 구현하는 기능을 시도 하였다. 

그중에서 reduce가 가장 시간이 오래 걸리고, 골치 아팠는데 

그 이유는 내가 reduce에 대해 잘못 알고 있던 부분 때문 이였다. 

나는 reduce의 인자로 callback함수와 뒤의 초기값 인자가 필수 요소라고 착각하고 있었다. 

그러나, 뒤의 초기값에 대한 인자는 선택사항이며 이에 따라 다르게 행동함을 알게 되었다. 

정리하자면, initialValue에 따라 초기에 두 부분이 영향을 받는다. (currentIndex,currentValue)

일단 initialValue가 주어진다면 currentIndex는 0, 주어지지 않는다면 1로 셋팅 된다

또한 initialValue가 주어지다면 currentValue는 initialValue가 되고, 주어지지 않는다면 array의 첫번째 아이템으로 셋팅된다. 

재귀함수로 구현한 reduce에서 첫번째 accumulator값은 currentValue로 시작하는데, 

이를 쉽게 정리하면 다음과 같을것 같다. 

> initialValue(초기값)이 주어진 경우, initialValue를 포함하여 array전체를 한번 훑는다. (n+1)

> initialValue(초기값)이 주어지지 않은 경우, array전체를 한번 훑는다. (n)


### return값이 없는 함수의 경우 jest에서 어떻게 테스트 할까

이 부분에 대해 고민을 많이 하였다. 

일단 .toBe나 toEqual 등의 방법을 사용하기 위해서는 전후의 값을 비교해야 한다. 

console.log같은 방법이 아닌, return을 비교해야 하는데 forEach같은 것은 어떻게 테스트할 수 있을까

처음에 든 생각은 snapshot을 활용한 방법이였으나, 또 아닌것 같아 그만 두었다 

두번째로 든 생각은 외부의 값에 변화를 이르키고, 그 값을 비교하는 것이다.

즉 의도적으로 side effect를 이르키는 방법이다. 

이 방법이 구현하기도 생각하기도 쉬워서 이렇게 하였다. 


### jest에서 블록당 독립된 테스트 환경 구축이 가능할까

jest에서 계속 테스트를 하니, 각각의 test문에서 함수가 실행되는 것이 독립된 공간에서 실행되는게 아닌듯 하다. 이를 완전히 격리시켜 줄 방법을 찾아봐야 하겠다. 


### map, reduce, filter등을 사용할때, arrow function을 사용하면 context가 변화되어 주의

항상 arrow function 사용시에 동적바인딩에 주의하여야 한다. 

이 부분을 조금 더 이해할 필요가 있고, 이 또한 주말에 집중해서 정리해야 겠다. 

fat arrow를 사용하면 다음과 같이 참조하는 context에 변화가 생기게 된다. 

물론 this를 활용하지 않음이 더 좋을것 같지만, 그럼에도 이런 일이 생길 수 있음을 숙지하고 있자 

```js
    [1,2,3].map((a,b,c)=>{console.log(this)},{a:1})
    // undefined
    
    [1,2,3].map(function(a,b,c){console.log(this)},{a:1})
    // {a:1}
```

## 회고

여러모로 힘든 하루였다. 

불합격 통보를 받고 정신적으로 힘든 상태에서 꾹꾹 참아가며 주어진 과제를 해나갔다. 

힘든 상황임에도 포기하지 않고 끝까지 해내서 뿌듯한 하루였다. 

내일은 더 발전된 모습의 내가 되었으면 한다.
