---
title: 부스트캠프 2019 챌린지 5일차
date: "2019-07-19T00:00:00Z"
---

## 피어 세션 중 느낀것

**문제에 맞딱드렸을땐, 정의한 가정에 오류가 있을 수 있음을 인식하자**

어제 작성한 코드중, 개선의 여지가 있음을 알게 되었다.

구체적으로 언급하면 다음과 같은 코드였는데, 이 코드를 줄일 수 있는 가장 핵심적인 방법은 처음 내린 가정을 수정하는 것 이였다.

**원래 작성한 코드**

```js
    const someFuncA(a,b,c)=>{}
    const someFuncB(a,b,c)=>{}
    const someWrapper(...args)=>{C:someFuncA(...args),S:someFuncB(...args)}

    const innerFunc = (acc, cur, i) => [...acc.slice(0, i),
    																		someFuncA(cur, B[i], acc[i]),
    																		someFuncB(cur, B[i], acc[i])]
    const outerFunc = (A, B) => A.reduce(innerFunc, []);
```

위 코드에서 보면, `someWrapper` 에서 `.C`와 `.S`를 분리할 방법을 찾지 못하여 함수를 분리하여 사용했다.

어떻게 하면 반환값에 필요한 모든 정보를 변수없이 넣을 수 있을지 고민하였고, 그 결과로 나온 형태는 다음과 같았다. (다음 코드로 가는 과정은 [[부스트캠프 4일차 챌린지중 느낀것](https://github.com/sukjae/daily-study/blob/master/boost-camp/day-4.md)] 을 참조 바란다)

`[...acc.slice(0, i),someFuncA(cur, B[i], acc[i]),someFuncB(cur, B[i], acc[i])]`

여기서 눈 여겨 봐야 할 점이, 어차피 `[S,C]` 순서로 만들어 진다는 것이다.

나는 `someWrapper` 함수가 두가지 정보를 내포 하고 있고, 그 정보는 각자 내포하는 의미가 다르므로

하나의 함수에 대한 하나의 반환값으로 표현하기 위해서는 객체로 표현함이 옳다고 생각했다. **(나의 가정)**

이를 배열로 표현하지 않은 이유는, 배열은 두 값이 서로 index로만 분리되어 있어, 사실상 같은 의미를 갖는 값들을 제공할때만 사용해야 한다 생각했다.

그러나, 피어세션중 다른 한 분이 객체가 배열로 표현하는것을 제안하셨고, 코드를 돌이켜 보니 충분히 가능한 방법이였다. 나는 내가 세웠던 가정이 불변의 규칙이라 생각하고, 이를 수정할 생각을 전혀 못하였는데, 내 반환값에 대한 구조를 다시 보니 다음과 같았다.

`[...prev, someFuncA(),someFuncB(),someFuncA(),someFuncB(),someFuncA(),...]`

즉, 어차피 같은 순서로 배열로 반환되게 된다.

즉, 나는 `.C`와 `.S` 값이 완전 독립적인 의미를 갖는다 생각하였지만, 사실은 두 값은 하나의 고통된 의미를 갖는 것이였다.

따라서 나의 코드를 다음과 바꾸니 훨씬 깔끔 해 졌다.

**최종 개선 코드**

```js
    const someFuncA(a,b,c)=>{}
    const someFuncB(a,b,c)=>{}
    // 반환값을 배열로 변환
    const someWrapper(...args)=>[someFuncA(...args),someFuncB(...args)]

    const innerFunc = (acc, cur, i) => [...acc.slice(0, i), someWrapper(cur, B[i], acc[i])]
    const outerFunc = (A, B) => A.reduce(innerFunc, []);
```

기존의 두 값을 각각 연산하여 두번의 함수를 호출하는 것에서, 하나의 함수를 호출하여 더 간략해진 코드로 작성이 가능해졌다.

## 금요일 프로젝트 중 느낀것

**역시 팀 프로젝트는 어렵다.**

팀 프로젝트를 진행하다 보면, 팀원들의 성향에 따라 분위기가 너무 급변한다.

적극적으로 참여를 꺼리고, 자기 주장이 강한(나의 얘기일 수 있다.) 사람들이 너무 많아지면,

프로젝트 디벨롭은 너무 다운되거나 너무 격양될 수 있다.

그럼에도, 혼자 하는것 보다는 머리를 맞대고 협업을 하는게 옳다.

힘들고, 귀찮다고 협업에 참여하는 기회를 놓쳐버린다면, 배우는것도 얻어가는것도 없을것이다.

**팀 프로젝트에서 토론은 공격이 아니라 단조(Forging)를 하는 과정이다**

팀 프로젝트를 함에 있어 가장 중요한 것은 의견 조율인것 같다.

운 좋게 팀원 모두가 비슷한 목적을 갖고 있다거나,

소수의 자기주장이 강한 분들이 리드하거나,

협업 경험이 많은 분들이 팀에 존재 한다면 의견 조율이 원활하게 돌아가겠지만 그런 상황은 많지 않다.

반면 자기 의견이 너무 없거나,

자신이 원하는 방향으로 흘러가지 않는다 하여 프로젝트에 참여를 잘 하지 않는다면

프로젝트에 진전이 있기 힘들고, 좋은 결과물이 나오기 어려운 것 같다.

결국 프로젝트를 진행하면서 나오는 토론은 서로를 공격하기 위한게 아니라,

더 좋은 결과물을 내기 위해 열을 내는 작업임을 왜 알지 못하는지 모르겠다.

우리는 칼을 들고 서로를 베기 위해 프로젝트를 하는게 아니라

더 강력한 칼을 만들기 위해 수도 없이 망치로 두들기는 작업을 하는 것이다.

## 추가적으로 마스터님께 질문한 부분들

### 회사에서 신입을 선발할 때 비 전공자, 학원 출신을 바라보는 시선이 어떠한가

요새 출신 학교, 출신 학과 등을 많이 보진 않는 편이다.

그러나 개발 관련 전문 용어를 모르고 있다면, 면접 등에서 불리할 수 있다. 부스트 캠프 맴버쉽 과정등에서 이와 관련한 전문 용어들을 다수 얻어 갈 수 있을 것이다.

### 과거에 부스트 캠프와 같은 넥스트를 진행하셨는데, 그때와 지금은 무엇이 달라졌나

그때와 지금의 방향은 비슷하다.

단지 그때는 주어진 문제를 학교의 형태로 해결하려 하였고,

지금은 학교와는 다른 형태(지금의 부스트캠프, 우아한테크코스 등)로도 가능함을 알고 시도하고 있다.

### 현업에서 프로젝트를 새로 시작할때 기술스택이나 라이브러리를 어떻게 선택하게 되나

상황에 따라 다른것 같다.

하지만 초기에는 대부분 CTO 등 개발을 총괄하시는 분들이 전반적인 역량을 파악하여 방향을 정하게 된다.

물론 역량과 자원이 된다면 실제 모든 중요 선택지를 구현하여 테스트 하는 방법을 사용하기도 한다 (카카오톡 예시)

### 채용시 알고리즘 테스트에 대한 관점

과거 토익, 토플 만능 시대와 비슷한 양상인것 같아 지양하고 싶다.

알고리즘 테스트는 최소한의 지식을 갖고 있다를 보여줄 뿐이지 업무의 역량을 파악하기 힘들다.

그러나 회사 입장에서는 이러한 기준으로 선발이 편해 도입을 많이 한다.

앞으로 회사들이 변화하였음 좋겠다.

## 회고

오늘은 챌린지 과정이 없어서 비교적 시간이 널널했다.

하지만, 언제나 그렇듯 내가 배움을 얻고자 한다면 더 큰 노력을 들여 배움을 구할 수 있다.

오늘 또한 많은 것을 느끼고, 많은 것을 배울 수 있는 하루였다.
