{"componentChunkName":"component---src-templates-blog-post-js","path":"/read-a-book/clean-architecture-day2/","result":{"data":{"site":{"siteMetadata":{"title":"Daily Study | Sukjae"}},"markdownRemark":{"id":"c0edb85c-5130-5ebb-9cbb-4e06e890cdca","excerpt":"원제 Clean Architecture 제목 클린 아키텍쳐 저자 Robert C. Martin ISBN 978-89-6626-247-2 독서 기간 2020-03-15 독서 량 CH…","html":"<table>\n<thead>\n<tr>\n<th>원제</th>\n<th>Clean Architecture</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>제목</td>\n<td>클린 아키텍쳐</td>\n</tr>\n<tr>\n<td>저자</td>\n<td>Robert C. Martin</td>\n</tr>\n<tr>\n<td>ISBN</td>\n<td>978-89-6626-247-2</td>\n</tr>\n<tr>\n<td>독서 기간</td>\n<td>2020-03-15</td>\n</tr>\n<tr>\n<td>독서 량</td>\n<td>CH3</td>\n</tr>\n</tbody>\n</table>\n<h2>시작하기 앞서…</h2>\n<p>단순히 코드를 작성하는게 아닌, 좋은 소프트웨어를 만들기 위해 읽게 되었다. 앞서 읽은 객체지향적인 사고들과 맞물려 좋은 아키텍쳐에 대한 고민을 담은 책이다. 현대의 프로그래밍에 대한 방법들은 모두 이러한 고민들을 바탕으로 이루어져 있으며 직접 적용을 하지 않더라도 생각을 확장하는데 큰 도움이 된다. 더욱 더 노력하여 장인이 될 수 있도록 하자!!</p>\n<h2>CH3</h2>\n<h3>설계 원칙</h3>\n<p>좋은 벽돌로 좋은 아키텍처를 정의하는 원칙이 필요한데, 그게 바로 <strong>SOLID</strong> 이다.(p62)\nSOLID 원칙의 목적은 중간 수준의 소프트웨어 구조가 다음과 같도록 만드는 것이다</p>\n<ul>\n<li>변경에 유연하다</li>\n<li>이해하기 쉽다</li>\n<li>많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다</li>\n</ul>\n<h3>단일 책임 원칙 (SRP)</h3>\n<p>SRP란</p>\n<blockquote>\n<p>단일 모듈은 변경의 이유가 하나, 오직 하나여야 한다. (p66)</p>\n</blockquote>\n<p>다르게 표현하면,</p>\n<blockquote>\n<p>하나의 모듈은 하나의, 오직 하나의 사용자 또는 이해관계자에 대해서만 책임 져야 한다</p>\n</blockquote>\n<p>최종적으로,</p>\n<blockquote>\n<p>하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.</p>\n</blockquote>\n<p>이는 하나의 모듈이 하나의 액터에 대한 기능과 정보를 품고 있는, 즉 응집된 집합임을 시사한다.</p>\n<p>SRP는 서도 다른 액터가 의존하는 코드를 서로 분리하라고 조언한다.</p>\n<p>여기서 조심해야 하는 것은, SRP가 <strong>단 하나의 일만 해야 한다는 원칙이 아니라는 것</strong>이다. 이렇게 단 하나의 일만 해야 한다는 원칙은 함수들을 리펙토링하는 저수준의 작업에서 사용되는 원칙이다.(함수는 반드시 하나의, 단 하나의 일만 해야 한다는 원칙, p66)</p>\n<p>또한 SRP는 메서드와 클래스 수준임을 명심하자. 컴포넌트 수준에서는 동일한 기준이 폐쇄 원칙 이라는 용어로 적용된다.</p>\n<h3>개방-폐쇄 원칙 (OCP)</h3>\n<p>OCP란</p>\n<blockquote>\n<p>소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다 (p74)</p>\n</blockquote>\n<p>코드의 수정이 아닌, 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 해야 한다. (p64)</p>\n<p>어떻게 하면 이렇게 구성할 수 있을까?</p>\n<p>SRP에 의해서 책임을 분리하였다면, 그 후로 한 책임의 변경에 대해 다른 책임은 영향을 받지 않도록 설계 되어야 한다. 그래야 마음 놓고 코드를 추가할 수 있을 것이다. 이를 위해서는 클래스 단위로 분할한 뒤 컴포넌트 단위로 구분해야 한다.</p>\n<p>그러나 소프트웨어의 특성상, 하나의 변화가 다른 곳에 전혀 영향을 미치지 않게 할 순 없다. 하지만 필요에 따라 변화로 부터 최대한 숨겨 보호할 수 있다.</p>\n<p>변경이 잦은 컴포넌트를 저수준으로 내리고, 이 변화로 인해 고수준의 컴포넌트가 영향을 받지 않는 형태의 의존성 계층구조를 만들면 어느정도 OCP의 원칙을 따랐다고 볼 수 있을 것이다.</p>\n<h3>리스코프 치환 원칙 (LSP)</h3>\n<blockquote>\n<p>자료형 S가 자료형 T의 하위 타입이라면, 행위의 변화 없이 T의 객체를 S의 객체로 치환 가능하다.</p>\n</blockquote>\n<p>반대로도 성립한다.</p>\n<p>즉, LSP는 하위 타입에 대한 원칙이다.</p>\n<p>이는 위배하는 사례로 쉽게 이해가능하다. 유명한 정사각형/직사각형 문제에서 나오듯이 하위 타입으로 정하고자 하는 후보가 다른 행동을 한다면, 이는 하위 타입이 될 수 없으며 LSP에 위배된다. (직사각형은 가로 세로가 독립적으로 욺직이지만, 정사각형은 종속적이다.) 별도의 불필요한 메커니즘을 추가하지 않기 위해 LSP를 잘 따라 구현하도록 하자.</p>\n<p>LSP는 아키텍처 수준까지 확장될 수 있는 원칙이다.</p>\n<h3>인터페이스 분리 원칙 (ISP)</h3>\n<blockquote>\n<p>사용하지 않는 것에 의존하지 않아야 한다.</p>\n</blockquote>\n<p>이 책에서 유저 셋이 서로 다른 메소드를 하나으 클래스로 부터 사용 하는 것을 보여준다. 이는 앞서 나온 SRP와는 다른데, SRP의 예시에서는 세명의 유저가 서로 다른 액터였기 때문이다.\n책의 예시의 경우에는, 클래스간의 의존을 끊어주기 위해 인터페이스를 끼어 넣는다. 하지만 이는 언어의 타입에(정적, 동적) 따라 다른 상황이 발생한다. 정적의 경우에는 보통 의존성이 생겨 이를 분리해야 하지만, 동적의 경우에는 런타임 추론이 발생하여 의존성이 없기 떄문이다.(더 생각해보면, 동적 언어를 사용하면 결합도가 낮은 시스템을 만들 수 있다고 한다)그렇다고, ISP가 언어적 문제를 해결하기 위한 원칙은 아니라고 한다.</p>\n<h3>의존성 역전의 원칙 (DIP)</h3>\n<blockquote>\n<p>고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안된다. 대신 세부사항이 정책에 의존해야 한다(p64)</p>\n</blockquote>\n<p>이 원칙을 지켜 유연성이 극대화된 시스템을 만드는데, 유연성이 극대화된 시스템이란 소스코드 의존성이 추상에 의존하며 구체에는 의존하지 않는 시스템이다.(p92)</p>\n<p>그러나 보통의 경우 운영체제나 플랫폼 같이 안정성이 보장된 환경에 대해서는 DIP를 무시한다.(String은 구체 클래스이지만 추상화 하지 않는다)</p>\n<p>이 원칙을 따르기 위해선 다음과 같은 실천법을 따를 수 있다.</p>\n<ul>\n<li>변동성이 큰 구체 클래스를 참조하지 말라</li>\n<li>변동성이 큰 구체 클래스로부터 파생하지 말라</li>\n<li>구체 함수를 오버라이드 하지 말라</li>\n<li>구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라</li>\n</ul>\n<p>DIP 위배는 모두 없앨 수는 없다. 하지만 위배하는 클래스를 소수의 구체 컴포넌트 내부로 모아 분리할 수 있다.</p>","frontmatter":{"title":"Clean Architecture 2","date":"March 15, 2020"}}},"pageContext":{"slug":"/read-a-book/clean-architecture-day2/","previous":{"fields":{"slug":"/read-a-book/clean-architecture-day1/"},"frontmatter":{"title":"Clean Architecture 1"}},"next":{"fields":{"slug":"/projects/celry/combining-destructuring-with-parameter-properties/"},"frontmatter":{"title":"TS에서 Combining destructuring with parameter properties"}}}}}