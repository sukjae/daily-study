{"componentChunkName":"component---src-templates-blog-post-js","path":"/daily/2019-11-26/","result":{"data":{"site":{"siteMetadata":{"title":"Daily Study | Sukjae"}},"markdownRemark":{"id":"3dc357c5-1838-5240-841b-865b0ee59e75","excerpt":"프로젝트를 진행하며 Elasticsearch를 사용해야 할 일이 생겼습니다. 이에 따라 기본적인 사용 방법을 파악하기 위해 공식 문서의 get started 내용을 정리하였습니다. Elastic Stack 과거 ELK 스택으로 불리던 제품 묶음이 이제는 Elastic Stack…","html":"<blockquote>\n<p>프로젝트를 진행하며 Elasticsearch를 사용해야 할 일이 생겼습니다. 이에 따라 기본적인 사용 방법을 파악하기 위해 공식 문서의 get started 내용을 정리하였습니다.</p>\n</blockquote>\n<h3>Elastic Stack</h3>\n<p>과거 ELK 스택으로 불리던 제품 묶음이 이제는 Elastic Stack이라는 제품군으로 통일</p>\n<h3>DB등과 어떻게 연결해야 하는지</h3>\n<p>다양한 방법들이 존재한다. 그중 많이 쓰이는 방법은 Logstash를 사용하는 방법이다.</p>\n<p>input source(DB)와 한개 이상의 output sinks(Elastic Search) 중간에 연결고리로 작용하는 pipeline을 생성한다.</p>\n<p>Logstash는 데이터를 연결하기 위한 다양한 source 와 sink의 종류에 대응하여 라이브러리를 제공한다.</p>\n<p>mongodb의 경우에는 output(sink)에 대한 라이브러리가 제공되지만, input으로서는 제공되지 않는다</p>\n<p>input 리스트</p>\n<p><a href=\"https://www.elastic.co/guide/en/logstash/current/input-plugins.html\">https://www.elastic.co/guide/en/logstash/current/input-plugins.html</a></p>\n<p>output 리스트</p>\n<p><a href=\"https://www.elastic.co/guide/en/logstash/current/output-plugins.html\">https://www.elastic.co/guide/en/logstash/current/output-plugins.html</a></p>\n<h3>Elasticsearch REST API의 3가지 query방법</h3>\n<p>출처: <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/search-analyze.html\">https://www.elastic.co/guide/en/elasticsearch/reference/current/search-analyze.html</a></p>\n<ul>\n<li>structured queries</li>\n<li>full text queries</li>\n<li>complex queries</li>\n</ul>\n<p><strong>structured queries</strong></p>\n<ul>\n<li>SQL에서 구성 하는것과 유사한 방법</li>\n</ul>\n<blockquote>\n<p>you could search the <code class=\"language-text\">gender</code> and <code class=\"language-text\">age</code> fields in your <code class=\"language-text\">employee index</code> and sort the matches by the <code class=\"language-text\">hire_date</code> field</p>\n</blockquote>\n<p><strong>Full-text queries</strong></p>\n<blockquote>\n<p>find all documents that match the query string and return them sorted by relevance</p>\n</blockquote>\n<ul>\n<li>relevance는 how good a match they are for your search terms.</li>\n</ul>\n<p><strong>complex queries</strong></p>\n<p>위 <strong>structured queries</strong>와 <strong>full text queries</strong> 를 합친 방식</p>\n<p><strong>추가적으로,</strong></p>\n<p>또한 다음과 같은 기능을 제공한다</p>\n<p>phrase searches, similarity searches, and prefix searches, and get autocomplete suggestions</p>\n<p>또한, 지리적 query와 대수적인 query 모두를 고성능으로 제공한다.</p>\n<p>위 모든 query는 Elasticsearch의 포괄적인 JSON스타일의 쿼리(Query DSL)을 통해 사용할 수 있다.</p>\n<p>이 뿐만 아니라, SQL형태의 query도 적용 가능하다.</p>\n<h1>docker &#x26; Elasticsearch</h1>\n<h2>설치</h2>\n<p>출처: <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html\">https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html</a></p>\n<p>두가지 방법이 존재한다.</p>\n<p>나의 경우에는 간단한 테스트를 위한 환경 구성이므로 single node도 무방해 보인다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># docker image pull\ndocker pull docker.elastic.co/elasticsearch/elasticsearch:7.4.2\n# docker run\ndocker run -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; docker.elastic.co/elasticsearch/elasticsearch:7.4.2</code></pre></div>\n<p>이렇게 올라간 엘라스틱서치를 확인하기 위해 다음과 같은 명령어 타입</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">╰─ curl -X GET &quot;localhost:9200/_cat/health?v&quot;\n\n# 결과\nepoch      timestamp cluster        status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent\n1574745447 05:17:27  docker-cluster green           1         1      0   0    0    0        0             0                  -                100.0%</code></pre></div>\n<p>위의 예시에서 보이듯이, elasticsearch는 restful api로 명령어를 수행 하는듯 하다.</p>\n<h2>사용법</h2>\n<p>Rest api로 설정이 가능하니, 데이터 주입이 가능함도 당연하다.</p>\n<h3>등록</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">curl -X PUT &quot;localhost:9200/customer/_doc/1?pretty&quot; -H \\\n&#39;Content-Type: application/json&#39; -d&#39;\n{\n  &quot;name&quot;: &quot;John Doe&quot;\n}\n&#39;\n\n# 결과\n{\n  &quot;_index&quot; : &quot;customer&quot;,\n  &quot;_type&quot; : &quot;_doc&quot;,\n  &quot;_id&quot; : &quot;1&quot;,\n  &quot;_version&quot; : 1,\n  &quot;result&quot; : &quot;created&quot;,\n  &quot;_shards&quot; : {\n    &quot;total&quot; : 2,\n    &quot;successful&quot; : 1,\n    &quot;failed&quot; : 0\n  },\n  &quot;_seq_no&quot; : 0,\n  &quot;_primary_term&quot; : 1\n}</code></pre></div>\n<h3>조회</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">curl -X GET &quot;localhost:9200/customer/_doc/1?pretty&quot;\n\n# 결과\n{\n  &quot;_index&quot; : &quot;customer&quot;,\n  &quot;_type&quot; : &quot;_doc&quot;,\n  &quot;_id&quot; : &quot;1&quot;,\n  &quot;_version&quot; : 1,\n  &quot;_seq_no&quot; : 0,\n  &quot;_primary_term&quot; : 1,\n  &quot;found&quot; : true,\n  &quot;_source&quot; : {\n    &quot;name&quot; : &quot;John Doe&quot;\n  }\n}</code></pre></div>\n<h3>벌크 주입</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">curl -H &quot;Content-Type: application/json&quot; \\\n-XPOST &quot;localhost:9200/bank/_bulk?pretty&amp;refresh&quot; \\\n--data-binary &quot;@accounts.json&quot;\n\n# 결과\n\n...\n{\n      &quot;index&quot; : {\n        &quot;_index&quot; : &quot;bank&quot;,\n        &quot;_type&quot; : &quot;_doc&quot;,\n        &quot;_id&quot; : &quot;717&quot;,\n        &quot;_version&quot; : 1,\n        &quot;result&quot; : &quot;created&quot;,\n        &quot;forced_refresh&quot; : true,\n        &quot;_shards&quot; : {\n          &quot;total&quot; : 2,\n          &quot;successful&quot; : 1,\n          &quot;failed&quot; : 0\n        },\n        &quot;_seq_no&quot; : 943,\n        &quot;_primary_term&quot; : 1,\n        &quot;status&quot; : 201\n      }\n    },\n...</code></pre></div>\n<p>신기하게도, 상대경로나 절대경로가 아닌 <code class=\"language-text\">@</code> 를 파일 앞에 두어야 한다.</p>\n<p><code class=\"language-text\">./accounts.json</code> 으로 해보니 에러가 뜬다.</p>\n<h3>index들 조회</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">curl &quot;localhost:9200/_cat/indices?v&quot;\n\n# 결과\nhealth status index    uuid                   pri rep docs.count docs.deleted store.size pri.store.size\nyellow open   bank     Vi8pnBZRQHaZY5J2NrdM0g   1   1       1000            0    414.2kb        414.2kb\nyellow open   customer aZHN_XWAQjC0j_W1yiYLRg   1   1          1            0      3.5kb          3.5kb</code></pre></div>\n<p>정상적으로 1000개의 bank정보가 주입 되었음을 확인할 수 있다.</p>\n<h3>검색</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">curl -X GET &quot;localhost:9200/bank/_search?pretty&quot; \\\n-H &#39;Content-Type: application/json&#39; -d&#39;\n{\n  &quot;query&quot;: { &quot;match_all&quot;: {} },\n  &quot;sort&quot;: [\n    { &quot;account_number&quot;: &quot;asc&quot; }\n  ]\n}\n&#39;\n\n# 결과\n{\n  &quot;took&quot; : 384,\n  &quot;timed_out&quot; : false,\n  &quot;_shards&quot; : {\n    &quot;total&quot; : 1,\n    &quot;successful&quot; : 1,\n    &quot;skipped&quot; : 0,\n    &quot;failed&quot; : 0\n  },\n  &quot;hits&quot; : {\n    &quot;total&quot; : {\n      &quot;value&quot; : 1000,\n      &quot;relation&quot; : &quot;eq&quot;\n    },\n    &quot;max_score&quot; : null,\n    &quot;hits&quot; : [\n      {\n        &quot;_index&quot; : &quot;bank&quot;,\n        &quot;_type&quot; : &quot;_doc&quot;,\n        &quot;_id&quot; : &quot;0&quot;,\n        &quot;_score&quot; : null,\n        &quot;_source&quot; : {\n          &quot;account_number&quot; : 0,\n          &quot;balance&quot; : 16623,\n          &quot;firstname&quot; : &quot;Bradshaw&quot;,\n          &quot;lastname&quot; : &quot;Mckenzie&quot;,\n          &quot;age&quot; : 29,\n          &quot;gender&quot; : &quot;F&quot;,\n          &quot;address&quot; : &quot;244 Columbus Place&quot;,\n          &quot;employer&quot; : &quot;Euron&quot;,\n          &quot;email&quot; : &quot;bradshawmckenzie@euron.com&quot;,\n          &quot;city&quot; : &quot;Hobucken&quot;,\n          &quot;state&quot; : &quot;CO&quot;\n        },\n        &quot;sort&quot; : [\n          0\n        ]\n      },\n... 9 more</code></pre></div>\n<p>기본적으로, hits의 배열(검색에대한 결과)은 검색 조건에 맞는 첫 10개의 documents를 포한한다.</p>\n<p><strong>이 응답 JSON에는 결과값과 다음과 같은 정보를 포함하고 있다.</strong></p>\n<ul>\n<li>took : query를 위해 소요된 시간. milliseconds</li>\n<li>timed_out: 검색 요청이 시간 초과가 되었는지 여부 확인</li>\n<li>_shards: 얼마나 많은 수의 shard가 검색되었는지, 그중 몇개의 shard가 성공/실패/건너띄었는지 의 정보</li>\n<li>max_score: 유사한 document중 가장 높은 점수</li>\n<li>hits.total.value: 얼마나 많은 수의 document가 조건과 부합하였는지</li>\n<li>hits.sort: 정렬 포지션 (관련 점수로 정렬되지 않았을 경우)</li>\n<li>hits._score: document의 유사 점수 (match_all를 사용시에 사용 불가)</li>\n</ul>\n<p>다음과 같이 sort를 제한할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">curl -X GET &quot;localhost:9200/bank/_search?pretty&quot; -H &#39;Content-Type: application/json&#39; -d&#39;\n{\n  &quot;query&quot;: { &quot;match_all&quot;: {} },\n  &quot;sort&quot;: [\n    { &quot;account_number&quot;: &quot;asc&quot; }\n  ],\n  &quot;from&quot;: 10,\n  &quot;size&quot;: 10\n}\n&#39;</code></pre></div>\n<p>또한, 다음과 같이 특정 문구를 검색할 수 있다.</p>\n<p>이 경우에, elasticsearch의 점수 알고리즘에 의해서 score를 측정하고, 가장 높은 점수 순으로 정렬된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">curl -X GET &quot;localhost:9200/bank/_search?pretty&quot; \\\n-H &#39;Content-Type: application/json&#39; -d&#39;\n{\n  &quot;query&quot;: { &quot;match&quot;: { &quot;address&quot;: &quot;mill lane&quot; } }\n}\n&#39;</code></pre></div>\n<p>위의 경우에는, mill와 lane을 포함하는 document를 가져오고, 점수화 하여 보여준다.</p>\n<p>반면, <code class=\"language-text\">mill lane</code> 을 모두 포함하고 싶은 경우에는 다음과 같이 진행한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">curl -X GET &quot;localhost:9200/bank/_search?pretty&quot; \\\n-H &#39;Content-Type: application/json&#39; -d&#39;\n{\n  &quot;query&quot;: { &quot;match_phrase&quot;: { &quot;address&quot;: &quot;mill lane&quot; } }\n}\n&#39;\n\n# 결과\n&#39;\n...\n    &quot;max_score&quot; : 9.507477,\n    &quot;hits&quot; : [\n      {\n        &quot;_index&quot; : &quot;bank&quot;,\n        &quot;_type&quot; : &quot;_doc&quot;,\n        &quot;_id&quot; : &quot;136&quot;,\n        &quot;_score&quot; : 9.507477,\n        &quot;_source&quot; : {\n          &quot;account_number&quot; : 136,\n          &quot;balance&quot; : 45801,\n          &quot;firstname&quot; : &quot;Winnie&quot;,\n          &quot;lastname&quot; : &quot;Holland&quot;,\n          &quot;age&quot; : 38,\n          &quot;gender&quot; : &quot;M&quot;,\n          &quot;address&quot; : &quot;198 Mill Lane&quot;,\n          &quot;employer&quot; : &quot;Neteria&quot;,\n...</code></pre></div>\n<p>이 경우, 정확히 맞는 단어를 포함해야 하는 경우로 보인다, 다음과 같은 경우는 아무것도 나오지 않는다</p>\n<p>완벽하게 단어가 매칭 되어야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">curl -X GET &quot;localhost:9200/bank/_search?pretty&quot; \\\n-H &#39;Content-Type: application/json&#39; -d&#39;\n{\n  &quot;query&quot;: { &quot;match_phrase&quot;: { &quot;address&quot;: &quot;mi lane&quot; } }\n}\n\n# 결과\n...\n&quot;hits&quot; : {\n    &quot;total&quot; : {\n      &quot;value&quot; : 0,\n      &quot;relation&quot; : &quot;eq&quot;\n    },\n    &quot;max_score&quot; : null,\n    &quot;hits&quot; : [ ]\n  }...</code></pre></div>\n<p>보다 복잡한 쿼리를 진행하기 위해서는 <code class=\"language-text\">bool</code> 쿼리를 사용해야 한다.</p>\n<p><code class=\"language-text\">bool</code> 을 사용하여 복수의 쿼리 조건을 합칠 수 있다.</p>\n<p>이를 활용하여 Boolean query에서는 다음 세가지 조건을 구사할 수 있다. (==query clause)</p>\n<ul>\n<li>required (<code class=\"language-text\">must</code>)</li>\n<li>desirable (<code class=\"language-text\">should</code>)</li>\n<li>undesirable (<code class=\"language-text\">must_not</code>)</li>\n</ul>\n<p>위 query clause중 <code class=\"language-text\">must</code> 와 <code class=\"language-text\">should</code> 는 얼마나 잘 맞는지가 document의 relevance score에 영향을 미친다.</p>\n<p><code class=\"language-text\">must_not</code> 은 <code class=\"language-text\">filter</code> 처럼 다뤄진다. 이 부분은 score에 영향을 미치지 않는다.</p>\n<p>예시)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">curl -X GET &quot;localhost:9200/bank/_search?pretty&quot; -H &#39;Content-Type: application/json&#39; -d&#39;\n{\n  &quot;query&quot;: {\n    &quot;bool&quot;: {\n      &quot;must&quot;: [\n        { &quot;match&quot;: { &quot;age&quot;: &quot;40&quot; } }\n      ],\n      &quot;must_not&quot;: [\n        { &quot;match&quot;: { &quot;state&quot;: &quot;ID&quot; } }\n      ]\n    }\n  }\n}\n&#39;</code></pre></div>\n<p><code class=\"language-text\">must_not</code> 이외에도, 명시적으로 필터의 속성을 이용 함으로서 포함하거나 불포함 하고자 하는 document를 정해줄 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">curl -X GET &quot;localhost:9200/bank/_search?pretty&quot; -H &#39;Content-Type: application/json&#39; -d&#39;\n{\n  &quot;query&quot;: {\n    &quot;bool&quot;: {\n      &quot;must&quot;: { &quot;match_all&quot;: {} },\n      &quot;filter&quot;: {\n        &quot;range&quot;: {\n          &quot;balance&quot;: {\n            &quot;gte&quot;: 20000,\n            &quot;lte&quot;: 30000\n          }\n        }\n      }\n    }\n  }\n}\n&#39;</code></pre></div>\n<h3>aggregations</h3>\n<p>이 작업은, 공통된 요소로 묶어서 보는 요약본 같은 느낌이다. (집합)</p>\n<p>예를 들어, How many account holders are in Texas?” or “What’s the average balance of accounts in Tennessee? 와 같은 질문을 던져볼 수 있다.</p>\n<p>terms 를 이용하여 다음과 같이 질의할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">curl -X GET &quot;localhost:9200/bank/_search?pretty&quot; -H &#39;Content-Type: application/json&#39; -d&#39;\n{\n  &quot;size&quot;: 0,\n  &quot;aggs&quot;: {\n    &quot;group_by_state&quot;: {\n      &quot;terms&quot;: {\n        &quot;field&quot;: &quot;state.keyword&quot;\n      }\n    }\n  }\n}\n&#39;</code></pre></div>\n<p>이 경우에, 우리는 field중에 state의 값에 따라 group을 생성해 준다.</p>\n<p>위의 group<em>by</em>state는 namepix 정도로 생각하면 될듯 하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># 결과\n{\n  &quot;took&quot; : 100,\n  &quot;timed_out&quot; : false,\n  &quot;_shards&quot; : {\n    &quot;total&quot; : 1,\n    &quot;successful&quot; : 1,\n    &quot;skipped&quot; : 0,\n    &quot;failed&quot; : 0\n  },\n  &quot;hits&quot; : {\n    &quot;total&quot; : {\n      &quot;value&quot; : 1000,\n      &quot;relation&quot; : &quot;eq&quot;\n    },\n    &quot;max_score&quot; : null,\n    &quot;hits&quot; : [ ]\n  },\n  &quot;aggregations&quot; : {\n    &quot;group_by_state&quot; : {\n      &quot;doc_count_error_upper_bound&quot; : 0,\n      &quot;sum_other_doc_count&quot; : 743,\n      &quot;buckets&quot; : [\n        {\n          &quot;key&quot; : &quot;TX&quot;,\n          &quot;doc_count&quot; : 30\n        },\n        {\n          &quot;key&quot; : &quot;MD&quot;,\n          &quot;doc_count&quot; : 28\n        },\n        {\n          &quot;key&quot; : &quot;ID&quot;,\n          &quot;doc_count&quot; : 27\n        },\n...</code></pre></div>\n<p>aggregation을 중첩하여 더 복잡한 요약본을 생성할 수도 있다 .</p>\n<p>이 경우에는 주별 평균 계좌 잔고를 측정할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">curl -X GET &quot;localhost:9200/bank/_search?pretty&quot; \\\n-H &#39;Content-Type: application/json&#39; -d&#39;\n{\n  &quot;size&quot;: 0,\n  &quot;aggs&quot;: {\n    &quot;group_by_state&quot;: {\n      &quot;terms&quot;: {\n        &quot;field&quot;: &quot;state.keyword&quot;\n      },\n      &quot;aggs&quot;: {\n        &quot;average_balance&quot;: {\n          &quot;avg&quot;: {\n            &quot;field&quot;: &quot;balance&quot;\n          }\n        }\n      }\n    }\n  }\n}\n&#39;</code></pre></div>\n<p>또, 다음과 같이 정렬도 가능하다. .</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">curl -X GET &quot;localhost:9200/bank/_search?pretty&quot; -H &#39;Content-Type: application/json&#39; -d&#39;\n{\n  &quot;size&quot;: 0,\n  &quot;aggs&quot;: {\n    &quot;group_by_state&quot;: {\n      &quot;terms&quot;: {\n        &quot;field&quot;: &quot;state.keyword&quot;,\n        &quot;order&quot;: {\n          &quot;average_balance&quot;: &quot;desc&quot;\n        }\n      },\n      &quot;aggs&quot;: {\n        &quot;average_balance&quot;: {\n          &quot;avg&quot;: {\n            &quot;field&quot;: &quot;balance&quot;\n          }\n        }\n      }\n    }\n  }\n}\n&#39;</code></pre></div>","frontmatter":{"title":"Elasticsearch 기본 정리","date":"November 26, 2019"}}},"pageContext":{"slug":"/daily/2019-11-26/","previous":{"fields":{"slug":"/daily/2019-11-10/"},"frontmatter":{"title":"JS Map에서 forEach, key값 뽑기 & Array에서 indexof vs findIndex"}},"next":{"fields":{"slug":"/online-conference/aws-iam-policies/"},"frontmatter":{"title":"IAM 정책 기본적인 내용 정리"}}}}}