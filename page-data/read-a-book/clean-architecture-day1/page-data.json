{"componentChunkName":"component---src-templates-blog-post-js","path":"/read-a-book/clean-architecture-day1/","result":{"data":{"site":{"siteMetadata":{"title":"Daily Study | Sukjae"}},"markdownRemark":{"id":"6c9bbe68-1980-506b-a06a-b161d21ef9a6","excerpt":"원제 Clean Architecture 제목 클린 아키텍쳐 저자 Robert C. Martin ISBN 978-89-6626-247-2 독서 기간 2020-03-12 독서 량 CH1, CH…","html":"<table>\n<thead>\n<tr>\n<th>원제</th>\n<th>Clean Architecture</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>제목</td>\n<td>클린 아키텍쳐</td>\n</tr>\n<tr>\n<td>저자</td>\n<td>Robert C. Martin</td>\n</tr>\n<tr>\n<td>ISBN</td>\n<td>978-89-6626-247-2</td>\n</tr>\n<tr>\n<td>독서 기간</td>\n<td>2020-03-12</td>\n</tr>\n<tr>\n<td>독서 량</td>\n<td>CH1, CH2</td>\n</tr>\n</tbody>\n</table>\n<h2>시작하기 앞서…</h2>\n<p>단순히 코드를 작성하는게 아닌, 좋은 소프트웨어를 만들기 위해 읽게 되었다. 앞서 읽은 객체지향적인 사고들과 맞물려 좋은 아키텍쳐에 대한 고민을 담은 책이다. 현대의 프로그래밍에 대한 방법들은 모두 이러한 고민들을 바탕으로 이루어져 있으며 직접 적용을 하지 않더라도 생각을 확장하는데 큰 도움이 된다. 더욱 더 노력하여 장인이 될 수 있도록 하자!!</p>\n<h2>CH1</h2>\n<h3>소개</h3>\n<p>1장에는 아키텍쳐(설계)에 대한 간단한 정의와 그 필요성에 대해 언급하고 있다. 이 부분에 대해 깊이 기록하기 보다, 느낌으로 받아드리고 필요한 경우에는 책을 참고해 보기 바란다.\n그중 몇가지 와닿았던 내용을 기록하자면,</p>\n<blockquote>\n<p>빨리 가는 유일한 방법은 제대로 가는 것이다.(p13)</p>\n</blockquote>\n<h3>기능과 아키텍처 둘 중 어느 가치가 더 높은가</h3>\n<p>동작하도록 만드는게 중요한가, 시스템의 변화에 용이하도록 하는게 중요한가. 책에서는 이 물음에 답을, 절대적인 것은 없지만 아이젠하워 매트릭스를 예로 들어 생각을 전하고 있다.\n중요함과 긴급함은 우선순위를 매겨 내려야하고, 그 우선순위에 따라 선택함이 맞다고 보는 것 같다.(즉, 상황에 따라 답은 다르다…) 하지만 저자가 주의하라 당부하는것이 있는데, 그것은 긴급하지만 중요하지 않은 기능에 대한 우선순위를 긴급하면서 중요한 문제로 격상하곤 한다는 것이다. 긴급하지 않지만 중요한 것은, 긴급하지만 중요하지 않은 것 보다 앞서야 한다. 그럼에도 긴급한 것만 쳐내다 보니 중요한 작업(아키텍처)를 신경쓰지 못하곤 한다.</p>\n<p><strong>우선순위 (p20)</strong></p>\n<ol>\n<li>긴급하고 중요한</li>\n<li>긴급하지 않지만 중요한</li>\n<li>긴급하지만 중요한</li>\n<li>긴급하지도 중요하지도 않은</li>\n</ol>\n<h2>CH2</h2>\n<h3>패러다임</h3>\n<p>저자는 패러다임에 대한 정의를 다음과 같이 하고 있다.</p>\n<blockquote>\n<p>패러다임은 프로그래밍을 하는 방법으로, 대체로 언어에는 독립적이다.\n패러다임은 어떤 프로그래밍 구조를 사용할지, 언제 구조를 사용해야 할지 결정한다. (p24)\n패러다임은 무엇을 해야 할지 보다 <strong>무엇을 해서는 안 되는지를</strong> 말해준다. (p27)</p>\n</blockquote>\n<p>저자는 세가지 패러다임을 ch2에서 다루고, 이 세가지 패러다임 이외의 패러다임은 더 이상 없을 것이라 한다.</p>\n<ol>\n<li>구조적 프로그래밍</li>\n<li>객체지향 프로그래밍</li>\n<li>함수형 프로그래밍</li>\n</ol>\n<p>책에서는 이 후로 각각의 패러다임이 나오게 된 역사와 아이디어를 정리한다. 그 역사를 기억함은 크게 중요할지 모르겠지만, 패러다임과 아키텍처의 세 가지 큰 관심사(함수, 컴포넌트 분리, 데이터 관리)가 어떻게 서로 연관되는지 주목하라 한다.</p>\n<h3>구조적 프로그래밍</h3>\n<blockquote>\n<p>구조적 프로그래밍은 제어흐름의 직접적인 전환에 대해 규칙을 부여한다. (p26)</p>\n</blockquote>\n<p>앞서 연구자들은 초기에 존재한 goto 방식이 더 작은 단위로 재귀적으로 분해하는데 방해가 된다는 사실을 발견하였다. 이 부분이 중요한 이유는, 모듈을 분해할 수 없다면 합리적으로 증명할 때 필수적인 기법인 분할 정복 접근법을 사용할 수 없기 때문이다.(p31)</p>\n<p>이와 더불어 매우 중요한 사실을 발견하게 되었는데, 그것은 <strong>모든 프로그램을 순차(sequence), 분기(selection), 반복(iteration)이라는 세가지 구조만으로 표현</strong> 할 수 있다는 것을 증명해 낸다.</p>\n<p>이러한 중요한 발견들로 인하여, 현대의 대부분의 언어는 제어흐름을 제약없이 제어할 수 있는 선태권을(goto) 제거한체 제공하게 되었고, 결과적으로 우리는 구조적 프로그래머가 되었다. (p33)</p>\n<p>구조적 프로그래밍을 통해 모듈을 더 작은 단위로 재귀적으로 기능적 분해할 수 있게 되었다. 이를 통해 우리는 고수준의 기능을 계속해서 저수준의 함수로 분해할 수 있게 되었으며 이 과정에서 제어구조를 이용해 표현할 수 있게 되었다.</p>\n<h3>객체지향 프로그래밍</h3>\n<blockquote>\n<p>객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 대해 규칙을 부과한다. (p26)</p>\n</blockquote>\n<p>이 챕터에서 객체지향 패러다임에 대한 모든내용을 포함하진 못한다. 하지만 몇가지 생각해볼만한 아이디어들을 던저준다.</p>\n<p>이 책에서는 객체지향에서 주요하게 다루는 세가지 성질(캡슐화, 상속, 다형성)이 우리가 말하는 “객체 지향 언어”에서만 적용될 수 있는 아이디어는 아니라고 설명하고 있다. 캡슐화의 경우에는 오히려 C언어에서 java등보다 더 잘 정의될 수 있다고 한다. 이 부분은 나중에 더 깊이있는 학습을 할때 돌아오겠지만, 지금은 간단히 그렇다는 사실만 받아들이고 넘어가기로 했다.</p>\n<p>이 챕터에서 말하고 싶은 중요한 아이디어는, 결과적으로 우리가 객체지향에서의 성질이라 부르는 캡슐화, 상속, 다형성이 실은 객체지향만이 아닌 소프트웨어 설계 전반에 걸쳐 언어에 제약없이 적용할 수 있고 해야하는 개념이라 말하고 싶은 것 같다.</p>\n<p>그럼에도 객체지향은 매우 중요하고, 여기서 중심적으로 다루는 주제 이기 때문에 객체지향에 대해 다음과 같이 요약하고 있다</p>\n<blockquote>\n<p>객체지향이란 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다(p51)</p>\n</blockquote>\n<blockquote>\n<p>객체지향과 다형성을 통해 고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장할 수 있다.</p>\n</blockquote>\n<h3>함수형 프로그래밍</h3>\n<blockquote>\n<p>함수형 프로그래밍은 할당문에 대해 규칙을 부과한다. (p27)</p>\n</blockquote>\n<p>함수형 언어에서 중요한 요소인 불변성과 순수성에 대해 간단히 다루고 있다. 간단히 정리하자면, 다음과 같다.</p>\n<p>함수형 언어에서 변수는 변경되지 않는다. 즉 불변성을 갖는다.(p55)이는 동시성 어플리케이션을 구성하고 관리하는데 큰 도움이 되는데, 함수형 프로그래밍을 통해 동시성 어플리케이션에서 마주치는 모든 문제를 해결할 수 있다. 동시성 어플리케이션에서는 보통 경합(race), 교착상태(deadlock), 동시 업데이트(concurrent update)와 같은 문제가 발생하고, 그 이유는 대부분 가변 변수로 부터 오기 때문이다.</p>\n<p>그러나 이러한 이상적인 방법에 대한 실현 조건으로 저장공간이 무한하고, 프로세서의 속도가 무한히 빨라야 가능하다고 한다. 따라서 저자는 불변성의 실현에 대해 어느정도 타협을 해야 한다고 말한다. 애플리케이션, 혹은 그 내부의 서비스를 가변 컴포넌트와 불변 컴포넌트로 분리하는 일이 그 방법이다.</p>\n<p>또한 이벤트 소싱이라는 아이디어를 언급하는데, 개인적으로 단순 무식하며 강력한 방법이라 생각한다. 어쩌면 NoSQL로 흘러간 방향과도 어느정도 일맥상통할 것이다. 프로세서의 가격보다 저장공간의 가격이 월등하게 낮아졌고, 저장공간은 어마무시하게 저렴해 졌으니 말이다.</p>\n<p>그래서 이벤트 소싱은 <strong>상태가 아닌 트랜잭션을 저장</strong> 하는 전략이다. 상태가 필요해지면, <strong>최신 상태를 조회하는게 아니라 단순히 시작점부터 모든 트랜잭션을 처리</strong> 하는 것이다.(p59)\n(물론 이 과정에서 특정 시간에 체크포인트와 같은 기준점을 만드어, 연산을 줄이는 최적화도 가능하다고 한다)</p>\n<p>이를 통해 신박해지는 결과는, <strong>결과적으로 애플리케이션은 CRUD가 아니라 그저 CR만 수행하게 된다는 것이다</strong>(나는 이 부분에서 한번 더 아하! 를 느꼈다)</p>\n<p>또한 이미 이런 방식이 적용되는 분야가 있는데, 그것은 소스 코드 버전 관리 시스템이 이렇게 작동한다는 것이다. (예를 들어 git. 나도 처음에는 git이 변화에 대해서만 저장하는 줄 알았지만, 사실은 전체를 계속해서 저장해가는 방식이다)</p>\n<h3>결론</h3>\n<p>앞서 세가지 패러다임을 다뤘다.\n저자의 말에 따르면,</p>\n<blockquote>\n<p><strong>지난 반세기 동안 우리가(프로그래머) 배운것은 해서는 안 되는 것에 대해서다.</strong> (p60)</p>\n</blockquote>\n<p>이 부분에서 마지막으로 아하! 를 느꼈다. 나는 항상 개발을 생각하며 어떤 규칙을 따라야 하는지만 생각했다. 예를 들어, React에서는 component와 page라는 폴더로 구분되어야 하고 각각이 적절한 요소들이 들어가야 한다와 같은 <strong>해야하는 규칙에 대해서만 찾아보고 적용했다</strong>. 이러한 따를 수 있는 방법들이, 해서는 안되는 다양한 규칙들을 만족하기 위해 나온 것이라는 것을 이해하지 못한채 결과물만 가져가려 했던 것 같다.</p>\n<p>개발에서는 해야하는 일보다 더 중요한것은, <strong>해서는 안되는 것들과 이에 대한 이해</strong> 라는 사실을 이번 챕터를 통해 느끼게 되었다.</p>","frontmatter":{"title":"Clean Architecture 1","date":"March 12, 2020"}}},"pageContext":{"slug":"/read-a-book/clean-architecture-day1/","previous":{"fields":{"slug":"/tools/lucidchart/"},"frontmatter":{"title":"Lucid Chart"}},"next":{"fields":{"slug":"/read-a-book/clean-architecture-day2/"},"frontmatter":{"title":"Clean Architecture 2"}}}}}