---
title: 부스트캠프 2019 챌린지 12일차
date: "2019-07-30T00:00:00Z"
---

## 피어 세션 중 느낀것

### [async/await 사용에 대한 고민]

JS에서 `await` 연산자는 다음과 같은 특징을 갖고 있습니다. 

await 문은 async함수의 실행을 중단시키고, Promise가 fulfill되거나 reject되기를 기다리고, 다시 async함수를 실행시킵니다. 이때  await 문의 값은 Promise 에서 fulfill된 값이 됩니다.

만약 Promise가 reject되면, await은 reject된 값을 throw합니다.

await 연산자 다음에 나오는 문의 값이 Promise가 아니면 해당 값을 resolved Promise로 변환시킵니다.
[출처: MDN web docs](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/await)

즉, `await`의 결과 `Promise.resolve()`를 반환하여 `pending` 중인 `Promise`를 반환합니다. 
이와 더불어 비동기의 특성상, 비동기의 호출순서가 비동기의 실행순서를 보장하지 않습니다. 
우리의 미션의 경우 비동기와 동기 테스트를 작성한 순서에 맞게 호출할 필요가 있었습니다. 

저는 모든 함수를 비동기로 바꿔줄 경우 호출 순서에 이상이 생기는 것을 보고, 비동기 작업만을 `async/await`로 기다리고자 하였습니다. 
이를 위하여 `try-catch`문 내에서 `await`를 사용하기 전에, 해당 함수의 호출이 `Promise`를 반환하는 값인지 확인 하였습니다.

```js    
const tmp = cb();
if (tmp instanceof Promise) {
  console.log(tmp);
  await tmp;
}
```

### [테스트 실패를 판별하기 위한 고민]

우리의 테스트 코드는 여러가지 assertion을 진행합니다. 
이 assertion 중에서 어떤 부분에서 문제가 발생했는지 확인이 필요합니다. 
예를 들어, 연산의 결과`Success, Success, Fail`이 발생 한경우, 이는  `Fail`을 반환해야 합니다. 

이를 구현하기 위해, 각 연산의 결과 실패시 에러를 호출 하였고, 이를 `try-catch`로 감싸 주었습니다.

```js
const assert = {
  equal: (...args) => {
    if (args[0] === args[1]) {
      return true;
    }
    throw new Error('Test Fail');
  },
  ...
  
try {
  const tmp = cb();
  if (tmp instanceof Promise) {
    console.log(tmp);
    await tmp;
  }
  } catch (e) {
  if (e.message === 'Test Fail') {
    result = RED + FAIL + RESET;
  }
}

```

### [Jest 테스트 라이브러리]

> Jest는 JavaScript를 테스트하기 위한 Framework이다.

Jest는 다음과 같은 기능을 제공한다.
- Test launchers
- Testing structure
- Assertion functions
- Generate and display test progress and results
- Mocks, spies, and stubs
- Generate and compare snapshots
- Generate code coverage

**[Jest 라이브러리의 특징]**

이 중 우리는 기본적인 Assertion functions를 구현하였다. 
이외의 다양한 기능이 Jest에 존재하고, 이를 통하여 더 많은 방식의 테스트 기법 사용이 가능하다. 
특히, 우리의 경우 Unit test에만 치우쳐 테스팅을 진행 하였는데, 
위 도구를 사용하면 Integration testing, Functional testing(e2e)등 다양한 기법을 사용 가능하다. 

**[Jest 라이브러리의 기능]**

또한, 프런트 엔드를 개발할때 UI등에 대해 테스트를 작성하는것은 무척 고된 작업이다.
원하는 컴포넌트가 생성, 작동 하는지 확인하기위 airbnb에서 제작한 `enzyme` 을 주로 사용하는데, 
이 경우 매번 테스트를 작성할때 컴포넌트의 구조에 대한 명시가 필요하다.
반면, jest의 snapshot과 같은 기능을 사용하면, 이에 대한 추가적인 작성 없이 동일한 결과(컴포넌트의 생성)이 기대되는지 여부를 쉽게 판별할 수 있다. 

**[Jest 와 내 코드의 동작 방식 차이]**

jest의 동작 방식과 나의(혹은 다른 부캠원)의 작동방식 중 가장 두드러지는 차이는, 
jest는 모든 테스트를 실행한 뒤 결과를 정리해서 보여준다.(리포트와 같이)
반면, 우리의 코드는 하나의 테스트가 실행될때 마다 이에 대한 결과를 순차적으로 보여준다. 
특히, 우리의 구현에서 js코드내에 비동기 코드가 있을경우, 이 비동기 작업에 대한 결과를 기다리고, 이에 따라 사용자 또한 다음 결과를 기다리는데
jest의 경우에는 한번에 완성된 보고서를 보여주니 더욱 이용이 편리하다.

## 챌린지 중 느낀것

### 구조에 대한 고민

항상 문제가 주어지면, 그 문제를 해결하기 위한 자료의 구조를 정의하는게 필요하다. 

이 자료 구조가 초반에 잘못 정의되면, 후반에 굉장히 큰 고통으로 다가오곤 한다.

우리가 작성하는 함수들은 범용적으로 설계 되는 것이 아니라 주어진 문제를 해결하기 위해 제작되곤 한다. 

우리가 함수를 통해 받아야 할 값들과 반환값의 형태가 어느정도 정해져 있고, 이에 따라 내부의 로직이 고정되곤 한다. 이에 따라, 들어오는 값이 변하게 되면 로직도 변해야 하기에 수정에 큰 비용이 든다. (당연한 말을 길게 풀어써 봤다ㅋ)

튜토리얼등만 수행하였을 때는 데이터의 구조를 정의하는게 이리도 중요한지 몰랐다. 

어차피 접근해봐야 2 deep level정도로만 탐색하고, 반환할테니 맘편히 객체, 배열을 사용할 수 있었다. 

그러나, 오늘같이 배열과 객체가 같이 사용되면서 3층 이상 떨어지는 자료를 만들게 되면 이를 사용하는데 고민을 많이 해야한다. 

데이터를 단순히 mutable하게 하면 편하지만, 이것은 내가 원하는 방법이 아니다. 

가능한 모든 데이터의 흐름을 immutable하게 가져가기 위해 노력을 하다 보니 자료 구조가 복잡해질 수록 이에 대한 데이터 변환 비용이 기하급수적으로 귀찮아 지는것 같다. 

 

결론적으로 말해서, 내일부터는 사전에 모든 명세를 꼼꼼히 살펴보고 진행해야 겠다. 

원래 글을 잘 못 읽고, 이해가 느려 명세만 읽다보면 시간이 다 가버리곤 한다. 그래서 코딩 테스트같은 문제를 풀때도 일단 코드를 몇자 적어보고 시작하곤 하는데, 오늘은 너무 코드만 적었던것 같다. 

### 로직의 분리의 중요성

오늘 Model과 Controller 를 분리하여 작성 해 봤다. 

controller에서도 간단히 처리 됨에도 저장소와 1이라도 연관이 있으면 model에 작성하려 노력했다. 

이렇게 코드를 작성하니 로직이 비교적 단순해 지고, 함수의 사용이 명확해져서 재사용이 용이했다. 

계속 이런식으로 학습해보자.

### 공부를 먼저 하고 했어야...

위에도 언급했지만, 오늘은 명세를 꼼꼼히 읽어보지 못했다. 어제와 더불어 오늘도 명세가 잘 읽히지 않고 이해가 가지 않아 코드 작성을 하며 이해하려 했다. 

> 그러나, 이 접근법은 크게 잘못 되었다는 것을 집을 오며 깨달았다. 

결국 회사에서도 그렇지만, 어떻게 하라고 가이드 라인을 명확하게 주는 경우는 없다. 

항상 고민을 통해 내 스스로 가이드 라인을 만들어 가며 구현해야 하는데, 오늘의 경우에는 너무 과제 해결에만 집중했던 것 같다. 오늘 과제의 양이 많아서 제대로 보지 못했다는 것은 핑계다.

> 하나를 배우더라도 제대로 배워 보자는 나의 마음가짐은 어디를 갔는가...

오늘은 하나도 제대로 학습하지 못했다. 

반성하고, 내일은 오늘과 같은 실수를 범하지 말자. 


### 테스트의 부재

첫날 나의 다짐을 어겼다. 

코드 작성 중반쯤 되서야 내가 TDD나 기본적인 Test 코드를 작성하고 있지 않다는 것을 자각했다. 

코드 작성 초반에는 오히려 빨리빨리 되는 것 같았지만, 여러 부분에서 오히려 시간이 더디어 졌고, 결과적으로 낮은 품질의 소프트웨어와 더불어 미션을 완수하지 못했다. 

예를 들어, 오늘 나는 간단한 코드를 계속해서 콘솔에 타이핑을 하며 테스트 하였다. 

이는, 콘솔을 받는 함수와 별도로 테스트 환경을 통해 인위적으로 함수들을 호출하여 통합테스트를 진행할 수 있었던 부분이였다. 

또한 기본적으로 유닛 테스트도 작성 하지 않으니, 문제가 생겼을 때 이에 대한 수정이 번거롭고 흐름이 잘 이해되지 않았다. 

항상 그렇지만, 

복잡할수록 태스트가 필요하다

> 테스트에서 타협을 보지 말자


### 또 한번 immutable 에 대한 고민

위에서 살짝 언급했지만, immutable에 대한 고민을 계속 했다. 

특히 OOP의 개념보다는 함수적 사고를 갖고 프로그램을 작성하려 노력했기 때문에, 순수 함수를 작성하고자 노력했다. 

그러나, 원 데이터에 손상을 주지 않고 데이터를 수정하여 적용하는 로직들에서 너무 큰 복잡함이 따라 왔다. 

예를 들어 다음 코드를 살펴 보자...

```js
const store = [
    ...this.store.filter(x => x.some_name !== some_name),
    {
      ...copiedOutter[0],
      files: [
        ...copiedOutter[0].files.filter(x => x.some_other_name !== cf.some_other_name),
        {
          ...cf,
          status: 'in progress',
          modified_at: new Date(),
        },
      ],
    },
  ];
```

기존의 `store` 를 손상시키지 않고 shallow copy를 통하여 새로운 값을 포함하는 객체(또는 배열)을 조합하는 방식으로 작성하였다. 

단순 무식한 방법으로 immutable을 구현하려 하였는데, 깊이가 2단계 이상으로 들어가니 로직이 너무 복잡해 졌다 . 이 또한 `spread syntax` 덕분에 이만큼 줄어 들었음에도 아주 더티하다..

만약 내가 `store` 를 변형 시키고자 했다면 단순히 해당 프로퍼티에 접근해 값을 바꿔주면 끝났을 것이다. 

하지만, FP의 개념을 살리면서 이를 구현하자니 너무 복잡해 졌다. 

아직 간단한 방법은 찾지 못했다. (**라이브러리 없이 !!!!**) 

이에 대한 고민을 더 해보고, immutablejs와 같은 도구를 한번 더 살펴봐야 겠다. 

## 오전 시간에 느낀것

### Array 객체의 특징

- Array.prototype.length 는 읽기 전용이 아니다. 이 값을 덮어쓰면, 인스턴스가 변해버린다.

```js
const arr = new Array(5)
arr // [empty * 5]
arr.length // 5
arr.length = 3
arr // [empty * 3]
```

위처럼, 그냥 뒤의 값이 잘려 버린다. 조심하자. 

- Array는 new 키워드 없이도 생성이 가능하다

### Garbage Collection in JS

- 이 부분에 대한 책의 내용은 워낙 오래된 브라우저 기준이라 지금도 적용이 되는지 모르겠다.
- 이 부분에 대한 나의 생각은 그냥 큰 고민없이 로직을 작성하면 어느정도 브라우저가 해결해 줄것이다....ㅎ

## 회고

오늘은 아쉬움이 많이 남는 날이다. 

내일은 더 발전되고 변한 나의 모습이면 좋겠다. 

> 하나를 배우더라도 제대로 배워 보자

> 테스트에서 타협을 보지 말자
