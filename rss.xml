<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Daily Study | Sukjae]]></title><description><![CDATA[매일 매일 학습한 내용을 기록합니다.]]></description><link>https://sukjae.github.io/daily-study</link><generator>GatsbyJS</generator><lastBuildDate>Tue, 31 Mar 2020 07:06:37 GMT</lastBuildDate><item><title><![CDATA[TS에서 Combining destructuring with parameter properties]]></title><description><![CDATA[문제 현재 작성하고 있는 entities 의 클래스들은 아래와 같은 형태를 띄고 있다. 여기서, , ,  를 private으로 만들고, getter…]]></description><link>https://sukjae.github.io/daily-study/projects/celry/combining-destructuring-with-parameter-properties/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/projects/celry/combining-destructuring-with-parameter-properties/</guid><pubDate>Tue, 31 Mar 2020 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;문제&lt;/h2&gt;
&lt;p&gt;현재 작성하고 있는 entities 의 클래스들은 아래와 같은 형태를 띄고 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;HiData&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  my&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; string&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  name&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; string&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  is&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; string&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Hi&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; _my&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; string&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; _name&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; string&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; _is&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; string&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;hiData&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; HiData&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; my&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; name&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; is &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; hiData&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;_my &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; my&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;_name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; name&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;_is &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; is&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;my&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;_my
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;_name
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;is&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;_is
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;여기서, &lt;code class=&quot;language-text&quot;&gt;my&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;name&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;is&lt;/code&gt; 를 private으로 만들고, getter를 설정하기 위해 무수히 많은 코드가 중복된다.
너무 장황해져서, 이를 줄일 수 있는 방법을 찾고자 한다.
(결론을 말하자면, 아직 방법을 선택하지는 못했다…)&lt;/p&gt;
&lt;h2&gt;제약사항&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;모든 properties는 private이 되어야 함&lt;/li&gt;
&lt;li&gt;constructor 의 parameter는 객체의 형태여야 함&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;private을 고수하는 이유는, 외부에서 변경이 안되게 함이다.(아예 immutable 하게 readonly로 가져갈 고민도 하는 중)&lt;/p&gt;
&lt;p&gt;object로 constructor에 넘기고자 하는 이유는 해당 클래스의 사용 편리성등이다. (인자의 순서를 딱 맞춰야 하는 불편함 등)&lt;/p&gt;
&lt;h2&gt;중복을 줄일 수 있는 부분&lt;/h2&gt;
&lt;p&gt;private 키워드를 생성하는 부분과 constructor에서 동일한(유사한) 이름에 할당하는 부분을 줄여볼 수 있을 것이다.
그에 대한 이유에는 typescript의 &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/classes.html#parameter-properties&quot;&gt;parameter-properties&lt;/a&gt;에 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Parameter properties are declared by prefixing a constructor parameter with an accessibility modifier or readonly, or both. Using private for a parameter property declares and initializes a private member; likewise, the same is done for public, protected, and readonly.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;parameter-properties 코드 샘플&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// before&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Octopus&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; name&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;string&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;name&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; string&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; name
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// after&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Octopus&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; name&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; string&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;중복된 코드가 상당히 줄어 들었음을 알 수 있다.&lt;/p&gt;
&lt;p&gt;그러나 이 방법은 constructor 의 parameter로 destructuring 하였을때는 적용할 수 없다는 단점이 있다.
이에 대한 토론은 다음에서 확인 해 볼 수 있다. &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/5326&quot;&gt;TS Issue 5326&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;즉, 위 방법으로는 나의 2번 제약 사항을 충족할 수 없다.&lt;/p&gt;
&lt;p&gt;이에 대해 위 이슈에서 여러 아이디어들이 오고가는데, 그 중 많이 보이는 방법은 &lt;code class=&quot;language-text&quot;&gt;Object.assign&lt;/code&gt;을 사용하여 &lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt;와 연결하는 것이다.&lt;/p&gt;
&lt;h3&gt;&lt;code class=&quot;language-text&quot;&gt;Object.assign&lt;/code&gt;을 사용하여 &lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt;와 연결하는 코드 샘플&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ExampleArgs&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  firstArg&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; string&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  otherArg&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; number&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Example&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;kwargs&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; ExampleArgs&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; Object&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;assign&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; kwargs&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Example&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ExampleArgs&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이것은 나의 제약사항 중 2번째를 충족하지만, 다시 1번의 제약사항을 지킬 수 없게 된다. (public이 됨)&lt;/p&gt;
&lt;h2&gt;결론&lt;/h2&gt;
&lt;p&gt;결국 마땅한 방법을 찾지 못했다.&lt;/p&gt;
&lt;p&gt;나름 개인적으로 꼭 필요하다 생각한 두 조건이므로 그대로 유지하고, 중복 되더라도 일단은 코드를 장황하게 쓰기로 결정하였다. 이슈를 subscribe 해두어 기능이 추가되면 적용해야 겠다.&lt;/p&gt;
&lt;p&gt;혹시 이에 대한 좋은 해결방법이나 제약사항에 오류가 보이면 댓글 부탁드립니다~&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Clean Architecture 2]]></title><description><![CDATA[원제 Clean Architecture 제목 클린 아키텍쳐 저자 Robert C. Martin ISBN 978-89-6626-247-2 독서 기간 2020-03-15 독서 량 CH…]]></description><link>https://sukjae.github.io/daily-study/read-a-book/clean-architecture-day2/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/read-a-book/clean-architecture-day2/</guid><pubDate>Sun, 15 Mar 2020 00:00:00 GMT</pubDate><content:encoded>&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;원제&lt;/th&gt;
&lt;th&gt;Clean Architecture&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;제목&lt;/td&gt;
&lt;td&gt;클린 아키텍쳐&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;저자&lt;/td&gt;
&lt;td&gt;Robert C. Martin&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ISBN&lt;/td&gt;
&lt;td&gt;978-89-6626-247-2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;독서 기간&lt;/td&gt;
&lt;td&gt;2020-03-15&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;독서 량&lt;/td&gt;
&lt;td&gt;CH3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;시작하기 앞서…&lt;/h2&gt;
&lt;p&gt;단순히 코드를 작성하는게 아닌, 좋은 소프트웨어를 만들기 위해 읽게 되었다. 앞서 읽은 객체지향적인 사고들과 맞물려 좋은 아키텍쳐에 대한 고민을 담은 책이다. 현대의 프로그래밍에 대한 방법들은 모두 이러한 고민들을 바탕으로 이루어져 있으며 직접 적용을 하지 않더라도 생각을 확장하는데 큰 도움이 된다. 더욱 더 노력하여 장인이 될 수 있도록 하자!!&lt;/p&gt;
&lt;h2&gt;CH3&lt;/h2&gt;
&lt;h3&gt;설계 원칙&lt;/h3&gt;
&lt;p&gt;좋은 벽돌로 좋은 아키텍처를 정의하는 원칙이 필요한데, 그게 바로 &lt;strong&gt;SOLID&lt;/strong&gt; 이다.(p62)
SOLID 원칙의 목적은 중간 수준의 소프트웨어 구조가 다음과 같도록 만드는 것이다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;변경에 유연하다&lt;/li&gt;
&lt;li&gt;이해하기 쉽다&lt;/li&gt;
&lt;li&gt;많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;단일 책임 원칙 (SRP)&lt;/h3&gt;
&lt;p&gt;SRP란&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;단일 모듈은 변경의 이유가 하나, 오직 하나여야 한다. (p66)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;다르게 표현하면,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;하나의 모듈은 하나의, 오직 하나의 사용자 또는 이해관계자에 대해서만 책임 져야 한다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;최종적으로,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이는 하나의 모듈이 하나의 액터에 대한 기능과 정보를 품고 있는, 즉 응집된 집합임을 시사한다.&lt;/p&gt;
&lt;p&gt;SRP는 서도 다른 액터가 의존하는 코드를 서로 분리하라고 조언한다.&lt;/p&gt;
&lt;p&gt;여기서 조심해야 하는 것은, SRP가 &lt;strong&gt;단 하나의 일만 해야 한다는 원칙이 아니라는 것&lt;/strong&gt;이다. 이렇게 단 하나의 일만 해야 한다는 원칙은 함수들을 리펙토링하는 저수준의 작업에서 사용되는 원칙이다.(함수는 반드시 하나의, 단 하나의 일만 해야 한다는 원칙, p66)&lt;/p&gt;
&lt;p&gt;또한 SRP는 메서드와 클래스 수준임을 명심하자. 컴포넌트 수준에서는 동일한 기준이 폐쇄 원칙 이라는 용어로 적용된다.&lt;/p&gt;
&lt;h3&gt;개방-폐쇄 원칙 (OCP)&lt;/h3&gt;
&lt;p&gt;OCP란&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다 (p74)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;코드의 수정이 아닌, 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 해야 한다. (p64)&lt;/p&gt;
&lt;p&gt;어떻게 하면 이렇게 구성할 수 있을까?&lt;/p&gt;
&lt;p&gt;SRP에 의해서 책임을 분리하였다면, 그 후로 한 책임의 변경에 대해 다른 책임은 영향을 받지 않도록 설계 되어야 한다. 그래야 마음 놓고 코드를 추가할 수 있을 것이다. 이를 위해서는 클래스 단위로 분할한 뒤 컴포넌트 단위로 구분해야 한다.&lt;/p&gt;
&lt;p&gt;그러나 소프트웨어의 특성상, 하나의 변화가 다른 곳에 전혀 영향을 미치지 않게 할 순 없다. 하지만 필요에 따라 변화로 부터 최대한 숨겨 보호할 수 있다.&lt;/p&gt;
&lt;p&gt;변경이 잦은 컴포넌트를 저수준으로 내리고, 이 변화로 인해 고수준의 컴포넌트가 영향을 받지 않는 형태의 의존성 계층구조를 만들면 어느정도 OCP의 원칙을 따랐다고 볼 수 있을 것이다.&lt;/p&gt;
&lt;h3&gt;리스코프 치환 원칙 (LSP)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;자료형 S가 자료형 T의 하위 타입이라면, 행위의 변화 없이 T의 객체를 S의 객체로 치환 가능하다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;반대로도 성립한다.&lt;/p&gt;
&lt;p&gt;즉, LSP는 하위 타입에 대한 원칙이다.&lt;/p&gt;
&lt;p&gt;이는 위배하는 사례로 쉽게 이해가능하다. 유명한 정사각형/직사각형 문제에서 나오듯이 하위 타입으로 정하고자 하는 후보가 다른 행동을 한다면, 이는 하위 타입이 될 수 없으며 LSP에 위배된다. (직사각형은 가로 세로가 독립적으로 욺직이지만, 정사각형은 종속적이다.) 별도의 불필요한 메커니즘을 추가하지 않기 위해 LSP를 잘 따라 구현하도록 하자.&lt;/p&gt;
&lt;p&gt;LSP는 아키텍처 수준까지 확장될 수 있는 원칙이다.&lt;/p&gt;
&lt;h3&gt;인터페이스 분리 원칙 (ISP)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;사용하지 않는 것에 의존하지 않아야 한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이 책에서 유저 셋이 서로 다른 메소드를 하나으 클래스로 부터 사용 하는 것을 보여준다. 이는 앞서 나온 SRP와는 다른데, SRP의 예시에서는 세명의 유저가 서로 다른 액터였기 때문이다.
책의 예시의 경우에는, 클래스간의 의존을 끊어주기 위해 인터페이스를 끼어 넣는다. 하지만 이는 언어의 타입에(정적, 동적) 따라 다른 상황이 발생한다. 정적의 경우에는 보통 의존성이 생겨 이를 분리해야 하지만, 동적의 경우에는 런타임 추론이 발생하여 의존성이 없기 떄문이다.(더 생각해보면, 동적 언어를 사용하면 결합도가 낮은 시스템을 만들 수 있다고 한다)그렇다고, ISP가 언어적 문제를 해결하기 위한 원칙은 아니라고 한다.&lt;/p&gt;
&lt;h3&gt;의존성 역전의 원칙 (DIP)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안된다. 대신 세부사항이 정책에 의존해야 한다(p64)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이 원칙을 지켜 유연성이 극대화된 시스템을 만드는데, 유연성이 극대화된 시스템이란 소스코드 의존성이 추상에 의존하며 구체에는 의존하지 않는 시스템이다.(p92)&lt;/p&gt;
&lt;p&gt;그러나 보통의 경우 운영체제나 플랫폼 같이 안정성이 보장된 환경에 대해서는 DIP를 무시한다.(String은 구체 클래스이지만 추상화 하지 않는다)&lt;/p&gt;
&lt;p&gt;이 원칙을 따르기 위해선 다음과 같은 실천법을 따를 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;변동성이 큰 구체 클래스를 참조하지 말라&lt;/li&gt;
&lt;li&gt;변동성이 큰 구체 클래스로부터 파생하지 말라&lt;/li&gt;
&lt;li&gt;구체 함수를 오버라이드 하지 말라&lt;/li&gt;
&lt;li&gt;구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;DIP 위배는 모두 없앨 수는 없다. 하지만 위배하는 클래스를 소수의 구체 컴포넌트 내부로 모아 분리할 수 있다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Clean Architecture 1]]></title><description><![CDATA[원제 Clean Architecture 제목 클린 아키텍쳐 저자 Robert C. Martin ISBN 978-89-6626-247-2 독서 기간 2020-03-12 독서 량 CH1, CH…]]></description><link>https://sukjae.github.io/daily-study/read-a-book/clean-architecture-day1/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/read-a-book/clean-architecture-day1/</guid><pubDate>Thu, 12 Mar 2020 00:00:00 GMT</pubDate><content:encoded>&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;원제&lt;/th&gt;
&lt;th&gt;Clean Architecture&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;제목&lt;/td&gt;
&lt;td&gt;클린 아키텍쳐&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;저자&lt;/td&gt;
&lt;td&gt;Robert C. Martin&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ISBN&lt;/td&gt;
&lt;td&gt;978-89-6626-247-2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;독서 기간&lt;/td&gt;
&lt;td&gt;2020-03-12&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;독서 량&lt;/td&gt;
&lt;td&gt;CH1, CH2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;시작하기 앞서…&lt;/h2&gt;
&lt;p&gt;단순히 코드를 작성하는게 아닌, 좋은 소프트웨어를 만들기 위해 읽게 되었다. 앞서 읽은 객체지향적인 사고들과 맞물려 좋은 아키텍쳐에 대한 고민을 담은 책이다. 현대의 프로그래밍에 대한 방법들은 모두 이러한 고민들을 바탕으로 이루어져 있으며 직접 적용을 하지 않더라도 생각을 확장하는데 큰 도움이 된다. 더욱 더 노력하여 장인이 될 수 있도록 하자!!&lt;/p&gt;
&lt;h2&gt;CH1&lt;/h2&gt;
&lt;h3&gt;소개&lt;/h3&gt;
&lt;p&gt;1장에는 아키텍쳐(설계)에 대한 간단한 정의와 그 필요성에 대해 언급하고 있다. 이 부분에 대해 깊이 기록하기 보다, 느낌으로 받아드리고 필요한 경우에는 책을 참고해 보기 바란다.
그중 몇가지 와닿았던 내용을 기록하자면,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;빨리 가는 유일한 방법은 제대로 가는 것이다.(p13)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;기능과 아키텍처 둘 중 어느 가치가 더 높은가&lt;/h3&gt;
&lt;p&gt;동작하도록 만드는게 중요한가, 시스템의 변화에 용이하도록 하는게 중요한가. 책에서는 이 물음에 답을, 절대적인 것은 없지만 아이젠하워 매트릭스를 예로 들어 생각을 전하고 있다.
중요함과 긴급함은 우선순위를 매겨 내려야하고, 그 우선순위에 따라 선택함이 맞다고 보는 것 같다.(즉, 상황에 따라 답은 다르다…) 하지만 저자가 주의하라 당부하는것이 있는데, 그것은 긴급하지만 중요하지 않은 기능에 대한 우선순위를 긴급하면서 중요한 문제로 격상하곤 한다는 것이다. 긴급하지 않지만 중요한 것은, 긴급하지만 중요하지 않은 것 보다 앞서야 한다. 그럼에도 긴급한 것만 쳐내다 보니 중요한 작업(아키텍처)를 신경쓰지 못하곤 한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;우선순위 (p20)&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;긴급하고 중요한&lt;/li&gt;
&lt;li&gt;긴급하지 않지만 중요한&lt;/li&gt;
&lt;li&gt;긴급하지만 중요한&lt;/li&gt;
&lt;li&gt;긴급하지도 중요하지도 않은&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;CH2&lt;/h2&gt;
&lt;h3&gt;패러다임&lt;/h3&gt;
&lt;p&gt;저자는 패러다임에 대한 정의를 다음과 같이 하고 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;패러다임은 프로그래밍을 하는 방법으로, 대체로 언어에는 독립적이다.
패러다임은 어떤 프로그래밍 구조를 사용할지, 언제 구조를 사용해야 할지 결정한다. (p24)
패러다임은 무엇을 해야 할지 보다 &lt;strong&gt;무엇을 해서는 안 되는지를&lt;/strong&gt; 말해준다. (p27)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;저자는 세가지 패러다임을 ch2에서 다루고, 이 세가지 패러다임 이외의 패러다임은 더 이상 없을 것이라 한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;구조적 프로그래밍&lt;/li&gt;
&lt;li&gt;객체지향 프로그래밍&lt;/li&gt;
&lt;li&gt;함수형 프로그래밍&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;책에서는 이 후로 각각의 패러다임이 나오게 된 역사와 아이디어를 정리한다. 그 역사를 기억함은 크게 중요할지 모르겠지만, 패러다임과 아키텍처의 세 가지 큰 관심사(함수, 컴포넌트 분리, 데이터 관리)가 어떻게 서로 연관되는지 주목하라 한다.&lt;/p&gt;
&lt;h3&gt;구조적 프로그래밍&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;구조적 프로그래밍은 제어흐름의 직접적인 전환에 대해 규칙을 부여한다. (p26)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;앞서 연구자들은 초기에 존재한 goto 방식이 더 작은 단위로 재귀적으로 분해하는데 방해가 된다는 사실을 발견하였다. 이 부분이 중요한 이유는, 모듈을 분해할 수 없다면 합리적으로 증명할 때 필수적인 기법인 분할 정복 접근법을 사용할 수 없기 때문이다.(p31)&lt;/p&gt;
&lt;p&gt;이와 더불어 매우 중요한 사실을 발견하게 되었는데, 그것은 &lt;strong&gt;모든 프로그램을 순차(sequence), 분기(selection), 반복(iteration)이라는 세가지 구조만으로 표현&lt;/strong&gt; 할 수 있다는 것을 증명해 낸다.&lt;/p&gt;
&lt;p&gt;이러한 중요한 발견들로 인하여, 현대의 대부분의 언어는 제어흐름을 제약없이 제어할 수 있는 선태권을(goto) 제거한체 제공하게 되었고, 결과적으로 우리는 구조적 프로그래머가 되었다. (p33)&lt;/p&gt;
&lt;p&gt;구조적 프로그래밍을 통해 모듈을 더 작은 단위로 재귀적으로 기능적 분해할 수 있게 되었다. 이를 통해 우리는 고수준의 기능을 계속해서 저수준의 함수로 분해할 수 있게 되었으며 이 과정에서 제어구조를 이용해 표현할 수 있게 되었다.&lt;/p&gt;
&lt;h3&gt;객체지향 프로그래밍&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 대해 규칙을 부과한다. (p26)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이 챕터에서 객체지향 패러다임에 대한 모든내용을 포함하진 못한다. 하지만 몇가지 생각해볼만한 아이디어들을 던저준다.&lt;/p&gt;
&lt;p&gt;이 책에서는 객체지향에서 주요하게 다루는 세가지 성질(캡슐화, 상속, 다형성)이 우리가 말하는 “객체 지향 언어”에서만 적용될 수 있는 아이디어는 아니라고 설명하고 있다. 캡슐화의 경우에는 오히려 C언어에서 java등보다 더 잘 정의될 수 있다고 한다. 이 부분은 나중에 더 깊이있는 학습을 할때 돌아오겠지만, 지금은 간단히 그렇다는 사실만 받아들이고 넘어가기로 했다.&lt;/p&gt;
&lt;p&gt;이 챕터에서 말하고 싶은 중요한 아이디어는, 결과적으로 우리가 객체지향에서의 성질이라 부르는 캡슐화, 상속, 다형성이 실은 객체지향만이 아닌 소프트웨어 설계 전반에 걸쳐 언어에 제약없이 적용할 수 있고 해야하는 개념이라 말하고 싶은 것 같다.&lt;/p&gt;
&lt;p&gt;그럼에도 객체지향은 매우 중요하고, 여기서 중심적으로 다루는 주제 이기 때문에 객체지향에 대해 다음과 같이 요약하고 있다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;객체지향이란 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다(p51)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;객체지향과 다형성을 통해 고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;함수형 프로그래밍&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;함수형 프로그래밍은 할당문에 대해 규칙을 부과한다. (p27)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;함수형 언어에서 중요한 요소인 불변성과 순수성에 대해 간단히 다루고 있다. 간단히 정리하자면, 다음과 같다.&lt;/p&gt;
&lt;p&gt;함수형 언어에서 변수는 변경되지 않는다. 즉 불변성을 갖는다.(p55)이는 동시성 어플리케이션을 구성하고 관리하는데 큰 도움이 되는데, 함수형 프로그래밍을 통해 동시성 어플리케이션에서 마주치는 모든 문제를 해결할 수 있다. 동시성 어플리케이션에서는 보통 경합(race), 교착상태(deadlock), 동시 업데이트(concurrent update)와 같은 문제가 발생하고, 그 이유는 대부분 가변 변수로 부터 오기 때문이다.&lt;/p&gt;
&lt;p&gt;그러나 이러한 이상적인 방법에 대한 실현 조건으로 저장공간이 무한하고, 프로세서의 속도가 무한히 빨라야 가능하다고 한다. 따라서 저자는 불변성의 실현에 대해 어느정도 타협을 해야 한다고 말한다. 애플리케이션, 혹은 그 내부의 서비스를 가변 컴포넌트와 불변 컴포넌트로 분리하는 일이 그 방법이다.&lt;/p&gt;
&lt;p&gt;또한 이벤트 소싱이라는 아이디어를 언급하는데, 개인적으로 단순 무식하며 강력한 방법이라 생각한다. 어쩌면 NoSQL로 흘러간 방향과도 어느정도 일맥상통할 것이다. 프로세서의 가격보다 저장공간의 가격이 월등하게 낮아졌고, 저장공간은 어마무시하게 저렴해 졌으니 말이다.&lt;/p&gt;
&lt;p&gt;그래서 이벤트 소싱은 &lt;strong&gt;상태가 아닌 트랜잭션을 저장&lt;/strong&gt; 하는 전략이다. 상태가 필요해지면, &lt;strong&gt;최신 상태를 조회하는게 아니라 단순히 시작점부터 모든 트랜잭션을 처리&lt;/strong&gt; 하는 것이다.(p59)
(물론 이 과정에서 특정 시간에 체크포인트와 같은 기준점을 만드어, 연산을 줄이는 최적화도 가능하다고 한다)&lt;/p&gt;
&lt;p&gt;이를 통해 신박해지는 결과는, &lt;strong&gt;결과적으로 애플리케이션은 CRUD가 아니라 그저 CR만 수행하게 된다는 것이다&lt;/strong&gt;(나는 이 부분에서 한번 더 아하! 를 느꼈다)&lt;/p&gt;
&lt;p&gt;또한 이미 이런 방식이 적용되는 분야가 있는데, 그것은 소스 코드 버전 관리 시스템이 이렇게 작동한다는 것이다. (예를 들어 git. 나도 처음에는 git이 변화에 대해서만 저장하는 줄 알았지만, 사실은 전체를 계속해서 저장해가는 방식이다)&lt;/p&gt;
&lt;h3&gt;결론&lt;/h3&gt;
&lt;p&gt;앞서 세가지 패러다임을 다뤘다.
저자의 말에 따르면,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;지난 반세기 동안 우리가(프로그래머) 배운것은 해서는 안 되는 것에 대해서다.&lt;/strong&gt; (p60)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이 부분에서 마지막으로 아하! 를 느꼈다. 나는 항상 개발을 생각하며 어떤 규칙을 따라야 하는지만 생각했다. 예를 들어, React에서는 component와 page라는 폴더로 구분되어야 하고 각각이 적절한 요소들이 들어가야 한다와 같은 &lt;strong&gt;해야하는 규칙에 대해서만 찾아보고 적용했다&lt;/strong&gt;. 이러한 따를 수 있는 방법들이, 해서는 안되는 다양한 규칙들을 만족하기 위해 나온 것이라는 것을 이해하지 못한채 결과물만 가져가려 했던 것 같다.&lt;/p&gt;
&lt;p&gt;개발에서는 해야하는 일보다 더 중요한것은, &lt;strong&gt;해서는 안되는 것들과 이에 대한 이해&lt;/strong&gt; 라는 사실을 이번 챕터를 통해 느끼게 되었다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Lucid Chart]]></title><description><![CDATA[Lucid Chart 학습 계기 원래는 keynote나 powerpoint, sketch app 등으로 다이어 그램을 그리곤 했다. 그러다, 이를 더 쉽고 체계적으로 그릴 수 있는 도구들에 대해 알아보게 되었고 lucid chart…]]></description><link>https://sukjae.github.io/daily-study/tools/lucidchart/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/tools/lucidchart/</guid><pubDate>Thu, 12 Mar 2020 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;Lucid Chart&lt;/h2&gt;
&lt;h3&gt;학습 계기&lt;/h3&gt;
&lt;p&gt;원래는 keynote나 powerpoint, sketch app 등으로 다이어 그램을 그리곤 했다. 그러다, 이를 더 쉽고 체계적으로 그릴 수 있는 도구들에 대해 알아보게 되었고 lucid chart를 알게 되었다.&lt;/p&gt;
&lt;p&gt;특히 lucid chart의 경우 &lt;a href=&quot;https://www.youtube.com/user/lucidchart/&quot;&gt;별도의 유트브 채널&lt;/a&gt;이 있어 도구 활용법을 쉽게 접할 수 있었다. (그리고 무려 32만명의 구독자를 보유중이다)&lt;/p&gt;
&lt;p&gt;Lucid chart는 단순히 ERD를 그리기 위한 도구로 알아 봤는데, 예상과 달리 굉장히 많은 그리기 도구를 제공한다. 특히 나의 입장에서는 여러 템플릿들이 존재하여 더욱 쉽게 시작할 수 있었다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/daily-study/static/d2970d0f2f9dbf9b13a3cd2f40826933/61fdd/lucid-chart-home.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 51.35135135135135%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAABuklEQVQoz4VSXW/TQBDM//9JQCLaSPACQrQSfahAiKRxY8exfV++Tw+z1wTlDUuj9e3tzs7u3sr7AOMTnndnxB8bhMd3CA/vkR7XSA/E9w1xj/TtHvHrHbFF/LJF+MTY7Rr+jvi4xrwhPqyxOjRHtKceMSWYBPQmYPIFEQCPCBek/yBfsGqOLV6aV7jZIyfSLAWF1qkzkp9hjYHVGjkGzM4hB49iR2QzoDiNojpkZ+CsRfQeq47qmtcWloSispSCEALGvkMQQjfDEeLzRM6JBBOyPr2RD3tEEo/TBC+Ebdfjz/6AYVKY57lCkh3ViJWzBMqsb32JxcVX4yM7oo20VHjGz1+/obTBsiwVOeebJP+P9ErYE4rJ0ziiaRp4udcDUrwolMXUlmOqhFLJcHZS2XI2lkSJ/7OQE5b/nsWUmjCSVIpZrRBZqBK23Ynzy1WBqBIVmoqv7VXLpEQU3ouvduF9LS459Z4cq2PbYX9okHKphKJMAiYOWRagDZdkFzyNAz4z9sT7l90OA8/P+zO0nXH7VYXydALbrYRsURRMXNLbcqjCRzR8Ok/spCWhVqouwVjHkbj6Mq7z/wu6QQE/8xKcLAAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;lucid chart home&quot;
        title=&quot;lucid chart home&quot;
        src=&quot;/daily-study/static/d2970d0f2f9dbf9b13a3cd2f40826933/fcda8/lucid-chart-home.png&quot;
        srcset=&quot;/daily-study/static/d2970d0f2f9dbf9b13a3cd2f40826933/12f09/lucid-chart-home.png 148w,
/daily-study/static/d2970d0f2f9dbf9b13a3cd2f40826933/e4a3f/lucid-chart-home.png 295w,
/daily-study/static/d2970d0f2f9dbf9b13a3cd2f40826933/fcda8/lucid-chart-home.png 590w,
/daily-study/static/d2970d0f2f9dbf9b13a3cd2f40826933/efc66/lucid-chart-home.png 885w,
/daily-study/static/d2970d0f2f9dbf9b13a3cd2f40826933/c83ae/lucid-chart-home.png 1180w,
/daily-study/static/d2970d0f2f9dbf9b13a3cd2f40826933/61fdd/lucid-chart-home.png 3204w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;lucid chart는 너무나도 직관적이고 사용이 편리하여 그 방법을 기록하지 않아도 될것 같다.&lt;/p&gt;
&lt;p&gt;하지만, 여러 종류의 다이어 그램이 처음인 사람들을 위해 좋았던 영상 몇가지 링크를 달아보겠다. (좋아요 비율이 굉장히 높다!)&lt;/p&gt;
&lt;h3&gt;UML Class Diagram Tutorial&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://youtu.be/UI6lqHOVHic&quot;&gt;UML Class Diagram Tutorial 링크&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;객체지향을 처음 학습하며, 관계를 표현하기 위해 UML이라는 것을 처음 접하게 되었고, 이에 대해 너무 쉽고도 핵심적인 내용만 짚어준 영상이다. 누구라도 한번 시청하면 바로 다이어 그램을 그릴 수 있을 정도다.&lt;/p&gt;
&lt;h3&gt;UML Use Case Diagram Tutorial&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://youtu.be/zid-MVo7M-E&quot;&gt;UML Use Case Diagram Tutorial 링크&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;항상 글(리스트)로만 작성하였던 유즈케이스가 이렇게 다이어그램으로 표현이 용이할 수 있다는 것을 느꼈다. 이런 내용을 배운적이 없어서 그런지, 표현하는 다양한 방법에 대해 더 알아볼 필요가 있겠단 생각이 들었다.&lt;/p&gt;
&lt;h3&gt;How to Make a UML Sequence Diagram&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://youtu.be/pCK6prSq8aw&quot;&gt;How to Make a UML Sequence Diagram 링크&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;OAuth 2.0등을 학습하며, 항상 봐왔던 형식의 다이어 그램이였다. 이것을 나는 keynote로만 그릴려 했었는데, 항상 꾸미는데 시간이 더 들더라…
이렇게 쉬운 도구로 직관적으로 표현할 수 있다는 점에 적절한 도구의 중요성을 알게 되었다. 위의 다른 UML 예시와 마찬가지로, 여러 종류의 다이어 그램에 대해 더 알아볼 필요성을 느끼게 되었다.&lt;/p&gt;
&lt;h3&gt;플레이리스트&lt;/h3&gt;
&lt;p&gt;이 외에도 lucid chart에서 제공하는 관련 플레이 리스트속의 영상을 모두 시청해 보면, 입문자의 입장에서 큰 도움이 될것 같다. 항상 혼자 개발을 할 때는 이러한 직관적인 의사소통의 수단(다이어그램)이 중요한지 몰랐다. 그러나, 누군가와 협업하기 위해서는 이만한 도구가 없는 것 같다. 좋은 사람들과 함께 하기 위해 더욱 더 노력해야 겠다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/playlist?list=PLUoebdZqEHTwbYD8oo6Wr81Xb7uCAh_oz&quot;&gt;Diagramming Tutorials 플레이 리스트&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[GOTO 2018 • Functional Programming in 40 Minutes • Russ Olsen]]></title><description><![CDATA[제목 GOTO 2018 • Functional Programming in 40 Minutes • Russ Olsen 요약 FP에 관한 간단한 intro 시청일 2020.03.10 링크 Youtube…]]></description><link>https://sukjae.github.io/daily-study/online-conference/functional-programming-in-40-min/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/online-conference/functional-programming-in-40-min/</guid><pubDate>Tue, 10 Mar 2020 00:00:00 GMT</pubDate><content:encoded>&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;제목&lt;/th&gt;
&lt;th&gt;GOTO 2018 • Functional Programming in 40 Minutes • Russ Olsen&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;요약&lt;/td&gt;
&lt;td&gt;FP에 관한 간단한 intro&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;시청일&lt;/td&gt;
&lt;td&gt;2020.03.10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;링크&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=0if71HOyVjY&quot;&gt;Youtube&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;느낀점 :&lt;/h2&gt;
&lt;p&gt;전체 강의는 굉장히 짜임새 있는 형식으로 진행되며, 기초적인 수준에서 FP의 방식에 대한 이해를 돕는 강의인것 같다.&lt;/p&gt;
&lt;p&gt;이 강의는 다음과 같은 세 부분으로 나누어 진행된다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What is it?&lt;/li&gt;
&lt;li&gt;What’s it like?&lt;/li&gt;
&lt;li&gt;Does it works?&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;What is it&lt;/h3&gt;
&lt;p&gt;보통 FP에 대해 언급할 때, 프로그래밍에 대해 알고 있는 모든것을 잊으라 라는 얘기를 듣는다(Forget everything you know about programming)&lt;/p&gt;
&lt;p&gt;이는 사실과 다르다. FP는 프로그래밍에서 중요한 부분들을 그대로 유지한 채 쌓는 아이디어이다. 우리가 FP를 한다고 해서 Array, Function과 같은 Data type, ifs, iteration, indentation등을 잊을 필요는 없다.&lt;/p&gt;
&lt;p&gt;FP는 우리가 아는 프로그래밍에 기초하여 Refactor 하는것에 가깝다.&lt;/p&gt;
&lt;p&gt;FP에서는 기존에 프로그래밍에서 갖고 있는 요소들을 기반으로 한채로 두가지 아이디어를 더 보탠다.&lt;/p&gt;
&lt;p&gt;그 중 하나는 수학적인 함수에 대한 부분이다.
프로그래밍에서도 함수는 존재한다. (method, procedures, subroutins, functions)&lt;/p&gt;
&lt;p&gt;그러나 이들은 수학적에서 말하는 함수와는 차이가 존재한다. 그 가장 명확한 차이는 side effect에서 온다.&lt;/p&gt;
&lt;p&gt;우리는 프로그래밍에서 함수를 사용하며 자연스래 side effect가 일어나길 기대한다. (파일 입출력 등) 그러나 수학적인 함수에서는 함수는 동일한 값에 대해서는 항상 동일한 값을 제공해야 하고, side effect를 발생하지 않는다는 점이 차이가 있다. 즉, 순수 함수여야 한다.(&lt;a href=&quot;https://en.wikipedia.org/wiki/Pure_function&quot;&gt;pure function, wiki&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;또 다른 중요한 요소는 Immutable이다.
만약 우리가 여러 함수들의 흐름에서 하나의 값이 바뀌면, 그 값의 변화를 따라가기 위해 들여야 하는 노력들을 생각해보면 크다는 것을 알 수 있다. 위에서 함수형으로 작성하여 코드를 큰 무리 없이 흐르듯이 이해해 갈 수 있는데, 그중에 의도치 않는 값 하나가 변하는 것을 상상해 보자. 이 문제를 해결하기 위해 사용되는 방식이 Immutable이다.&lt;/p&gt;
&lt;p&gt;보통 Immutable을 하기 위해서 copy를 하곤 한다.
근데, 우리가 생각하는 것 처럼 copy를 하는 것은 아니다. 만약 수백만개의 아이템이 있는데, 한두개의 아이템을 바꿔야 하는 경우에도 전체 배열을 copy해야 할까?&lt;/p&gt;
&lt;p&gt;이를 위해 Persistent Data structure를 사용한다.
이 방식의 요점은, 배열과 같은 구조를 트리의 형식으로 변화하고, 변화된 부분만 갱신하는 방법니다. 변화된 부분 이외에는 복사가 필요없으므로 자원의 재사용이 용이하며 copy로 부터 오게 되는 단점을 극복할 수 있다.&lt;/p&gt;
&lt;p&gt;그러나, 문제는 우리는 현실 세계에서 프로그래밍이 side effect를 이르키길 원한다는 점이다. 프로그래밍을 하며 side effect를 최대한 피하기 위해 노력했지만, 이 것이 필요하다는게 아이러니 하다. (여기서 내 생각에는, 중요한 부분은 side effect가 나쁘다가 아니라, 의도치 않은 side effect가 나쁘다 인것 같다)&lt;/p&gt;
&lt;p&gt;프로그래밍 언어에서는 side effect를 제공하기 위해 언어별로 다른 접근법을 제공한다.&lt;/p&gt;
&lt;p&gt;강의에서는 두가지 방법에 대한 side effect를 어떻게 이르킬 것인지 설명한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;값을 변경하기 위해 (immutable에 대한 반대)&lt;/li&gt;
&lt;li&gt;외부 세상과 상호 작용 하기 위해 (write file 등)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;값을 변경하기 위해서 예시로 강의에서 클로저 라는 언어를 예시로 들고, Atoms라는 개념에 함수를 전달하여(수학적인 함수) atoms가 그 함수에 따라 side effect를 이르키도록 한다. 이 방식을 통해, 몇개의 함수가 동시적으로 오던지 너무 쉽게 해결할 수 있고, 이는 DB 에서의 트랜잭션과 유사한 모습을 보이기도 한다고 언급한다.&lt;/p&gt;
&lt;p&gt;또 외부와의 상호작용을 위한 방식으로는 주로 다양한 언어에서 queue와 유사한 구조를 사용하여 처리한다고 한다. (NodeJS에서도 유사하게 처리됨) 수행해야 한 작업을 queue에 넣고, 언어가 자체적으로 queue를 처리함으로서 side effect를 이르킨다.&lt;/p&gt;
&lt;h3&gt;What’s it like?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;No Magic!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;FP는 뭔가 특별히 마법같은 기능을 제공한는게 아니다.&lt;/p&gt;
&lt;p&gt;FP를 적용하여도 여전히 &lt;a href=&quot;https://en.wikipedia.org/wiki/Off-by-one_error&quot;&gt;Off-by-one error&lt;/a&gt;, Redundant 코드, 나쁜 코드 등이 모두 존재할 수 있다.&lt;/p&gt;
&lt;p&gt;FP를 적용하므로서 무언가 magic같이 얻는 장점이 있다면, 그것을 thread와 관련된 것일 것이다.
FP를 사용시 thread간의 변화를 너무나도 쉽게 방지할 수 있다. 모든 것은 input-&gt; output 이므로 상태는 존재하거나 존재하지 않거나 둘 중 하나이다.&lt;/p&gt;
&lt;h3&gt;Does it works?&lt;/h3&gt;
&lt;p&gt;가능하다. 끗~&lt;/p&gt;</content:encoded></item><item><title><![CDATA[CSS의 Width/Height VS HTML attributes의 Width/Height]]></title><description><![CDATA[HTML의 여러 엘리먼트를 스타일링 하기 위해 다양한 방법이 존재한다.
엘리먼트 자체가 약속에 의해 스타일을 포함하는 경우가 있고, 브라우저가 임의로 스타일링 하는 경우도 있으며 css 파일로 적용할 수 있다. 아니면 inline style…]]></description><link>https://sukjae.github.io/daily-study/daily/2020-01-25/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/daily/2020-01-25/</guid><pubDate>Sat, 25 Jan 2020 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;HTML의 여러 엘리먼트를 스타일링 하기 위해 다양한 방법이 존재한다.
엘리먼트 자체가 약속에 의해 스타일을 포함하는 경우가 있고, 브라우저가 임의로 스타일링 하는 경우도 있으며 css 파일로 적용할 수 있다. 아니면 inline style등으로 지정할 수 있는데 이 모든 스타일 옵션은 정해진 우선순위를 따른다. 보통 inline style 속성은 가장 강력한 스타일 방법중에 하난데, 재밌게도 HTML 속성(attribute)로서 스타일을 지정할 수 있는 엘리먼트들이 있고, 그 경우에 우선순위가 낮다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt; valid&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; works&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; is a good idea &lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;img width&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;500&quot;&lt;/span&gt; height&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;400&quot;&lt;/span&gt; src&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;...&quot;&lt;/span&gt; alt&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;...&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;iframe width&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;600&quot;&lt;/span&gt; height&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;400&quot;&lt;/span&gt; src&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;...&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;iframe&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;svg width&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;20&quot;&lt;/span&gt; height&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;20&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;svg&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;

&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt; not valid&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; doesn&apos;t work&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; not a good idea &lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;div width&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;40&quot;&lt;/span&gt; height&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;40&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;span width&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;100&quot;&lt;/span&gt; height&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;10&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;span&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 출처: 하단 링크&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;여기서 의아할 수 있는 부분이 있다. 위에서 언급 하였듯이, 스타일은 우선순위를 갖고 있고, inline이 아주 강력한 우선순위를 갖음에도(보통 !important만이 우회할 유일한 방법이다) inline과 유사하게 엘리먼트의 속성으로서 추가하는 스타일은 그 우선순위가 가장 낮다(css보다도!)&lt;/p&gt;
&lt;p&gt;어찌보면 무언가 논리적이지 못해 보일 수 있다 생각할 수 있지만 이 방식은 보통 잘못되는 상황에서의 대처에 유용하게 쓰인다고 한다. 쉽게 생각하면 default 값으로서 문제가 생겼을때만 적용되고 평상시에는 무시해도 되는 정도의 우선순위를 갖는 fallback styling 으로서의 역할을 하는것 이다.&lt;/p&gt;
&lt;p&gt;즉 기타 스타일링 자원이 아직 로드 되지 않았을 때나, 불러오는데 문제가 생겨서 정상적인 형태를 유지하게 하기 어려울 때 사용 되는 것이다. 본문의 내용에 따르면 svg의 경우 이 속성없이는 잘못된 상황에서 정말 이상한 형태가 나오기도 한다고 한다.&lt;/p&gt;
&lt;p&gt;이제 이런것도 있음을 알게 되었으니, 다음 글로는 css의 스타일 우선순위에 대해 다시 한번 살펴보고 정리하도록 해야겠다.&lt;/p&gt;
&lt;p&gt;참고: &lt;a href=&quot;https://css-tricks.com/whats-the-difference-between-width-height-in-css-and-width-height-html-attributes/&quot;&gt;https://css-tricks.com/whats-the-difference-between-width-height-in-css-and-width-height-html-attributes/&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[HTML 엘리먼트 기본 스타일 제거하기]]></title><description><![CDATA[css 작업을 하기 위해  와 같은 도구를 사용하곤 한다. 그 이유는 브라우저마다 HTML tag…]]></description><link>https://sukjae.github.io/daily-study/daily/2020-01-23/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/daily/2020-01-23/</guid><pubDate>Thu, 23 Jan 2020 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;css 작업을 하기 위해 &lt;code class=&quot;language-text&quot;&gt;normalize.css&lt;/code&gt; 와 같은 도구를 사용하곤 한다. 그 이유는 브라우저마다 HTML tag에 각자의 기본적인 스타일을 적용하고, 개발자 입장에서 통일된 스타일을 제공하기 위해 초기화 하는 것이다.&lt;/p&gt;
&lt;p&gt;이런 도구들은 여럿 있는데, 그 중에는 초기화 작업 뿐만 아니라 몇가지 실용적인 자체 스타일을 설정하기도 한다. 예를 들어, 스타일을 편하게 하기 위해 자주 쓰이는 트릭인 &lt;code class=&quot;language-text&quot;&gt;box-sizing: border-box;&lt;/code&gt; 속성을 글로벌하게 적용한다던지 말이다.&lt;/p&gt;
&lt;p&gt;많이 쓰이는 &lt;code class=&quot;language-text&quot;&gt;normalize.css&lt;/code&gt; 의 경우에는 브라우저마다 서로 다른 스타일을 초기화 해 주는데, 신기하게도 이미 통일된 규격은 그대로 유지한다고 한다. 이 외에도 &lt;code class=&quot;language-text&quot;&gt;sanitize.css&lt;/code&gt; 나 &lt;code class=&quot;language-text&quot;&gt;modern-normalize&lt;/code&gt; 등 과 같이 &lt;code class=&quot;language-text&quot;&gt;normalize.css&lt;/code&gt; 에서 파생되어 실용적인 기능들을 추가한 라이브러리들도 존재한다. 이들에 대한 &lt;strong&gt;시각적인 비교는&lt;/strong&gt; 다음 링크에서 확인할 수 있다. &lt;a href=&quot;https://codepen.io/chriscoyier/pen/JpLzjd&quot;&gt;codepen&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;다음 링크에서 확인할 수 있듯이, &lt;a href=&quot;https://www.npmtrends.com/normalize.css-vs-sanitize.css-vs-reset-css-vs-modern-normalize&quot;&gt;normalize.css vs sanitize.css vs reset-css vs modern-normalize, npm trents&lt;/a&gt; 사용량은 &lt;code class=&quot;language-text&quot;&gt;normalize.css&lt;/code&gt; 가 압도적으로 많았지만, &lt;code class=&quot;language-text&quot;&gt;sanitize.css&lt;/code&gt; 가 매섭게 추격 하고 있고, 아직 나머지 둘은 대중적인진 않다. &lt;code class=&quot;language-text&quot;&gt;normalize.css&lt;/code&gt; 에서 모던한 브라우저를 모두 지원하면서 실용적인 기능을 넣고도 유사한 파일 크기를 유지한 &lt;code class=&quot;language-text&quot;&gt;modern-normalize&lt;/code&gt; 도 손이 가지만, 나는 &lt;code class=&quot;language-text&quot;&gt;sanitize.css&lt;/code&gt; 도 좋은 것 같다.&lt;/p&gt;
&lt;p&gt;이들 대부분이 npm으로 제공되고, css파일로도 제공되니 사용하면서 원하지 않는 부분을 제거하며 튜닝하는 방법도 있겠다…만 그냥 학습용으로만 들여다 볼 것 같다.&lt;/p&gt;
&lt;h2&gt;참조&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://css-tricks.com/reboot-resets-reasoning/&quot;&gt;reboot-resets-reasoning, CSS Trick&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.npmtrends.com/normalize.css-vs-sanitize.css-vs-reset-css-vs-modern-normalize&quot;&gt;normalize.css vs sanitize.css vs reset-css vs modern-normalize, npm trents&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://codepen.io/chriscoyier/pen/JpLzjd&quot;&gt;codepen&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[Microbrowser 간단 느낌 정리]]></title><description><![CDATA[우연히 microbrowser란 용어에 대해 알게 되었고, microbrowser에 대해 깊이 알아 보기전 간단한 정리를 진행하였다 microbrowser…]]></description><link>https://sukjae.github.io/daily-study/daily/2020-01-18/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/daily/2020-01-18/</guid><pubDate>Sat, 18 Jan 2020 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;우연히 microbrowser란 용어에 대해 알게 되었고, microbrowser에 대해 깊이 알아 보기전 간단한 정리를 진행하였다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;microbrowser는 무엇일까?&lt;/h3&gt;
&lt;p&gt;우리가 문자, 카톡, 슬랙등으로 링크를 주고 받을 떄 생성되는 카드 형태의 thumbnail(preview)가 생기곤 한다. 이 preview를 생성하기 위해 앱마다 링크를 방문하여 정보를 수집하고 이를 표현하는데, 그 역할을 하는 존재가 microbrowser이다.&lt;/p&gt;
&lt;p&gt;어떻게 보면 현대와 같이 메신저가 발달된 상황에서 지인끼리 링크를 공유하게 되면 방문 확률이 높음에도, 해당 부분에 신경을 많이 쓰지 않곤 한다. 글에서 나와 있듯이, 어쩌면 SEO 보다도 더 중요한 부분임에도 많은 노력을 드리지 않곤 한다.&lt;/p&gt;
&lt;p&gt;많은 이들이 알고 있듯이, 이 preview를 생성하기 위해 microbrowser가 웹페이지를 크롤링 하고, header등에 존재하는 metadata 뽑아내어 표현하는 것을 알고 있을 것이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Twitter Cards and Open Graph annotations for Facebook. LinkedIn likewise embraced both Open Graph and OEmbed tags to help generate the previews (출처: 참고 1)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;그러나 항상 내 예상되로 되지 않고 그저 메타 데이터를 추가 하곤 하는데, 사실 이 microbrowser가 몇가지 한계가 존재한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the parsing of the HTML is limited and filtered&lt;/li&gt;
&lt;li&gt;they ignore cookies&lt;/li&gt;
&lt;li&gt;they don’t execute javascript&lt;/li&gt;
&lt;li&gt;they are not good with follow redirects&lt;/li&gt;
&lt;li&gt;they fake the user-agent string when visiting the site&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이러한 특성들과, 앱마다 서로 다른 구현으로 인해 개발자 입장에서는 preview를 예측하고 대응하기 어려운 면이 있다.&lt;/p&gt;
&lt;p&gt;또한, 서비스 제공자의 입장에서 microbrowser의 행동을 파악하기 어려운 면이 존재한다.
그 이유는 주로 자바스크립트를 실행하지 않고, 가짜 user-agent를 통해 사이트로 들어 오기 떄문에 우리가 많이 사용하는 analytics 도구들이 실행이 안되고(주로 script에 포함되어 있는데, 이 부분을 실행 안한다) 서버 입장에서도 보통의 유저와 유사하게 들어오기도 하고 서비스 마다 서로 다르게 들어오기도 하기 때문에 구분이 어렵다. 또한, 서비스 제공자(링크를 공유하는 플랫폼)에서 일괄적으로 크롤링을 진행하기도 하기도 한다.&lt;/p&gt;
&lt;p&gt;이러한 성격으로 실제 유저의 행동을 파악하기 어려운게 가장 큰 문제다. 실제 유저가 우리의 링크를 공유하였고 그 결과 들어왔음을 파악하기 어렵다. 우리 서비스 입장에서 유저는 그냥 url을 통해 들어온 것으로만 파악되지, 해당 유저가 메신저 등을 통해 들어왔는지 알기 어렵다.&lt;/p&gt;
&lt;p&gt;이 부분을 조금 더 학습하여 어떻게 실제 유저의 흐름을 파악할 수 있는지 알아봐야 겠다.&lt;/p&gt;
&lt;p&gt;참고 1 : &lt;a href=&quot;https://css-tricks.com/microbrowsers-are-everywhere/&quot;&gt;https://css-tricks.com/microbrowsers-are-everywhere/&lt;/a&gt;
참고 2 : &lt;a href=&quot;https://uxdesign.cc/do-you-know-what-a-microbrowser-is-a555f15f6cc8&quot;&gt;https://uxdesign.cc/do-you-know-what-a-microbrowser-is-a555f15f6cc8&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[면접 반성]]></title><description><![CDATA[…]]></description><link>https://sukjae.github.io/daily-study/daily/2020-01-17/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/daily/2020-01-17/</guid><pubDate>Fri, 17 Jan 2020 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;오늘은 감사하게도 두 군데에서 기술 면접을 볼 수 있었다. 많은 것을 배울 수 있는 시간이였고, 생각보다 많이 긴장하여 준비한 만큼 보여드리지 못해 아쉬움이 크다. 진행된 면접에 대해서 구체적으로 남기긴 힘들지만, 내가 느꼈던 부분들과 개선해야 할 점들을 기록해 보려한다.&lt;/p&gt;
&lt;p&gt;두 곳 모두 친절하게 응대해 주었고, 면접을 진행함에 있어 긴장을 많이 풀어주셨다. 또, 막히는 부분들이 있을 때 적절히 힌트가 가미된 멘트들을 남겨주셔서 정신을 차리는데 도움이 많이 되었다. 두 곳은 서로 다른 형태의 기술질문을 주었지만, 각각이 타당한 근거가 있었고 충분히 납득할만한 질문들이였다.&lt;/p&gt;
&lt;p&gt;면접의 만족도는 높았지만, 개인적으로 나의 능력에 많은 아쉬움이 남았다. 특히 두번의 면접 모두 라이브 코딩을 진행했는데, 이 부분에 대한 연습이 부족함을 많이 느끼게 되었다. 문제를 어떻게 접근할지 머릿속에서 연상이 되지만, 그것을 코드로 옮기는데 약간의 버퍼링이 존재했었다. 그로 인해 내 스스로 이런것도 빨리 못푼다는 자괴감에 빠져 멘탈이 점점 흔들리곤 했다. 라이브 코딩이나 알고리즘 문제를 푸는것은 꾸준한 훈련이 필요한 것 같다. 마스터 클래스 시간에 경력자 분들도 이직전에 3개월 가량 준비를 한다는 말이 다시금 떠오르는 순간이였다. 입사를 하고 싶으면 코딩 테스트를 꾸준히 응시하자!!&lt;/p&gt;
&lt;p&gt;또 개인적으로 아쉬웠던 부분은 설명에 대한 연습이였다. 분명 간단하게는 기억하고 있지만, 세세한 내용을 명확하게 기억하지 못했다. 그래서 내 자신도 말을 하며 디테일한 부분에서 햇갈리는 상황이 발생하였다. 이 부분 또한 연습의 부족인 것 같다. 취업을 하고자 한다면 필히 했어야 할 연습인데, 그 과정을 소홀히 한 것 같다. 시간을 내서 강의를 찍듯이 말하는 연습이 필요한 것 같다. 내 스스로만 아는것에 만족하지 말고, 구체적으로 설명할 수 있는 수준으로 갈고 닦아야 겠다.&lt;/p&gt;
&lt;p&gt;마지막으로 아쉬웠던 부분은 CS나 JS와 같은 기본적인 부분에 대한 탄탄함이였다. 물론 모든 문제를 어느정도 논리에 의거하여 답을 유추할 수 있었고, 내가 낸 답이 정답과 흡사하였으나 자신감 있게 설명하지는 못했다. 이 부분도 위와 같이 한번 더 정리가 필요한 부분이다.&lt;/p&gt;
&lt;p&gt;결과적으로, 세가지 아쉬운 부분 모두 연습 부족이 원인이라 할 수 있을 것 같다. 아쉽지만 현재 취업 시장에서 면접관이 원하는 답을 말하기 위해서 연습과 훈련을 통해서 이루어져야 하는 것 같다. 개인의 기억의 한계는 명확하고, 아무리 많이 본다하더라도 잊기 마련이다. 면접을 진행하기 전에 한번 쭉 훑어보는 시간을 많이 들여서 준비할 필요가 있다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React 학습 노트(Virtual DOM, Fiber,reconciliation)]]></title><description><![CDATA[요약 build your own x 정신에 따라, 만들지 못한다면 이해하지 못한 것 이라는 가정을 갖고 React 를 만들기 위해 학습합니다.
React…]]></description><link>https://sukjae.github.io/daily-study/react-study/study-note/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/react-study/study-note/</guid><pubDate>Thu, 16 Jan 2020 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;요약&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/danistefanovic/build-your-own-x&quot;&gt;build your own x&lt;/a&gt; 정신에 따라, 만들지 못한다면 이해하지 못한 것 이라는 가정을 갖고 React 를 만들기 위해 학습합니다.
React를 모방하여 만들기 전에 선배 개발자 님들이 모방한 작업물들을 참조하고, 그 과정에서 얻어진 학습 내용을 수기로 작성하였습니다.
추후 학습이 깊어저 어느정도 이해가 되면 저만의 React를 만드는 것을 목표로 합니다.&lt;/p&gt;
&lt;h3&gt;학습 자료: &lt;a href=&quot;https://pomb.us/build-your-own-react/&quot;&gt;https://pomb.us/build-your-own-react/&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;현재 위 문서에 대한 한글 번역을 완료 하였습니다.
추후 수정후에 저자에게 허락을 받아 공개 할 예정입니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;라이프 사이클&lt;/h3&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/daily-study/static/f3c12d773a86db00295ffe608f8627c2/76775/1.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 62.16216216216216%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAEDAgX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAv/aAAwDAQACEAMQAAAB7LypUJh//8QAFxAAAwEAAAAAAAAAAAAAAAAAABBBEv/aAAgBAQABBQJ26P/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEABj8CX//EABkQAQEBAAMAAAAAAAAAAAAAAAEAETFhgf/aAAgBAQABPyF02FvbVZHItdX/2gAMAwEAAgADAAAAEK8//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAHBABAQEAAgMBAAAAAAAAAAAAAREAIXExQVFh/9oACAEBAAE/ELEJO/GcRp+povNHWbLA+YlhZ701JwZv/9k=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;1&quot;
        title=&quot;1&quot;
        src=&quot;/daily-study/static/f3c12d773a86db00295ffe608f8627c2/1c72d/1.jpg&quot;
        srcset=&quot;/daily-study/static/f3c12d773a86db00295ffe608f8627c2/a80bd/1.jpg 148w,
/daily-study/static/f3c12d773a86db00295ffe608f8627c2/1c91a/1.jpg 295w,
/daily-study/static/f3c12d773a86db00295ffe608f8627c2/1c72d/1.jpg 590w,
/daily-study/static/f3c12d773a86db00295ffe608f8627c2/a8a14/1.jpg 885w,
/daily-study/static/f3c12d773a86db00295ffe608f8627c2/fbd2c/1.jpg 1180w,
/daily-study/static/f3c12d773a86db00295ffe608f8627c2/76775/1.jpg 2386w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;Virtual DOM 순회 비교&lt;/h3&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/daily-study/static/20e379b44ecde0c6bbc518a623738331/76775/2.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 62.16216216216216%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAECBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAC/9oADAMBAAIQAxAAAAHZpqVCD//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEAAQUCX//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEABj8CX//EABkQAAIDAQAAAAAAAAAAAAAAAAERABAxQf/aAAgBAQABPyElHseTQ6Nf/9oADAMBAAIAAwAAABA8/wD/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAcEAEAAgIDAQAAAAAAAAAAAAABABEhMRBBgVH/2gAIAQEAAT8QKm/LDFDYtN7ggC6fpmeQd6eP/9k=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;2&quot;
        title=&quot;2&quot;
        src=&quot;/daily-study/static/20e379b44ecde0c6bbc518a623738331/1c72d/2.jpg&quot;
        srcset=&quot;/daily-study/static/20e379b44ecde0c6bbc518a623738331/a80bd/2.jpg 148w,
/daily-study/static/20e379b44ecde0c6bbc518a623738331/1c91a/2.jpg 295w,
/daily-study/static/20e379b44ecde0c6bbc518a623738331/1c72d/2.jpg 590w,
/daily-study/static/20e379b44ecde0c6bbc518a623738331/a8a14/2.jpg 885w,
/daily-study/static/20e379b44ecde0c6bbc518a623738331/fbd2c/2.jpg 1180w,
/daily-study/static/20e379b44ecde0c6bbc518a623738331/76775/2.jpg 2386w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;React.createElement&lt;/h3&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/daily-study/static/1ef60f6f462d9fe9128baa26b2999e6c/76775/3.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 62.16216216216216%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAMEAQX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB6evhi8SJ/8QAGxAAAgIDAQAAAAAAAAAAAAAAAQIAEQMEEzL/2gAIAQEAAQUCAfomVWMqbC0qeP/EABURAQEAAAAAAAAAAAAAAAAAAAAR/9oACAEDAQE/AVf/xAAVEQEBAAAAAAAAAAAAAAAAAAAAEf/aAAgBAgEBPwFH/8QAHBAAAQQDAQAAAAAAAAAAAAAAAgABESEQIkFx/9oACAEBAAY/Aikq5Shil2zrrfEPi//EABsQAQADAQADAAAAAAAAAAAAAAEAETEhEEFR/9oACAEBAAE/IS1S8GInNor14rd2wxsp1yz7l42f/9oADAMBAAIAAwAAABBDP//EABURAQEAAAAAAAAAAAAAAAAAABAx/9oACAEDAQE/EIP/xAAWEQADAAAAAAAAAAAAAAAAAAABECH/2gAIAQIBAT8QFT//xAAbEAEAAwADAQAAAAAAAAAAAAABABEhMUFRcf/aAAgBAQABPxDygLHfb3kvktVbqtPsEeG4pgN3zE4AWwmOWQIS7RVrk//Z&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;3&quot;
        title=&quot;3&quot;
        src=&quot;/daily-study/static/1ef60f6f462d9fe9128baa26b2999e6c/1c72d/3.jpg&quot;
        srcset=&quot;/daily-study/static/1ef60f6f462d9fe9128baa26b2999e6c/a80bd/3.jpg 148w,
/daily-study/static/1ef60f6f462d9fe9128baa26b2999e6c/1c91a/3.jpg 295w,
/daily-study/static/1ef60f6f462d9fe9128baa26b2999e6c/1c72d/3.jpg 590w,
/daily-study/static/1ef60f6f462d9fe9128baa26b2999e6c/a8a14/3.jpg 885w,
/daily-study/static/1ef60f6f462d9fe9128baa26b2999e6c/fbd2c/3.jpg 1180w,
/daily-study/static/1ef60f6f462d9fe9128baa26b2999e6c/76775/3.jpg 2386w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;ReactDOM.render&lt;/h3&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/daily-study/static/907830f47053b4f098cdaed82229f6af/76775/4.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 62.16216216216216%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAUBBP/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHsyiiOsD//xAAaEAACAgMAAAAAAAAAAAAAAAACAwQQERQj/9oACAEBAAEFAtjtISTSGIeL/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGhAAAgIDAAAAAAAAAAAAAAAAAREAEiAxMv/aAAgBAQAGPwKlDtOAgpCdjD//xAAZEAADAAMAAAAAAAAAAAAAAAAAAREgIdH/2gAIAQEAAT8hVCiOfDYl1Yf/2gAMAwEAAgADAAAAELff/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFREBAQAAAAAAAAAAAAAAAAAAABH/2gAIAQIBAT8Qqv/EABoQAQACAwEAAAAAAAAAAAAAAAERIQAxQSD/2gAIAQEAAT8QZAF+hU3rAUyACXM8cRS0s68P/9k=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;4&quot;
        title=&quot;4&quot;
        src=&quot;/daily-study/static/907830f47053b4f098cdaed82229f6af/1c72d/4.jpg&quot;
        srcset=&quot;/daily-study/static/907830f47053b4f098cdaed82229f6af/a80bd/4.jpg 148w,
/daily-study/static/907830f47053b4f098cdaed82229f6af/1c91a/4.jpg 295w,
/daily-study/static/907830f47053b4f098cdaed82229f6af/1c72d/4.jpg 590w,
/daily-study/static/907830f47053b4f098cdaed82229f6af/a8a14/4.jpg 885w,
/daily-study/static/907830f47053b4f098cdaed82229f6af/fbd2c/4.jpg 1180w,
/daily-study/static/907830f47053b4f098cdaed82229f6af/76775/4.jpg 2386w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;Concurrent Mode&lt;/h3&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/daily-study/static/eb9ce91a112bb8afbb17df8aa7606618/76775/5.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 62.16216216216216%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAQFA//EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAGzFu5wmPB//8QAGRAAAgMBAAAAAAAAAAAAAAAAAQIAAwRB/9oACAEBAAEFAu7GItxEmmNWjFVCj//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABoQAAIDAQEAAAAAAAAAAAAAAAABAhEhEDH/2gAIAQEABj8CMb8He7y5RTKikj//xAAaEAEAAgMBAAAAAAAAAAAAAAABABEhMVEQ/9oACAEBAAE/IVbQaCx0xkTl2+WI/UlGLwJ//9oADAMBAAIAAwAAABAkD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABURAQEAAAAAAAAAAAAAAAAAAAEA/9oACAECAQE/EBlv/8QAGhABAQADAQEAAAAAAAAAAAAAAREAIVEQMf/aAAgBAQABPxAAV+62YXjWiha8xSdKosh3zRGZGsxYot0i9z//2Q==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;5&quot;
        title=&quot;5&quot;
        src=&quot;/daily-study/static/eb9ce91a112bb8afbb17df8aa7606618/1c72d/5.jpg&quot;
        srcset=&quot;/daily-study/static/eb9ce91a112bb8afbb17df8aa7606618/a80bd/5.jpg 148w,
/daily-study/static/eb9ce91a112bb8afbb17df8aa7606618/1c91a/5.jpg 295w,
/daily-study/static/eb9ce91a112bb8afbb17df8aa7606618/1c72d/5.jpg 590w,
/daily-study/static/eb9ce91a112bb8afbb17df8aa7606618/a8a14/5.jpg 885w,
/daily-study/static/eb9ce91a112bb8afbb17df8aa7606618/fbd2c/5.jpg 1180w,
/daily-study/static/eb9ce91a112bb8afbb17df8aa7606618/76775/5.jpg 2386w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;Fiber Tree 1&lt;/h3&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/daily-study/static/3066184703222b45876578806043db95/76775/6.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 62.16216216216216%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAMEAQX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAv/aAAwDAQACEAMQAAAB7E9eySOD/8QAGhAAAgIDAAAAAAAAAAAAAAAAAQIDEQQQIf/aAAgBAQABBQK+5Ku8cQIirf8A/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGxAAAQQDAAAAAAAAAAAAAAAAAAECETETIFH/2gAIAQEABj8CEx3PRqOvT//EABkQAAMBAQEAAAAAAAAAAAAAAAABESExUf/aAAgBAQABPyFtaQiKXlBy9rdpBKLD/9oADAMBAAIAAwAAABBvP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABsQAQACAwEBAAAAAAAAAAAAAAEAESExQXFR/9oACAEBAAE/EAoYv7FuoF4aex4Fqt2e9mS++xIB5kgBRqf/2Q==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;6&quot;
        title=&quot;6&quot;
        src=&quot;/daily-study/static/3066184703222b45876578806043db95/1c72d/6.jpg&quot;
        srcset=&quot;/daily-study/static/3066184703222b45876578806043db95/a80bd/6.jpg 148w,
/daily-study/static/3066184703222b45876578806043db95/1c91a/6.jpg 295w,
/daily-study/static/3066184703222b45876578806043db95/1c72d/6.jpg 590w,
/daily-study/static/3066184703222b45876578806043db95/a8a14/6.jpg 885w,
/daily-study/static/3066184703222b45876578806043db95/fbd2c/6.jpg 1180w,
/daily-study/static/3066184703222b45876578806043db95/76775/6.jpg 2386w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;Fiber Tree 2&lt;/h3&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/daily-study/static/2f5d9d041f5158f844ca8f38eb3402a7/76775/7.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 62.16216216216216%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAQCAwX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAABZYR1oiWkf//EABwQAAEEAwEAAAAAAAAAAAAAAAIBAwQRABASIf/aAAgBAQABBQKMZEaN8uUuRPXa1//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABwQAAEDBQAAAAAAAAAAAAAAAAIDEBEAASEyUf/aAAgBAQAGPwJSSvjtGU7Mo/8A/8QAGRABAQEAAwAAAAAAAAAAAAAAAREAEKHh/9oACAEBAAE/IaMRQMANL0zR1DrPcHj/2gAMAwEAAgADAAAAEBf/AP/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAECAQE/EGf/xAAaEAEBAQEBAQEAAAAAAAAAAAABEQAhYUFR/9oACAEBAAE/EBurWECvnmDpQo8OvmUwKL+mopUsGdvMI15OuOE3/9k=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;7&quot;
        title=&quot;7&quot;
        src=&quot;/daily-study/static/2f5d9d041f5158f844ca8f38eb3402a7/1c72d/7.jpg&quot;
        srcset=&quot;/daily-study/static/2f5d9d041f5158f844ca8f38eb3402a7/a80bd/7.jpg 148w,
/daily-study/static/2f5d9d041f5158f844ca8f38eb3402a7/1c91a/7.jpg 295w,
/daily-study/static/2f5d9d041f5158f844ca8f38eb3402a7/1c72d/7.jpg 590w,
/daily-study/static/2f5d9d041f5158f844ca8f38eb3402a7/a8a14/7.jpg 885w,
/daily-study/static/2f5d9d041f5158f844ca8f38eb3402a7/fbd2c/7.jpg 1180w,
/daily-study/static/2f5d9d041f5158f844ca8f38eb3402a7/76775/7.jpg 2386w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;Render &amp;#x26; commit phase&lt;/h3&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/daily-study/static/fb8696f6a0f34c59a70ef464c8ec6453/76775/8.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 62.16216216216216%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAIFBP/EABUBAQEAAAAAAAAAAAAAAAAAAAAC/9oADAMBAAIQAxAAAAGtioPJRg//xAAcEAABAwUAAAAAAAAAAAAAAAASAAECAxARFCH/2gAIAQEAAQUCNnkVfa6hjm3/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAbEAACAgMBAAAAAAAAAAAAAAABERAhABIxUf/aAAgBAQAGPwIgHmK9H5DQuf/EABsQAQACAgMAAAAAAAAAAAAAAAEAESExEFHh/9oACAEBAAE/IQNVWTqeB1QwgSBOzW+f/9oADAMBAAIAAwAAABB//wD/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAVEQEBAAAAAAAAAAAAAAAAAAAQEf/aAAgBAgEBPxCn/8QAHBAAAgEFAQAAAAAAAAAAAAAAAREAECExUXFh/9oACAEBAAE/EFF8DN+pcCL4YYNrDgKZD7CqyYkJe7r/AP/Z&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;8&quot;
        title=&quot;8&quot;
        src=&quot;/daily-study/static/fb8696f6a0f34c59a70ef464c8ec6453/1c72d/8.jpg&quot;
        srcset=&quot;/daily-study/static/fb8696f6a0f34c59a70ef464c8ec6453/a80bd/8.jpg 148w,
/daily-study/static/fb8696f6a0f34c59a70ef464c8ec6453/1c91a/8.jpg 295w,
/daily-study/static/fb8696f6a0f34c59a70ef464c8ec6453/1c72d/8.jpg 590w,
/daily-study/static/fb8696f6a0f34c59a70ef464c8ec6453/a8a14/8.jpg 885w,
/daily-study/static/fb8696f6a0f34c59a70ef464c8ec6453/fbd2c/8.jpg 1180w,
/daily-study/static/fb8696f6a0f34c59a70ef464c8ec6453/76775/8.jpg 2386w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;Reconciliation&lt;/h3&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/daily-study/static/c0888d9553b3f2e5da1baf5d4301af3d/76775/9.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 62.16216216216216%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAMFBP/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAGxMr5YaMI//8QAGxAAAQUBAQAAAAAAAAAAAAAAAgABAwQRIRL/2gAIAQEAAQUC3thvcwcBPXApcX//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAcEAABBAMBAAAAAAAAAAAAAAABABARMQMSEyH/2gAIAQEABj8CUDLqahAE0G6ey3//xAAZEAACAwEAAAAAAAAAAAAAAAAAAREhMVH/2gAIAQEAAT8hkmsia8tNGuxoTfSFwmClp7VEOH//2gAMAwEAAgADAAAAEBf/AP/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAECAQE/ECf/xAAcEAACAgMBAQAAAAAAAAAAAAABEQAhMVFhQZH/2gAIAQEAAT8QTLWri+CuVLPVeiAFG8AAnOD5BQ6xAyYUuRcf/9k=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;9&quot;
        title=&quot;9&quot;
        src=&quot;/daily-study/static/c0888d9553b3f2e5da1baf5d4301af3d/1c72d/9.jpg&quot;
        srcset=&quot;/daily-study/static/c0888d9553b3f2e5da1baf5d4301af3d/a80bd/9.jpg 148w,
/daily-study/static/c0888d9553b3f2e5da1baf5d4301af3d/1c91a/9.jpg 295w,
/daily-study/static/c0888d9553b3f2e5da1baf5d4301af3d/1c72d/9.jpg 590w,
/daily-study/static/c0888d9553b3f2e5da1baf5d4301af3d/a8a14/9.jpg 885w,
/daily-study/static/c0888d9553b3f2e5da1baf5d4301af3d/fbd2c/9.jpg 1180w,
/daily-study/static/c0888d9553b3f2e5da1baf5d4301af3d/76775/9.jpg 2386w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[객체지향의 사실과 오해 1]]></title><description><![CDATA[원제 객체지향의 사실과 오해: 역할, 책임, 협력 관점에서 본 객체지향 저자 조영호 ISBN 978-89-98139-76 독서 기간 2019-12-31 ~ 독서 량…]]></description><link>https://sukjae.github.io/daily-study/read-a-book/essence-of-oop-ch3/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/read-a-book/essence-of-oop-ch3/</guid><pubDate>Tue, 31 Dec 2019 00:00:00 GMT</pubDate><content:encoded>&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;원제&lt;/th&gt;
&lt;th&gt;객체지향의 사실과 오해: 역할, 책임, 협력 관점에서 본 객체지향&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;저자&lt;/td&gt;
&lt;td&gt;조영호&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ISBN&lt;/td&gt;
&lt;td&gt;978-89-98139-76&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;독서 기간&lt;/td&gt;
&lt;td&gt;2019-12-31 ~&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;독서 량&lt;/td&gt;
&lt;td&gt;3장&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;시작하기 앞서…&lt;/h2&gt;
&lt;p&gt;이 책을 읽기 전에 객체지향에 대한 나의 생각은, 객체를 기반으로한 복잡한 개발 방법에 지나지 않았다. 그 속의 철학과 용어들을 이해하려 하지 않은채, 어렵고 오래된 방법이라 치부하며 학습하지 않았다. &lt;/p&gt;
&lt;p&gt;이 책은 객체지향에 대해 무지하던 나에게 객체지향을 맛보게 해주고, 방향을 알려준 고마운 책이다. 이 책은 한번 읽었지만, 그 내용을 한번 더 정리하기 위해 부분 부분 중요한 내용을 요약하여 기록하고자 한다. &lt;/p&gt;
&lt;h2&gt;타입과 추상화&lt;/h2&gt;
&lt;h3&gt;추상화&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;추상화&lt;/strong&gt;라는 단어는 객체지향에서 정말 많이 언급된다. 이 책에서도 추상화가 정말 많이 언급 되는데, 책에서는 다음과 같이 그 필요성에 대해 말하기도 한다. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;추상화를 사용함으로써 우리는 극도로 복잡한 이 세상을 그나마 제어 가능한 수준으로 단순화할 수 있는 것이다 (p88)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;우리가 동시에 인지할 수 있는 객체의 수는 한정되어 있고, 그 객체는 끝도 없는 복잡함을 갖고 있다. 우리는 추상화를 통해 우리의 뇌에게 조금 덜 부담을 주고, 실수를 줄일수도 있을 것이다. &lt;/p&gt;
&lt;p&gt;그렇다면, 이 책에서는 추상화를 어떻게 정의하고 있을까?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;추상화란, 어떤 양상, 세부 사항, 구조를 좀 더 &lt;strong&gt;명확하게 이해하기 위해&lt;/strong&gt; 특정 절차나 물체를 &lt;strong&gt;의도적으로 생략하거나 감춤으로써 복잡도를 극복하&lt;/strong&gt;는 방법이다 (p77)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;복잡성을 다루기 위해 추상화는 두 차원으로 단순화 한다. &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;구체적인 사물들 간의 공통점은 취하고, 차이점은 버리는 일반화&lt;/li&gt;
&lt;li&gt;중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;두 방법 모두 가치를 쳐내듯 세부사항을 제거한다는 공통점이 있지만, 제거의 대상을 찾는 방법에 약간의 차이가 있다. 우리는 은연중에 모두 이 두가지 방법을 사용했을 텐데, 이렇게 짚고 넘어가니 나중에 점검하기도 좋은것 같다. &lt;/p&gt;
&lt;h3&gt;유사성을 기반으로 한 추상화 예시와 개념&lt;/h3&gt;
&lt;p&gt;책에서는 여러 객체들을 유사성을 기반으로 한 두가지 그룹으로 나누어 단순화 한다.(p82) 이렇게 다수의 개별적인 객체가 아니라, 두개의 큰 덩어리로 인식을 함으로서 우리는 내재된 복잡성을 효과적으로 감소시키게 된다.&lt;/p&gt;
&lt;p&gt;여기서 공통점(유사성)을 기반으로 객체들을 묶기 위한 그릇을 개념(concept) 이라고 한다. (p83) 이 개념에 대한 예시로는, 자동차, 비행기, 인간 이라는 개념이 있을 수 있다. &lt;/p&gt;
&lt;p&gt;이 개념을 기반으로 우리는 분류(classification)을 할 수 있다. 우리는 여러 객체중에 공통점을 기반으로 한 두 개념으로 나누고, 객체가 각 그룹에 포함되도록 분류하는 작업을 수행한다. &lt;/p&gt;
&lt;p&gt;분류란, 특정한 객체를 특정한 개념의 객체 집합에 포함시키거나 포함시키지 않는 작업을 의미한다.(p87)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;객체에 특정한 개념을 적용하기로 결심했을 때 우리는 그 객체를 특정한 집합의 멤버로 분류하고 있는 것이다(p87)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;우리는 개념이 객체에 적용됐을 때 객체를 개념의 인스턴스라고 한다. &lt;/p&gt;
&lt;h3&gt;개념의 3가지 관점: 심볼, 내연, 외연 (p84)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;심볼은 개념을 가르키는 명칭.&lt;/li&gt;
&lt;li&gt;내연은 개념의 완전한 정의.&lt;/li&gt;
&lt;li&gt;외연은 개념에 속하는 모든 객체의 집합.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;을 의미한다. &lt;/p&gt;
&lt;p&gt;책에서는 트럼프를 예시로 들어 다음과 같이 설명한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;트럼프라는 이름은 개념의 심볼이다&lt;/li&gt;
&lt;li&gt;몸이 납작하고 두 손과 두 발이 네모난 몸 모서리에 달려 있다는 트럼프에 대한 설명은 내연이다 (내연은 개념을 객체에게 적용할 수 있는지 여부를 판단하기 위한 &lt;strong&gt;조건이다&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;외연은 개념에 속하는 객체들, 즉 개념의 인스턴스들이 모여 이뤄진 집합&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;타입&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;타입은 개념이다(p89)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;저자는 프로그래밍 언어 관점에서의 데이터 타입을 다음과 같이 정의한다(p91)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;데이터 타입은 … 메타데이터 이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;책에 따르면, 우리가 앞서 이해한 “개념(concept)“를 수학적으로 차용한 언어로 바꾸면, “타입(type)“이 된다. 타입은, 공통점을 기반으로 객체들을 묶기 위한 틀이다. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;어떤 객체에 &lt;strong&gt;타입은 적용&lt;/strong&gt;할 수 있을 때 그 &lt;strong&gt;객체를 타입의 인스턴스&lt;/strong&gt;라고 한다. (p89)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;저자는 이 책에서, 타입에 대한 이해를 돕기 위해 자료형에 대해 언급한다. 이 부분은 생활코딩에서도 한번 들은적이 있는데, 그 내용을 정리하면 다음과 같다. &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;타입은 데이터가 어떻게 사용되느냐에 관한 것이다. &lt;/li&gt;
&lt;li&gt;타입에 속한 데이터를 메모리에 어떻게 표현하는지는 외부로부터 철저하게 감춰진다. &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;자료형을 예로 들면, 숫자형 데이터가 숫자형인 이유는 더하거나 빼는등의 연산자를 적용할 수(사용할 수) 있기 때문이다. 즉, 중요한 것은 연산자의 종류가 아니라 어떤 데이터에 어떤 연산자를 적용할 수 있느냐가 그 데이터의 타입을 결정한다. (p91) &lt;/p&gt;
&lt;p&gt;이 책에서 여러번 언급되 듯이 객체에서 중요하고, 그 타입을 결정하는 것은 내부의 상태가 아니라, &lt;strong&gt;행동&lt;/strong&gt;임을 기억하자. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;상태는 행동의 결과로 초ㄹ래된 부수효과를 쉽게 표현하기 위해 도임한 추상적인 개념일 뿐이다(p92)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;객체가 협력을 위해 어떤 책임을 지녀야 하는지를 결정하는 것이 객체지향 설계의 핵심이다.(p92)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;결과적으로, 객체를 타입에 따라 분류하고 이름을 붙이면 결국 프로그램에서 사용할 &lt;strong&gt;새로운 데이터 타입을 선언&lt;/strong&gt; 하는 것이다.(p92)&lt;/p&gt;
&lt;h3&gt;행동이 우선이다&lt;/h3&gt;
&lt;p&gt;앞서 여러번 언급 되었듯이, 객체가 어떤 행동을 하느냐에 따라 객체의 타입이 결정되며, 객체의 타입은 내부 표현과는 아무런 상관이 없다.
그러므로 동일한 데이터를 갖고 있더라도, 다른 행동을 한다면 그 객체들은 서로 다른 타입이다. (p93)&lt;/p&gt;
&lt;p&gt;이를 종합해 보면 객체들이 동일한 메세지를 수신하고 처리한다면, 그 내부 구현 방법이 다르더라도 동일한 타입으로 본다. 이는 다형성과 관련이 있는 부분이다. &lt;/p&gt;
&lt;h3&gt;타입의 계층&lt;/h3&gt;
&lt;p&gt;타입간에는 계층 관계가 존재할 수 있으며 그 관계는 일반화/특수화(generalization/specialization)의 관계를 갖는다. 타입간의 계층 관계는 개념의 외연적 표현으로 미뤄 봤을 때 하나가 다른 하나를 부분집합으로서 갖는 모양이 된다.&lt;/p&gt;
&lt;p&gt;계층관계에 있어, 특수계층의 경우 더 많은 행동의 수를 갖으면 더 적은 외연 집합을 갖게 되고, 일반계층은 반대의 성향을 보인다. &lt;/p&gt;
&lt;p&gt;일반적인 타입을 &lt;strong&gt;슈퍼타입&lt;/strong&gt;, 특수한 타입을 &lt;strong&gt;서브타입&lt;/strong&gt; 이라 표현할 수 있다. &lt;/p&gt;
&lt;p&gt;이 두 관계도 위에서 말한 타입간의 관계가 행동에 의해 결정되고, 행위적 호환성을 만족해야 슈퍼-서브 타입의 관계가 될 수 있다는 사실에는 변함이 없다. &lt;/p&gt;
&lt;p&gt;이를 책에서는 다음과 같이 표현한다. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;어떤 타입을 다른 타입의 서브타입이라고 말할 수 있으려면 다른 타입을 대체할 수 있어야 한다. (p100)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;타입의 목적&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;타입은 시간에 따라 동적으로 변하는 앨리스의 상태를 시간과 무관한 정적인 모습으로 다룰 수 있게 해준다. (p102)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;책에서 앨리스를 갖고 소개하는 은유를 통해, 앨리스의 상태가 계속 변하는 것에 초점을 맞추는게 아니라 변경되는 상태를 갖는다 라고 단순화 한다 라고 표현한다. 이를 통해 상태에 복잡성을 부여하는 시간이라는 요소를 배제한체 정적인 모습의 객체를 생각할 수 있게 해준다. &lt;/p&gt;
&lt;p&gt;이는 앞서 말한 추상화와 크게 관련이 있다. 결국, 이러한 관점 또한 불필요한 부분을 도려내고 객체를 바라보는 추상화인 것이다. 그러므로 타입은 추상화이기도 하다. &lt;/p&gt;
&lt;h3&gt;클래스와의 관계&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;타입을 구현하는 가장 보편적인 방법은 클래스를 이용하는 것이다. (p104)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;클래스와 타입은 동일한 것이 아니다.&lt;/strong&gt;  타입은 객체를 분류하기 위해 사용하는 개념이며, 클래스는 타입을 구현할 수 있는 여러 구현 메커니즘 중 하나일 뿐이다. &lt;/p&gt;</content:encoded></item><item><title><![CDATA[Node.js Design Patter 1]]></title><description><![CDATA[원제 Node.js Design Patter 제목 Node.js 디자인패턴 저자 Mario Casciaro, Luciano Mammino ISBN 9788931459425 독서 기간 2019-11-23 독서 량 1장 시작하기 앞서… Node…]]></description><link>https://sukjae.github.io/daily-study/read-a-book/node-design-pattern-day1/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/read-a-book/node-design-pattern-day1/</guid><pubDate>Mon, 23 Dec 2019 00:00:00 GMT</pubDate><content:encoded>&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;원제&lt;/th&gt;
&lt;th&gt;Node.js Design Patter&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;제목&lt;/td&gt;
&lt;td&gt;Node.js 디자인패턴&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;저자&lt;/td&gt;
&lt;td&gt;Mario Casciaro, Luciano Mammino&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ISBN&lt;/td&gt;
&lt;td&gt;9788931459425&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;독서 기간&lt;/td&gt;
&lt;td&gt;2019-11-23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;독서 량&lt;/td&gt;
&lt;td&gt;1장&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;시작하기 앞서…&lt;/h2&gt;
&lt;p&gt;Node와 Express로 서버를 만들며, 무언가 풀리지 않는 의문들이 많아서 보게 되었다. 이 책은 Node에서 적용 가능한 여러 디자인 패턴을 다루고 있고, 이 패턴들은 다양한 환경에서 적용 가능한 범용적인 내용들을 다루고 있는듯 하다. 이 책을 읽으므로서, Node를 어느정도 안다고 하는 수준으로 만들고 싶다.&lt;/p&gt;
&lt;h2&gt;새로이 알게 된 내용들&lt;/h2&gt;
&lt;h3&gt;busy waiting (p38)&lt;/h3&gt;
&lt;p&gt;논 블로킹 I/O에서 액세스 하는 가장 기본적인 패턴으로 루프 내에서 리소스를 계속하여 polling하는 방법이 있다. 이를 busy-waiting이라 한다.&lt;/p&gt;
&lt;p&gt;바쁘게 기다린다는 단어 선택이 딱 맞는것 같다. 하는건 없지만, 굉장히 바쁘게 움직이는 모습이다.
이 방법은 당연스럽게도 CPU 시간에서 큰 낭비를 불러온다.&lt;/p&gt;
&lt;h3&gt;동기 이벤트 디멀티플렉서 (이벤트 통지 인터페이스)(p39)&lt;/h3&gt;
&lt;p&gt;최신 운영체제에서 효율적인 논 블로킹 리소스 처리를 위한 메커니즘중 하나이다.
이 구성요소는 감시된 일련의 리소스들로부터 들어오는 I/O 이벤트를 수집하여 큐에 넣고, 처리할 수 있는 새 이벤트가 있을때 까지 차단한다.&lt;/p&gt;
&lt;p&gt;각 운영체제에는 이러한 이벤트 디멀티플렉서에 대한 자체 인터페이스가 존재한다. 이에 각각 대응하여 작업하기에는 매우 힘드므로, Node.js에서 libuv 를 통하여 높은 추상화를 제공한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[TS에서 any대신에 $TSFixMe]]></title><description><![CDATA[오늘 정말 간단한 것에서 생각의 확장이 이루어진것 같다. 대단한건 아니지만, 나로서는 굉장시 신박하였고, 창의적이였다. 지하철에서 부스트 캠프를 가면서, airbnb에서 typescript를 적용한 사례에 대한 영상을 보고 있었다.
Adopting…]]></description><link>https://sukjae.github.io/daily-study/daily/2019-12-05/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/daily/2019-12-05/</guid><pubDate>Thu, 05 Dec 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;오늘 정말 간단한 것에서 생각의 확장이 이루어진것 같다. 대단한건 아니지만, 나로서는 굉장시 신박하였고, 창의적이였다.&lt;/p&gt;
&lt;p&gt;지하철에서 부스트 캠프를 가면서, airbnb에서 typescript를 적용한 사례에 대한 영상을 보고 있었다.
&lt;a href=&quot;https://youtu.be/P-J9Eg7hJwE&quot;&gt;Adopting Typescript at Scale - Brie Bunge | JSConf Hawaii 2019&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;영상 전반에 걸쳐 좋은 내용들이 가득했지만, 특히 &lt;code class=&quot;language-text&quot;&gt;아하! 모멘트&lt;/code&gt; 를 주었던 부분이 있었다. (나만 몰랐던 것 일수도 있다..ㅎ)&lt;/p&gt;
&lt;p&gt;바로 이 부분이였는데, 한번 살펴보길 바란다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/daily-study/static/a6e34dc5041f78b5f5a773152333e3ad/a2b91/index.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 62.83783783783784%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAADnElEQVQ4y02SaVDUZRzH/yzgynLtbuwusizHEIIsQhzLbiwLyI0gigtxLBBHRmio40hCKHRoAmkyLOPxgkkapzXJJskQ5DBeVCM1KWhlNdKUveiCnIkpsPLTn+1Nv5nP8/09z4vPPJeg9lfio3gEDy8Fa72VyBRqPFXrkGm0+AQGIwvQIch8cfH2RaJQ4KJU4qJQIvFT4a7WsNZ/HZ5aHe4qDV5BIQhzn2eRnCpFt96XsHg1gXFaAg0haM3r8UvWozJHE5odi9yYgGu8CWlyKh6WDHyy8tFsK0NbYsNvSwmyvK14FpYg9A0mEpPgjTrIA12UnOBYNT7BKjxCtEjDQ5FuCMdN/yhCVARC5AYEfTQuBhOSlDTcRNakZeK6KRuP3ELk20oRxFod8PORo/FTOPuIrZHk9m3BeCgf/YEC8rp2UnOqk8q+Nir7D1Fp76Ci/0UKju5H21SMtlnc6e5KMav+E0pcXDnW2EDD5iSnMLY2jrJLdWSdrCamu4Qrt6fhjxX+uv8b/ywssLK0BCsrzP98j/AX6glrryO0rQ5dy5MI0jVrcJMI2Hc8RWNeOkpXCWGlj2HotxLRWYSmLQf7pINv579h9uvbzN2ZY/bul9y5+xWXb3yIfLcV711WZM9YUTbbEDxEocJTxl5rLod31KB0dyPGtom+62/SM3GW7vHX6Z08h336Ar1Tb3FiaogTk0Mcn3yboyMOOt4d5OA7g7w07MDyShtCSlwM8ZGxNNc3crqn13nk7KYy+BMezC/xYOFvFu/Dr78ss7j4kN/FyY/ff8dPP9zj4fIy/6/WC28gRCea2Jhg5Nn6Og7va3EKUxqKmZ7/jMmbHzN+a4axW58wNjfD6NxqXmfkxkdOVtfG5j5l5OYMH3wxi9X+KoI2XI8xy0p5eSl5SUanMHS7mY3HqsU7LCe8o4Kwg+WEPF+BrrWSwOeqCNhfjf++avz2VKPYVYVvUxVejTXInhYfJcpgwGQtInFzHvowC66CG0HFZqJ6akVRBaHtFQS1iV/iQCUBLTZRZEOz14ZqTxVKUabcWY28qRZZYy3SBlHY2W2n8/hpjvSe4cjLdl7rOoV94Bznxye4OHoVx6URhi6PcnHkqsgEjitTDLx/jTPDU5wcvkbX+fdoHXDQfnaIrqFRhAxzBrnpOeRYskhNMpNpspCRmEyOIYV8o0UklcLH0ygwiSmSb8kkIy2XVEs2KeZM0jPy2V5UyhNFJc7+X541KeLHbqQJAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;index&quot;
        title=&quot;index&quot;
        src=&quot;/daily-study/static/a6e34dc5041f78b5f5a773152333e3ad/fcda8/index.png&quot;
        srcset=&quot;/daily-study/static/a6e34dc5041f78b5f5a773152333e3ad/12f09/index.png 148w,
/daily-study/static/a6e34dc5041f78b5f5a773152333e3ad/e4a3f/index.png 295w,
/daily-study/static/a6e34dc5041f78b5f5a773152333e3ad/fcda8/index.png 590w,
/daily-study/static/a6e34dc5041f78b5f5a773152333e3ad/efc66/index.png 885w,
/daily-study/static/a6e34dc5041f78b5f5a773152333e3ad/c83ae/index.png 1180w,
/daily-study/static/a6e34dc5041f78b5f5a773152333e3ad/a2b91/index.png 3360w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;typescript를 쓰면서, 그 방법을 찾기 어려울때 주로 사용되는게 any이다. 와일드 카드 같은 역할로서, type에 상관없이 다 받겠다는 의미이다.
단편적으로만 생각해도, “type” script에서 type에 상관없이 받겠다는 것은, 그냥 JS처럼 쓰겠다는 의미이고, 자주 사용해서는 안되는 방식이다.&lt;/p&gt;
&lt;p&gt;모든 값들은 type을 지정해 줄 수 있음에도, 당장의 편의를 위해서 any를 사용하곤 하였고, 그러면서 가슴 한편에 불편함이 가득했다.&lt;/p&gt;
&lt;p&gt;언젠간 고쳐야지 하면서도, 아무런 문제없이 돌아가는 코드를 보고 고칠 생각을 하지 않았다.&lt;/p&gt;
&lt;p&gt;하지만 위와 같이 태그처럼 (나는 개인적으로 위트있는 방식이다 생각한다) 사용하면, any가 주는 의미보다 더 강력하게 다가온다.&lt;/p&gt;
&lt;p&gt;현재 잘 돌아가는 부품으로서의 역할이 아니라, 미래 어느시점에 고쳐야 한다고 밑줄을 그어 놓은 것 같은 느낌이다.&lt;/p&gt;
&lt;p&gt;언젠가 나와 내 동료가 위 fixMe를 보고 any보다 더 큰 불편함을 직관적으로 느끼게 될것이고, 자연스럽게 수정에 이를 것이다.&lt;/p&gt;
&lt;p&gt;단어 혹은 변수명 하나를 잘 짓는게 이렇게 효과적이다!!&lt;/p&gt;</content:encoded></item><item><title><![CDATA[IAM 정책 기본적인 내용 정리]]></title><description><![CDATA[발표명 IAM 정책을 잘 알아야 AWS 보안도 쉬워진다. 이것은 꼭 알고 가자! 발표자 신은수 솔루션즈 아키텍트(AWS) 출처 https://youtu.be/iPKaylieTV8 오늘은 AWS의 IAM…]]></description><link>https://sukjae.github.io/daily-study/online-conference/aws-iam-policies/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/online-conference/aws-iam-policies/</guid><pubDate>Thu, 05 Dec 2019 00:00:00 GMT</pubDate><content:encoded>&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;발표명&lt;/th&gt;
&lt;th&gt;IAM 정책을 잘 알아야 AWS 보안도 쉬워진다. 이것은 꼭 알고 가자!&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;발표자&lt;/td&gt;
&lt;td&gt;신은수 솔루션즈 아키텍트(AWS)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;출처&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://youtu.be/iPKaylieTV8&quot;&gt;https://youtu.be/iPKaylieTV8&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;오늘은 AWS의 IAM인증에 대해 다시 한번 정리해 보았다. 정리를 하며 좋은 강의(발표)가 있어서, 내용중 일부분을 정리하고자 한다.&lt;/p&gt;
&lt;p&gt;발표는 2019 AWS Summit Seoul에서 진행되었다. IAM에 대한 기본적인 설명(메카니즘)과 활용방법(팁)들이 포함되어 있다.&lt;/p&gt;
&lt;h3&gt;계정 생성&lt;/h3&gt;
&lt;p&gt;AWS의 서비스를 사용하기 위해 다음과 같은 종류가 존재한다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/daily-study/static/1a1d300ca7b2debf0b36cc1d835e8fc3/6b26f/1.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 55.4054054054054%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAACkUlEQVQoz4WSSUjUARTGR8m0RWfGNkXBEnMdM7dOKnUoSFPBZnTy1KFDmFuGhVCUWZmCFth+taYQ0ksokQVCUU7mNjOa5pLOODZO6uQsLqm//i60YNSDH++7vMf3PZ4oMDgC/5B9bPMJImRvHOvdvQmNjMPLLwxP7wBi4hMJlUUTHRWFSCT6P4oEP6oLZJRm+nIpbQvnDm+iWL6d88nuFBx0pUIpJinWm4DAcKRiMRIPCRLxKoKWiqV4SjwFLcbZyRlRQrAbV9M9uXbMB8ubMmaay7C+K8f2tgybupKZpkKsfa8wma1YxieYnLAITC5jEbR5zIzZZMaoHyE0OGTJpdOK1XUSDGPTWL/DuA2+zcIcsMi/S9fRTNPLeqxTVqIjhbM4r2YXu7mgaVGj7+/lk64DfV8PkyYjZqMew7CA4MCgN/zWDYwIenBggM+DQwz2DxISFIxos6+MnUcv4J9WRPypKvbn3SM+9w4JObdJyH9AYnY5udk55Obk/ZX8vNOcPZNH1skspBIpIhcPL1x3x7MjOpHa5iEaOsd41mGiXuj1GjMfhqaWoy3ML65h6R7TjlnaWt9jtzmI2BOxlHYl8kaB0d5ubMZh7KN6sAuLZh3gsDFvsy8PTjtmfuKwzzA3t8AX4wjVNQ8xmcaICBcWbpVFEn48myDlCVKLK1CUVpFccoOUkpscuVyJ4votkoquoJBnkJGuXIMiI5MMeQpKZSYe7mJE7n4B+BxIZNehVFTqTmraPqJq7eJJWzePBV2rG+B5n4GJ8cnVl1lh4us4Ftsc+ob7lMljqVOpiImJ/RV5g5MTrxsb0bW0oFGr6Wlvp1+rpU+jpV/XhaZT+ycdGjTablpf1HH3YiFPVY8IC5XxA1VURZs5NsKtAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;1&quot;
        title=&quot;1&quot;
        src=&quot;/daily-study/static/1a1d300ca7b2debf0b36cc1d835e8fc3/fcda8/1.png&quot;
        srcset=&quot;/daily-study/static/1a1d300ca7b2debf0b36cc1d835e8fc3/12f09/1.png 148w,
/daily-study/static/1a1d300ca7b2debf0b36cc1d835e8fc3/e4a3f/1.png 295w,
/daily-study/static/1a1d300ca7b2debf0b36cc1d835e8fc3/fcda8/1.png 590w,
/daily-study/static/1a1d300ca7b2debf0b36cc1d835e8fc3/efc66/1.png 885w,
/daily-study/static/1a1d300ca7b2debf0b36cc1d835e8fc3/c83ae/1.png 1180w,
/daily-study/static/1a1d300ca7b2debf0b36cc1d835e8fc3/6b26f/1.png 1658w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;여기서, IAM 사용자를 ID/PW와 같은 방법으로 접근하는 방식은 Permanent한 자격 증명이다. 반면, 임시보완 자격 증명의 방식은 Lifetime을 갖게 되고 결과적으로 보안에 이점이 생긴다.&lt;/p&gt;
&lt;h3&gt;서비스 이용 방법&lt;/h3&gt;
&lt;p&gt;AWS의 서비스를 이용하는 방법은 다음과 같이 low에서 high로 다양한 방법이 존재한다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 334px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/daily-study/static/0c4c1bb2fb6646aeba49ba907b7bb29a/86d36/0.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 118.24324324324324%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAYCAYAAAD6S912AAAACXBIWXMAABYlAAAWJQFJUiTwAAAFN0lEQVQ4y52Va3BNVxTHVRKEQWKmSCIerTJ86Ixpx5D7PDf33tyb3LxIboR69yUTrVdIRBBCqy31TnBpKSP0QxiPmBJJUImIV9WjM01SJdx7kxbBUF9+XeckSn3otP3wn7332uv8zjp7rbNXO53OgMliw6hYRbb/LJPF2jbKWtROp38GtP8vqc+ao+2aTM+BYrCaUKxmFJuCxWb+B5m0UdH8TRjMFkbojJoM5mgB6lo33hi8nJCQE4SEHqV79zK6diujW/c2dWtbi0JDj4nfd/TocZK+/YuITUjk/WmZfJAxHacrkXZROvWNeoEcJSgQBg58SETEYxkf07fvEyIjn9Cvv6jfH5otrPdT0tLvExwMQUE/kTQqnZzcPBbnLychcbQA9SrQIG89QnAnGD68iZE6P9FWHynuJhTFj9HUhMPhR6/z0TfyHmlpzfQIfUSHoMu43eOZNWsOGRkzSExKaQUqAozo8zUBgQ/oFHybwCCfpk7BTRKFn/YBPl5p7yMgwEuHjuqen8DAFnqFHUdvNGugWFeSzBU1KSZJipH4JA+j3V6SU+tIGl1P4qh6EpLrcSU1MMrdgHtsvew3iOo1n1HuO7J/EL3JLGMKDjk/vZoUvWRHBaakljJh4iM5Hx/z85op+KSZJQU+Pvu8iYzMJhYs9LNmXTOLFvtIH+sX3xZS085JZh044xOxxsS2ZlmvV4EGeeMh0qc8IGX8HabP9ZO10MeMHB/ZApic4WPqdC+5BV4yZ3txT/CL7z1Gp5+VCB2S6WRsDlcbULJsEGCyw8N7zmamOG8wKeYm7xhvMdHayHilkQkWmUfL3KKub4vPTd51/oY75gA6k4m4+JeAepuRDwfspaDjQ5aGetlqaGRn/C22RN1gq+0XtuhusSv+JpsMMjf+ypKQOyzt1MKcsJNSAdHExidh/1uEUv2Z/Q6zrPMTlvRo5svBfgrf8or87HA1sj3uFtvtXlYN8rF+mJel4lPQ5SHzws5jMsZoxf0SUCLsf4BFXZ6S2+13cru0MDeghWV9Wig0NrNzUiNro+4yT8oqp/N9crveZWGXx3wcXisR2rQI//pkgwCj5NfLeDOXjeGlrI7cx5pwUZ/9on2si9xP0aAS1kaUsLpXCWvCSjSfDeGHyR6yUkrF3HaGcc+ARkZaLRQOnc+FcA+nIgupGfoV1a9t0VSlqr+H2rd3cd5QzNnh33AqYgO1ER72Dlwun2xtO8MXgFEqcEg+NeE7qQjzcC7mIOecpdSmlHJp0jFODxOQcR+Xx1VwIeUox3tupjpiB9++vgrFKJ+c8EJSnkW4anAOp1/dRlnvIsol0oqILVT281A5YBsVvTZR0VO1b6IsvEjzOdXLw44By1qzrAKdrueFPVIxszx5AdXj9lGeXkzFmL2iPZSn7hYVU54mUtdjZC99D8fFp2pcCYXJKxgh/7L6H0fbnW33oQB1isLuzM005J/hSl4lV/NOcH3J99SvO0dd0XnqPRdp8Fzi2ooqri5Q9yupy6+m9KNioqOd2GNdGtQsF7UWoc6iUDxNgLnV/JhdwdXsSq7lnaKh8CI/rzxLnYBv7rzG9U+ruJJVzhXxqVtQxZFpu3DFJWmX68yZWVpi2hkEGGVW2Dj1C37IPkZ11iFq5pZyJuswZ2aLZslaxpp5pZq9Ruyqz6WcMnZMXk+qe6xcHPlkZeXI/ZmuRmiQbmXHYnHisicSZ0/AZXumRM2mjdYX7Qma3WJxSPtwECeXg1qLFptD7SmtTcogbVQvDUev/HsZtNYrz5ksmtT5n13rJLThqnReAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;0&quot;
        title=&quot;0&quot;
        src=&quot;/daily-study/static/0c4c1bb2fb6646aeba49ba907b7bb29a/86d36/0.png&quot;
        srcset=&quot;/daily-study/static/0c4c1bb2fb6646aeba49ba907b7bb29a/12f09/0.png 148w,
/daily-study/static/0c4c1bb2fb6646aeba49ba907b7bb29a/e4a3f/0.png 295w,
/daily-study/static/0c4c1bb2fb6646aeba49ba907b7bb29a/86d36/0.png 334w&quot;
        sizes=&quot;(max-width: 334px) 100vw, 334px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;이 중 Declarative한 방식은 자주 사용되는 Provisioning tool들을 뜻하고, CloudFormation, Terraform등이 존재한다.&lt;/p&gt;
&lt;h3&gt;SigV4&lt;/h3&gt;
&lt;p&gt;AWS의 서비스를 사용하기 위해서는 SigV4를 사용하여 Signature를 생성한뒤 요청시에 포함해야 한다. 포함은 Header나 query등 다양한 곳에 위치할 수 있다.&lt;/p&gt;
&lt;p&gt;CLI나 CDK같은 도구를 사용시에는 자동으로 매 요청마다 포함되므로 생각할 필요는 없지만, 이와 같은 도구 없이 서비스를 만드는 경우를 위하여 Signature를 만드는 방법이 AWS에 소개되어 있다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/daily-study/static/336c7f585fc55ed051ef485edaf3d585/a9577/2.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 53.37837837837838%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAACFElEQVQoz2WSWW+bQBRGwZjdeMEMmMVgbEdynBjvSaqmifrQVEn7///O6TCuGqV5OLoMM/e7q9ZsGp6+PfH49ZH9bs/r6xvPz985nc7stnt+vf2W98+8/PiJrnXQNE2i/0X7TM/vEccJQS/A83zC0Yh0PCATIRMxJk9iUmlTEWEbOqau0dUutGfX7EoMhWd1W9GPEXRJ3nVYJgW7zZbtbcPN+obVakWe50zzgllZKnqe98+ntYYMpkXjiERmeLET0kRQmCOu3Ywrd8KuafjycOZwu+Hc7NludhRFSV0v1Huza+I6LrZl4znORTAWsRLMs5woHFOlDvebPs2yz00Vcroquc+nHMuCY7Pm7tywba6ZTCKEEKRppjTSJPlccpu26DuUkc+mH3AOhjz0Q+6GIcdpzFa4HGKP9dil9jvE0sf/qPFZcGBYhLpDaLpUWcaqrFnP56yqmoHpMLRcAtNm5HhEcpCi1yOQ5fqWgdb2wHM9HNvBMi3VC1deej2fxJOOmk3fDinyikkykaUJaRNZqtwAGayQQ8rSVE7Yp9Ou0nAwpJ7V6vFysVSItp/TikfZ08wKmC1WFLMrbuWADvs993cPcigzJTiv5yohXTMk+nvJRsdQ0UQk/lsjk/XimtP+yGF3oJy2E67Uvl7uL0ve1a3L92g4UhNuo7yL6IqOooOl2/hOgGXY8mwouh1TirzT/mt9/wDRIwuocbbCewAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;2&quot;
        title=&quot;2&quot;
        src=&quot;/daily-study/static/336c7f585fc55ed051ef485edaf3d585/fcda8/2.png&quot;
        srcset=&quot;/daily-study/static/336c7f585fc55ed051ef485edaf3d585/12f09/2.png 148w,
/daily-study/static/336c7f585fc55ed051ef485edaf3d585/e4a3f/2.png 295w,
/daily-study/static/336c7f585fc55ed051ef485edaf3d585/fcda8/2.png 590w,
/daily-study/static/336c7f585fc55ed051ef485edaf3d585/efc66/2.png 885w,
/daily-study/static/336c7f585fc55ed051ef485edaf3d585/c83ae/2.png 1180w,
/daily-study/static/336c7f585fc55ed051ef485edaf3d585/a9577/2.png 1784w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;IAM Policy&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Policy를 정의할 때는 어떤 IAM Principal이 어떤 Condition에서 AWS의 어떤 Resource에 대해 어떤 Action을 허용/차단 할것인지를 지정한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;IAM Policy의 종류와 사용 목적&lt;/h3&gt;
&lt;p&gt;다음과 같이 크게 두 분류의 정책이 존재한다. 하나는 사용하는 쪽에 정책을 정의하는 것이고, 다른 하나는 사용되는 곳에 정책을 정의하는 것이다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/daily-study/static/b480a25cdbd7fa956bcfe31f2d83aace/764d7/3.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 50.67567567567568%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB8ElEQVQoz21SXU/cMBB0vh3biZM4n+ckvuOuqECFiuCBPtBSJNTHtv//xwzrnFoJtQ+jXcvW7MyO2e3tZzw+fsHT01fc3d3j+voTXl9/4NfP37i+usHL9xc8f3vGw/0DGGN/EbDgXf8HzNkJ8zTAzTtcuBm9qSHSGDyJwOMQaZLQQ4Y4imGtxTTtYEyLuqpRlnpDRX2ei/MA2xWYGoVd66vc0JcZ2pJjqDiSiAiDGFmSYmq7DbUqoDKOgufQuURJZB4ZDWVuqLAOGktfYfbkpqSqcWEN3GRwtDUu1xajoXs7w60r3LJinZetHvYHHNweHanmaQbWaJKtJJSgKVJCFwpaCTpzVNQXVL0VledYyK7tR7RksasbNGTXw/YDBDkIveWjWzDQ3ppSoiIiQRY4l1tVskCWnQkFFxi7HoLOIiW7dC+pz0mVlop2niLyodzse1ytBh/mBh8Xg3U0RJy/S9QjjZNN4ZHsTW1Pbwq0uiIxLQzVyAcXhGCnuYMjktPSw+/TBzIQsijcvkHIwi3llMKZya7bWQqsghZyI603lHRWZ8K1U3B9AUtBTCanVNk/6jzCOMIwjRC0ayEFiqJA5b8MqasJhnbqB7Ng+5hnzHGNKdbYRWQl0jglA45xj8tkxD5u4Qg1E9iHBgXj/xkc4A2g4+yZsMC0lAAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;3&quot;
        title=&quot;3&quot;
        src=&quot;/daily-study/static/b480a25cdbd7fa956bcfe31f2d83aace/fcda8/3.png&quot;
        srcset=&quot;/daily-study/static/b480a25cdbd7fa956bcfe31f2d83aace/12f09/3.png 148w,
/daily-study/static/b480a25cdbd7fa956bcfe31f2d83aace/e4a3f/3.png 295w,
/daily-study/static/b480a25cdbd7fa956bcfe31f2d83aace/fcda8/3.png 590w,
/daily-study/static/b480a25cdbd7fa956bcfe31f2d83aace/efc66/3.png 885w,
/daily-study/static/b480a25cdbd7fa956bcfe31f2d83aace/c83ae/3.png 1180w,
/daily-study/static/b480a25cdbd7fa956bcfe31f2d83aace/764d7/3.png 1782w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/daily-study/static/04bd8950d3130474c8026781c3b5ae04/e92cd/4.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 52.70270270270271%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB+0lEQVQoz3VSy1LbQBBcabWynl5JlgpLtiyRsmxjwMEV/IJTEhI+IARy50DBHwQO+YmkknxtZ7R24YTAoWtmt3Z6uneGnZ19wHK5wunJKfb3D7BaneDq8gqL+QLz2Vzdn388R6fTBWMMOtOh6QTBISwTwm5Ap1wzuIoskRLSdtDym2hatsrjpoRLued6Cg7dGdxQhBrTwKhYBgFGwz1U1RCdPIemaeCuWb9hMA2BrN2GR4XrIgZOYE9QkynUhL5Ef1xgcNBDmWUQ1FC3BZiUARZkbXY8w3KxRK9XKEJTI1tkT38G3BSqQZQ76I0kIp3IahG1Qk3nyLo5CiIa741RN3hJ4aNSYSilwjRgmPxRPXeI0Cep+cbq9GiKsthVeWV28TO5x4/0K34NvuF7fo/fyQMeomtYDVu9SQof5ShEbFlrwlrhVIZ4F8VIaRALmujb6TEyq4GMR7iVn3ETXuA2/YKb+AJ38hKfvPcwzYYilImNds+HpxtbhU/tNAghF8r2S5Z1c01gkyLLFWrC9dmoFRZFqf6ujlW/wuHkNQJSy9U/8mehi/UKxbsu+pMIobFZKZti6LhIiCCwXQSUh44Hl/51PRRtuyob1IW256IVtpDstNBOYyQyQrqTwo2a/1veQvvL9r+EfigxPjrEq0GFblnSPg4xeTNFmCX4A/MTBz7XgmqNAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;4&quot;
        title=&quot;4&quot;
        src=&quot;/daily-study/static/04bd8950d3130474c8026781c3b5ae04/fcda8/4.png&quot;
        srcset=&quot;/daily-study/static/04bd8950d3130474c8026781c3b5ae04/12f09/4.png 148w,
/daily-study/static/04bd8950d3130474c8026781c3b5ae04/e4a3f/4.png 295w,
/daily-study/static/04bd8950d3130474c8026781c3b5ae04/fcda8/4.png 590w,
/daily-study/static/04bd8950d3130474c8026781c3b5ae04/efc66/4.png 885w,
/daily-study/static/04bd8950d3130474c8026781c3b5ae04/c83ae/4.png 1180w,
/daily-study/static/04bd8950d3130474c8026781c3b5ae04/e92cd/4.png 1778w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;IAM Policy의 구조&lt;/h3&gt;
&lt;p&gt;이 구성요소는 필수사항이 아니다. 단, 항상 암묵적으로 Deny를 유지함을 기억하자!&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/daily-study/static/f9b9cc4a74d8d60a4dab6965da0bff75/e92cd/5.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 56.75675675675676%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABzklEQVQoz5VT2XKjQAzkPg2Ew4AZTjtVcarifcg+Jv//W52WIK593QfVyELTanWPrWVZ8fn5Fx8fD9zf7pinGe/3d6ysW5b1/9GdWyzjhL5tcduuuHQ98w7TZUASRogZSRQjjRM9f0PqnuPCsWy4tvMMK3A9tE2LnkBRED4nvQQR6pcSLQfOHKhhxmduODDyAwXxieETXMLKkxR/uOI8LzCDQczpAlglJ6xcv23OuJK5gKzsEUkWxkDAjbI0VQ2b/QosgLEfYukNjDEKOJKF7/koOGhhPvLixPpyMNzmVQdJTX5n7PMIJpsGAugS/T6ueDweakae5TvDuFApmrrG6+0VonVTNypBTVZyZqdMex0C2tRSGTosLJz2/fWN2/WmH6SpTDMaY9DVXJmrtlWDVAyhGWkYI/IC+LZLVt7Bbg9L9o+iBGdqJcaEhzFNelLdShozDqPqN5mJudFcGEuvK6wOlrqyOBT+4+7T5XQ3RS6KXqa/4CLP6dBukwEcVOYFmSe6rgKGYj0T+5iy67G7fF03DAQSppPZWYqzYpx8E7flD1CXlUqlK1fy1riuPNzfRypnwEFn6iYM5UJBszoxqaw1cmpcnHKty0Ye9ZS7P4nBA+51KDOWAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;5&quot;
        title=&quot;5&quot;
        src=&quot;/daily-study/static/f9b9cc4a74d8d60a4dab6965da0bff75/fcda8/5.png&quot;
        srcset=&quot;/daily-study/static/f9b9cc4a74d8d60a4dab6965da0bff75/12f09/5.png 148w,
/daily-study/static/f9b9cc4a74d8d60a4dab6965da0bff75/e4a3f/5.png 295w,
/daily-study/static/f9b9cc4a74d8d60a4dab6965da0bff75/fcda8/5.png 590w,
/daily-study/static/f9b9cc4a74d8d60a4dab6965da0bff75/efc66/5.png 885w,
/daily-study/static/f9b9cc4a74d8d60a4dab6965da0bff75/c83ae/5.png 1180w,
/daily-study/static/f9b9cc4a74d8d60a4dab6965da0bff75/e92cd/5.png 1778w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;권한 할당 원칙&lt;/h3&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/daily-study/static/c238433dcdc305e1fe82884eaafea6cf/71c1d/6.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 62.16216216216216%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAACEElEQVQoz2VTS1MaQRCefbALu2Atr/BeQGARk62AWB4CYtQCUXJMVaxK5ZC7j1ilZU6e/BnJKbfkR37p6WEV5dA7Pd9+83VPd4/otDuYTWcYj8Y4/HiI3eEuDiYHvOayOWz3tvnf/niC8F2IQX+AZqNJ+32MPozQf9/HcGeIul+HEAIik86g3WqjUW8g6ASoVqool8ooFopIxBPI5/KolCu8LxXL6AZdWktshTcFxjebm8xhweVnzUzDWMNcx1nDrFiMuCb7mtAg5EfX9CeTe0lIug77TFpiNz+usZFMLQMqkdl0irP5KfuGbijBKJoSUNm58fiKoMLubm+RcpPPh2mdn8zx6WyxiimhiKCMsk04z9dgso7ri8una0f846MjzGcnLwVr1Ro67QAxXVCxDUxyOh4sC37NJwGXyV5qA39//cbgbQiXspTlkfj9xRV+kiUJW5ZBcMtl93QZxRQoWgbGJOh5HizL5oMOdfzx8QGdVgtx8qPMz798xrev5zwRHGS1hiLyNUr9VUd108Ti8juyxQJilImmKW44nWBvMYUpGxoJrhofJrJj21AToLCUq+HfnxBb7TwMw6Z6qUD3N1XcXQXkO8R9NYeRYMKO0yvJrjRKI0Eb8+M0Mp68rs7TIISBvR0PgzBNfkxh8pC0aAalgHwFva0e7GX9NG6cT7XuoVarvxh03w/oKXaJazH2H/bbJQQwYe5CAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;6&quot;
        title=&quot;6&quot;
        src=&quot;/daily-study/static/c238433dcdc305e1fe82884eaafea6cf/fcda8/6.png&quot;
        srcset=&quot;/daily-study/static/c238433dcdc305e1fe82884eaafea6cf/12f09/6.png 148w,
/daily-study/static/c238433dcdc305e1fe82884eaafea6cf/e4a3f/6.png 295w,
/daily-study/static/c238433dcdc305e1fe82884eaafea6cf/fcda8/6.png 590w,
/daily-study/static/c238433dcdc305e1fe82884eaafea6cf/efc66/6.png 885w,
/daily-study/static/c238433dcdc305e1fe82884eaafea6cf/c83ae/6.png 1180w,
/daily-study/static/c238433dcdc305e1fe82884eaafea6cf/71c1d/6.png 1536w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/daily-study/static/033ac85259803d8a7bc7a355d76db49a/bf8c1/7.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 54.72972972972974%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAACIUlEQVQoz1VTzU5TQRidO3P/em+92NZyaVpuf6UktpQSwV6lpVK4BGhAY0wUjEoT2Lhgo1sT1ybGRNP4AkYfwLj3CXTlwq07X+I4My1Tupicb/6+850535BgPsD+Xh9RtIPeZg8bnQ20brVQq9VQLBRxt7uJMLyNTruD9TvrIISAahQa0WQs8GKIOTENE67jIu7G5XBiDmzLlij2xDB0Q84dx5lcHCeTyAkoVSREHaCaxhPouLxWKZWQzWSm1pYbDSQTSVXthICjyHohwdR12KYJxtl0xuShe4cHCFstGYtqBZ6dnqJSLqtEfreK5Zd7IDadrlAjOhgTl0TpI+bdaB83m2tjaYbEp09OUMiXZMw8F+c/PuDdv29oDrZBxNukUmn41+IIfIZ8xkI2zZCd1ZGIEdx/3EE3qsl4fs7EVY7PXxxiZTWARwmaWxUMfw3x+udHHH96BWKZFma8GW6MDddm8FwTMZPCsUeSewddtKMQcctQaw9PHqCxegMWj3ONAMPfX/H2zxc8en8+LZlRnb+TJSVrY8n93T7CtVDtCxw8G+B6eUHdO/v8BsO/31Hs1qdNYdrIDOE2o6NqdqJtrDSbMhbtI/D46AhBEKiEdi4Bv60IJhUK6XO+r1pBZzpy2Sxm0+mxUSOni/kCUsnk2CiuxuDklBdhckLR1N4VT7KnkilUF6qyUSUzb/Cl+hLqtbpqGfHmi9VF5IP8pZ8yafL/re4YPgXo5pkAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;7&quot;
        title=&quot;7&quot;
        src=&quot;/daily-study/static/033ac85259803d8a7bc7a355d76db49a/fcda8/7.png&quot;
        srcset=&quot;/daily-study/static/033ac85259803d8a7bc7a355d76db49a/12f09/7.png 148w,
/daily-study/static/033ac85259803d8a7bc7a355d76db49a/e4a3f/7.png 295w,
/daily-study/static/033ac85259803d8a7bc7a355d76db49a/fcda8/7.png 590w,
/daily-study/static/033ac85259803d8a7bc7a355d76db49a/efc66/7.png 885w,
/daily-study/static/033ac85259803d8a7bc7a355d76db49a/c83ae/7.png 1180w,
/daily-study/static/033ac85259803d8a7bc7a355d76db49a/bf8c1/7.png 1722w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;항상 Deny가 제일 강하다! Deny는 명시적으로 작성될 수 있고, 묵시적으로 적용될 수 있다.&lt;/p&gt;
&lt;p&gt;기본적으로, 모든 Resource는 묵시적으로 Deny이므로 해당 Resource에 대한 사용이 명시적으로 Allow 되어 있지 않다면, 그냥 Deny된 상태라 보면 된다.&lt;/p&gt;
&lt;p&gt;IAM은 Policies Lookup 할때, API에 해당하는 모든 Policies를 확인한다.&lt;/p&gt;
&lt;p&gt;만약, Permission Boundary에 대한 정의가 존재하는데, 특정 Resource에 대한 내용이 없다면 묵시적 Deny라고 보면 된다.&lt;/p&gt;
&lt;p&gt;즉, 모든 Permission에서 사용하고자 하는 Resource에 대해 명시적인 Allow가 존재하면서 Deny가 없어야만 사용이 가능한 것이다.&lt;/p&gt;
&lt;p&gt;다음 예시처럼, Permission Boundary와 Permission Policy가 모두 존재하는 경우에, 한쪽만 사용에 대한 Allow가 있다면 Deny가 없더라도 묵시적 Deny에 의해 사용이 불허된다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/daily-study/static/71aabbe4dbd433843eaf7a6f51907774/2d912/8.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 53.37837837837838%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABrElEQVQoz4VS227TQBTc+65jO3F8jUPibQMphL60CFUgkQoJ/v+XhrPrOErTVjyM9uKzc2bGhx1/HfF8fMbTj5/4/ecvvn1/AmPsXXDGCdM6gl2c2ePDI+4PX3FblrhblvBZhjxJsNt9RN+tUJUV6qpG27Rw1p2I+RtNToRd22E5X6CjD1uCJ6xmCwybAW3bwg8+4sbfwJqR0BmOxDACh1EvyZnkEporVLpA40iNLVGzHPLKqpKSCC3SxMKvc3waFvB9hmVuIIWClgpGa7DQeb+/Q1VXKKsSaZaCSxHlCy4QGwqBsihw+HLAhpQXRYUsK2BMEu2Lk93EWjDBqFjPkcsZLNMwhOt8NKkTPDxQWDczsiqROkF3U824BgcsbJYyhzc91qaJ6HUdYxiLRSSUYlTx2WfYDxl2mxT7bYqusucf4oLCsFnIDK0q0RG2ZhX3lhsE9ZNCRTGEBv3c4AORrBuHTeswn+mzk0hotY12NVNQjILnGo7IDK2SzhMhJ8spkTZCwsXcXs+nnRT+b5ADYQhcKxXzEhdzdznYUeH1YL6FQGiUOj9k79Q5Y/AP6q/xRO80PAkAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;8&quot;
        title=&quot;8&quot;
        src=&quot;/daily-study/static/71aabbe4dbd433843eaf7a6f51907774/fcda8/8.png&quot;
        srcset=&quot;/daily-study/static/71aabbe4dbd433843eaf7a6f51907774/12f09/8.png 148w,
/daily-study/static/71aabbe4dbd433843eaf7a6f51907774/e4a3f/8.png 295w,
/daily-study/static/71aabbe4dbd433843eaf7a6f51907774/fcda8/8.png 590w,
/daily-study/static/71aabbe4dbd433843eaf7a6f51907774/efc66/8.png 885w,
/daily-study/static/71aabbe4dbd433843eaf7a6f51907774/c83ae/8.png 1180w,
/daily-study/static/71aabbe4dbd433843eaf7a6f51907774/2d912/8.png 1772w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/daily-study/static/6b6e1f76692e22d5ca7a73219cd9fe21/6c86f/9.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 56.08108108108109%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAACAElEQVQoz21TTW8TMRD12hvvbjYfNMlWS5J+5JOWpkmjtJBwgAZFUako5UDVUsoWGkQPFaee4AwXkIBe4T9w5MpP4T8gJI4P21svG4nDaJ5HM2/meWxiMhMzV2aQclNIp9LKZzNZyLhBDBBClGn8vxgTnhlUn8lUAjdNxGP1Wg3lYikspEz51VYL+VxOYSqI/uULQkmiTZLZnItCKiYMi3cf7ODWYKBwwkwoP5lM0KjXI6KdXB4XKy1kwnO8CwNjibATCWPDuyN0u90pwmdHARrVmsI5Eft5dgZ8/IQ3ayLPTbpCVhPpJMWCzzHvWyh5DOVZjhQneP3qBI/u76pinuDh1Md7qFyrKnzb9/Hr/Qf8OT/H9+AYZHlpGTc2bmKuXIRrM2RcDseiAod3+eLJAYL9AzhOMrrDh8EeOhtrCq8XPPz+fAG8fYdvR09BpAy5UWoIudQUU1hKsnEpeTQao9/vKyzzpD8JnmOp0Qxjwn68PAW+fMV+vTG9Zb0MahjRNFvjMdZ7vSnJh48PUVlcjOp6loNT/yocvRRt2XQGs54XLUn6UrEIr1CIcuSUkix6NkKNfTmpJeuS4m7kg5YT5cX6m0KKJnRsB512B+3VtsIyLpcocxbm5mOPW5toWq1UsXK9Bduyown0D5A/aLg5xPa9bQz6A4U37wxVbvznxO0vD5AWxDG8uAsAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;9&quot;
        title=&quot;9&quot;
        src=&quot;/daily-study/static/6b6e1f76692e22d5ca7a73219cd9fe21/fcda8/9.png&quot;
        srcset=&quot;/daily-study/static/6b6e1f76692e22d5ca7a73219cd9fe21/12f09/9.png 148w,
/daily-study/static/6b6e1f76692e22d5ca7a73219cd9fe21/e4a3f/9.png 295w,
/daily-study/static/6b6e1f76692e22d5ca7a73219cd9fe21/fcda8/9.png 590w,
/daily-study/static/6b6e1f76692e22d5ca7a73219cd9fe21/efc66/9.png 885w,
/daily-study/static/6b6e1f76692e22d5ca7a73219cd9fe21/c83ae/9.png 1180w,
/daily-study/static/6b6e1f76692e22d5ca7a73219cd9fe21/6c86f/9.png 1720w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;계정에 따른 권한 획득 조건 (동일 계정)&lt;/h3&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/daily-study/static/8a5cbb0d4c9f4db7897bd4f81534a824/27f8b/10.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 54.05405405405405%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAACX0lEQVQoz11TTW8SURR982aY4WOgzAcDMzAMFsQSBjpCKxawKWlMjdbQRTd+pFQXxqhNbaIxmDR1YVyaaIyJG12ZuDBx4caN8Ue48Te49QccHw9KShc37+R9nHvvuecRK2Wht9ZDsBig0+6g2+mi2WiislBBcb6IUrHE95aXlvk5IQRUoBCIMI3R3vFKFFlB3s3DsZ3pmrYspEwTWjLJQoPnedA1HV7eGz86FSMyKrIkAiedPZREia9BPUAyoXGcdXIozZc4DitRrFxoQxRDkOUwKJVmE/CyWQuyRKFGRFiGyg/uPdqFXz/L8eUrq9javsqxY+t48nwfnYsNVCtFaKoCOS7AuxFAyiZGhGNmNSIgZ0kouir0KMGtB5totDyoAiPsN9G/uQqVElTKBvaOBsinZdgGhR4m6B9ew5u/n7H1fg9EpKwqNhjCRRUQicR4gp2dXRQKRY6rfh3nG0scK6zl9kp30uJ4EAffXuPZ748Y/nwHMtLMr/pMWMovRCeEtwcDuHwIAnxGWPMXIYfCiIRjaHcvTcjYG1b18PtbvPrzBUe/PoCYholeb51pF4NrUZQLcZgqweDhJpotF1aCwHNknMkqsHWCWjWFgxcDZDQ2rBSFEWHdvNzG138/cPfTIcjIKr5fg51Jg7LKkokor/DO/QHKlXHLsiTwGOlt2yk8Hu6jkM/BzdnIOzYMV8fa0+vQFuzxlI+tIjILmIbBcbvVZjh1QquxXnE1gY31DX5XZO8kUWb2CcE5F8Wcqcz6MDmXRBAETCsZmqYhFotNjSuc/A2njc0MrWVUyGEJ/wF7vyQQqg2qKAAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;10&quot;
        title=&quot;10&quot;
        src=&quot;/daily-study/static/8a5cbb0d4c9f4db7897bd4f81534a824/fcda8/10.png&quot;
        srcset=&quot;/daily-study/static/8a5cbb0d4c9f4db7897bd4f81534a824/12f09/10.png 148w,
/daily-study/static/8a5cbb0d4c9f4db7897bd4f81534a824/e4a3f/10.png 295w,
/daily-study/static/8a5cbb0d4c9f4db7897bd4f81534a824/fcda8/10.png 590w,
/daily-study/static/8a5cbb0d4c9f4db7897bd4f81534a824/efc66/10.png 885w,
/daily-study/static/8a5cbb0d4c9f4db7897bd4f81534a824/c83ae/10.png 1180w,
/daily-study/static/8a5cbb0d4c9f4db7897bd4f81534a824/27f8b/10.png 1730w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;위에는 요청을 보내는 쪽에서 허용하는 방법이고, 아래쪽은 요청을 받는 쪽에서 허용하는 방법이다.&lt;/p&gt;
&lt;h3&gt;계정에 따른 권한 획득 조건 (다른 계정)&lt;/h3&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/daily-study/static/4894dc5c1a1485aab193caf197ec9f36/e7aec/11.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 56.75675675675676%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAACsUlEQVQoz1WTyU4UYRCAu3umZ+lZepaGWRlsZEZoFGRUQMGFqBdjYqIHITggDBkZEFwgRIxGo7gmLvGgJnBwCx70pEcPvoLxok9g4lN81gwY9FBd9VdXfV31V7WSyWQZPDRIz54eent6ObD/ILuKuyh2d5FJJ2lvK8h5JwP9e+nc7qAoioiKomrrWs5qXa/bis/rI51Kk0wkSSVTWHGLaCROLG4TDKYJhtKYkRyJZCummZMkH4bAQpIcFtE34JqmbYDrX9wUt1bTEdo6F1GNSYLWFC3tC+Ibwdl5FcUcZkDibts2l02TLf/k1oG1h6au0z26jt/rkpcNTM+9xrBmaXGWKJVXxDfG3KU1jHSZPkn+MH6Wu9s7SIkd6LPJTwyguJT/K1RVN7q7djcWlXNv8ERmyeWXGD6zKr5RqtU1vI1ldteAo+Pc2tpGTiCVr095/PszzmmB6m6dxsYkhlclbXnINLiJRywm5pfJtpTZ0TfN0NRNjPAQk4v3yBSGOaYqrFZPcK2rieN7m3n4/QW3vr1k6Pk8iuE36NzRhcetEg3pxE0XAb9F6eID4tkKheIspybvoPpGODv/iJhd4rBUuFI5yZKT40hXlic/3vHk5xpDzy6i2Fts+vf1Y/gD0pYm9+iqt3yu+hZvdI7mwlVGRtdbnpl5jy8xyR4BfhydYDnvkBF7+tNjVn59ofVoESUre5jPF4iYERmMIkC1DixPreKLzQhwkdOl5+I7Q6X6Cl9ynF6Je18qsew4JMUOdaRoP1X8O4vNoYSCIdlDE9WVoCm/KEM5j5m4QMpewB2eptW5hhYdY1Bi78vaLEWjNIvtj3mxO8Lote5qi+33+etr02A11v8MzWXJ/lUIxCsU+67jdF+hoek83T03iDWNccClc7NtGwuZDLlaMR43gbC3XtQf6i9LMpQ1eAoAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;11&quot;
        title=&quot;11&quot;
        src=&quot;/daily-study/static/4894dc5c1a1485aab193caf197ec9f36/fcda8/11.png&quot;
        srcset=&quot;/daily-study/static/4894dc5c1a1485aab193caf197ec9f36/12f09/11.png 148w,
/daily-study/static/4894dc5c1a1485aab193caf197ec9f36/e4a3f/11.png 295w,
/daily-study/static/4894dc5c1a1485aab193caf197ec9f36/fcda8/11.png 590w,
/daily-study/static/4894dc5c1a1485aab193caf197ec9f36/efc66/11.png 885w,
/daily-study/static/4894dc5c1a1485aab193caf197ec9f36/c83ae/11.png 1180w,
/daily-study/static/4894dc5c1a1485aab193caf197ec9f36/e7aec/11.png 1726w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;서로 다른 계정의 Resource를 사용하기 위해서는 길이 하나 존재하고, 모든 요청에서 Allow가 되어 있어야 한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Elasticsearch 기본 정리]]></title><description><![CDATA[프로젝트를 진행하며 Elasticsearch를 사용해야 할 일이 생겼습니다. 이에 따라 기본적인 사용 방법을 파악하기 위해 공식 문서의 get started 내용을 정리하였습니다. Elastic Stack 과거 ELK…]]></description><link>https://sukjae.github.io/daily-study/daily/2019-11-26/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/daily/2019-11-26/</guid><pubDate>Tue, 26 Nov 2019 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;프로젝트를 진행하며 Elasticsearch를 사용해야 할 일이 생겼습니다. 이에 따라 기본적인 사용 방법을 파악하기 위해 공식 문서의 get started 내용을 정리하였습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Elastic Stack&lt;/h3&gt;
&lt;p&gt;과거 ELK 스택으로 불리던 제품 묶음이 이제는 Elastic Stack이라는 제품군으로 통일&lt;/p&gt;
&lt;h3&gt;DB등과 어떻게 연결해야 하는지&lt;/h3&gt;
&lt;p&gt;다양한 방법들이 존재한다. 그중 많이 쓰이는 방법은 Logstash를 사용하는 방법이다.&lt;/p&gt;
&lt;p&gt;input source(DB)와 한개 이상의 output sinks(Elastic Search) 중간에 연결고리로 작용하는 pipeline을 생성한다.&lt;/p&gt;
&lt;p&gt;Logstash는 데이터를 연결하기 위한 다양한 source 와 sink의 종류에 대응하여 라이브러리를 제공한다.&lt;/p&gt;
&lt;p&gt;mongodb의 경우에는 output(sink)에 대한 라이브러리가 제공되지만, input으로서는 제공되지 않는다&lt;/p&gt;
&lt;p&gt;input 리스트&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/logstash/current/input-plugins.html&quot;&gt;https://www.elastic.co/guide/en/logstash/current/input-plugins.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;output 리스트&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/logstash/current/output-plugins.html&quot;&gt;https://www.elastic.co/guide/en/logstash/current/output-plugins.html&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Elasticsearch REST API의 3가지 query방법&lt;/h3&gt;
&lt;p&gt;출처: &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/search-analyze.html&quot;&gt;https://www.elastic.co/guide/en/elasticsearch/reference/current/search-analyze.html&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;structured queries&lt;/li&gt;
&lt;li&gt;full text queries&lt;/li&gt;
&lt;li&gt;complex queries&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;structured queries&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SQL에서 구성 하는것과 유사한 방법&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;you could search the &lt;code class=&quot;language-text&quot;&gt;gender&lt;/code&gt; and &lt;code class=&quot;language-text&quot;&gt;age&lt;/code&gt; fields in your &lt;code class=&quot;language-text&quot;&gt;employee index&lt;/code&gt; and sort the matches by the &lt;code class=&quot;language-text&quot;&gt;hire_date&lt;/code&gt; field&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Full-text queries&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;find all documents that match the query string and return them sorted by relevance&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;relevance는 how good a match they are for your search terms.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;complex queries&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;위 &lt;strong&gt;structured queries&lt;/strong&gt;와 &lt;strong&gt;full text queries&lt;/strong&gt; 를 합친 방식&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;추가적으로,&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;또한 다음과 같은 기능을 제공한다&lt;/p&gt;
&lt;p&gt;phrase searches, similarity searches, and prefix searches, and get autocomplete suggestions&lt;/p&gt;
&lt;p&gt;또한, 지리적 query와 대수적인 query 모두를 고성능으로 제공한다.&lt;/p&gt;
&lt;p&gt;위 모든 query는 Elasticsearch의 포괄적인 JSON스타일의 쿼리(Query DSL)을 통해 사용할 수 있다.&lt;/p&gt;
&lt;p&gt;이 뿐만 아니라, SQL형태의 query도 적용 가능하다.&lt;/p&gt;
&lt;h1&gt;docker &amp;#x26; Elasticsearch&lt;/h1&gt;
&lt;h2&gt;설치&lt;/h2&gt;
&lt;p&gt;출처: &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html&quot;&gt;https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;두가지 방법이 존재한다.&lt;/p&gt;
&lt;p&gt;나의 경우에는 간단한 테스트를 위한 환경 구성이므로 single node도 무방해 보인다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;# docker image pull
docker pull docker.elastic.co/elasticsearch/elasticsearch:7.4.2
# docker run
docker run -p 9200:9200 -p 9300:9300 -e &amp;quot;discovery.type=single-node&amp;quot; docker.elastic.co/elasticsearch/elasticsearch:7.4.2&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이렇게 올라간 엘라스틱서치를 확인하기 위해 다음과 같은 명령어 타입&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;╰─ curl -X GET &amp;quot;localhost:9200/_cat/health?v&amp;quot;

# 결과
epoch      timestamp cluster        status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent
1574745447 05:17:27  docker-cluster green           1         1      0   0    0    0        0             0                  -                100.0%&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 예시에서 보이듯이, elasticsearch는 restful api로 명령어를 수행 하는듯 하다.&lt;/p&gt;
&lt;h2&gt;사용법&lt;/h2&gt;
&lt;p&gt;Rest api로 설정이 가능하니, 데이터 주입이 가능함도 당연하다.&lt;/p&gt;
&lt;h3&gt;등록&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;curl -X PUT &amp;quot;localhost:9200/customer/_doc/1?pretty&amp;quot; -H \
&amp;#39;Content-Type: application/json&amp;#39; -d&amp;#39;
{
  &amp;quot;name&amp;quot;: &amp;quot;John Doe&amp;quot;
}
&amp;#39;

# 결과
{
  &amp;quot;_index&amp;quot; : &amp;quot;customer&amp;quot;,
  &amp;quot;_type&amp;quot; : &amp;quot;_doc&amp;quot;,
  &amp;quot;_id&amp;quot; : &amp;quot;1&amp;quot;,
  &amp;quot;_version&amp;quot; : 1,
  &amp;quot;result&amp;quot; : &amp;quot;created&amp;quot;,
  &amp;quot;_shards&amp;quot; : {
    &amp;quot;total&amp;quot; : 2,
    &amp;quot;successful&amp;quot; : 1,
    &amp;quot;failed&amp;quot; : 0
  },
  &amp;quot;_seq_no&amp;quot; : 0,
  &amp;quot;_primary_term&amp;quot; : 1
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;조회&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;curl -X GET &amp;quot;localhost:9200/customer/_doc/1?pretty&amp;quot;

# 결과
{
  &amp;quot;_index&amp;quot; : &amp;quot;customer&amp;quot;,
  &amp;quot;_type&amp;quot; : &amp;quot;_doc&amp;quot;,
  &amp;quot;_id&amp;quot; : &amp;quot;1&amp;quot;,
  &amp;quot;_version&amp;quot; : 1,
  &amp;quot;_seq_no&amp;quot; : 0,
  &amp;quot;_primary_term&amp;quot; : 1,
  &amp;quot;found&amp;quot; : true,
  &amp;quot;_source&amp;quot; : {
    &amp;quot;name&amp;quot; : &amp;quot;John Doe&amp;quot;
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;벌크 주입&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;curl -H &amp;quot;Content-Type: application/json&amp;quot; \
-XPOST &amp;quot;localhost:9200/bank/_bulk?pretty&amp;amp;refresh&amp;quot; \
--data-binary &amp;quot;@accounts.json&amp;quot;

# 결과

...
{
      &amp;quot;index&amp;quot; : {
        &amp;quot;_index&amp;quot; : &amp;quot;bank&amp;quot;,
        &amp;quot;_type&amp;quot; : &amp;quot;_doc&amp;quot;,
        &amp;quot;_id&amp;quot; : &amp;quot;717&amp;quot;,
        &amp;quot;_version&amp;quot; : 1,
        &amp;quot;result&amp;quot; : &amp;quot;created&amp;quot;,
        &amp;quot;forced_refresh&amp;quot; : true,
        &amp;quot;_shards&amp;quot; : {
          &amp;quot;total&amp;quot; : 2,
          &amp;quot;successful&amp;quot; : 1,
          &amp;quot;failed&amp;quot; : 0
        },
        &amp;quot;_seq_no&amp;quot; : 943,
        &amp;quot;_primary_term&amp;quot; : 1,
        &amp;quot;status&amp;quot; : 201
      }
    },
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;신기하게도, 상대경로나 절대경로가 아닌 &lt;code class=&quot;language-text&quot;&gt;@&lt;/code&gt; 를 파일 앞에 두어야 한다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;./accounts.json&lt;/code&gt; 으로 해보니 에러가 뜬다.&lt;/p&gt;
&lt;h3&gt;index들 조회&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;curl &amp;quot;localhost:9200/_cat/indices?v&amp;quot;

# 결과
health status index    uuid                   pri rep docs.count docs.deleted store.size pri.store.size
yellow open   bank     Vi8pnBZRQHaZY5J2NrdM0g   1   1       1000            0    414.2kb        414.2kb
yellow open   customer aZHN_XWAQjC0j_W1yiYLRg   1   1          1            0      3.5kb          3.5kb&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;정상적으로 1000개의 bank정보가 주입 되었음을 확인할 수 있다.&lt;/p&gt;
&lt;h3&gt;검색&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;curl -X GET &amp;quot;localhost:9200/bank/_search?pretty&amp;quot; \
-H &amp;#39;Content-Type: application/json&amp;#39; -d&amp;#39;
{
  &amp;quot;query&amp;quot;: { &amp;quot;match_all&amp;quot;: {} },
  &amp;quot;sort&amp;quot;: [
    { &amp;quot;account_number&amp;quot;: &amp;quot;asc&amp;quot; }
  ]
}
&amp;#39;

# 결과
{
  &amp;quot;took&amp;quot; : 384,
  &amp;quot;timed_out&amp;quot; : false,
  &amp;quot;_shards&amp;quot; : {
    &amp;quot;total&amp;quot; : 1,
    &amp;quot;successful&amp;quot; : 1,
    &amp;quot;skipped&amp;quot; : 0,
    &amp;quot;failed&amp;quot; : 0
  },
  &amp;quot;hits&amp;quot; : {
    &amp;quot;total&amp;quot; : {
      &amp;quot;value&amp;quot; : 1000,
      &amp;quot;relation&amp;quot; : &amp;quot;eq&amp;quot;
    },
    &amp;quot;max_score&amp;quot; : null,
    &amp;quot;hits&amp;quot; : [
      {
        &amp;quot;_index&amp;quot; : &amp;quot;bank&amp;quot;,
        &amp;quot;_type&amp;quot; : &amp;quot;_doc&amp;quot;,
        &amp;quot;_id&amp;quot; : &amp;quot;0&amp;quot;,
        &amp;quot;_score&amp;quot; : null,
        &amp;quot;_source&amp;quot; : {
          &amp;quot;account_number&amp;quot; : 0,
          &amp;quot;balance&amp;quot; : 16623,
          &amp;quot;firstname&amp;quot; : &amp;quot;Bradshaw&amp;quot;,
          &amp;quot;lastname&amp;quot; : &amp;quot;Mckenzie&amp;quot;,
          &amp;quot;age&amp;quot; : 29,
          &amp;quot;gender&amp;quot; : &amp;quot;F&amp;quot;,
          &amp;quot;address&amp;quot; : &amp;quot;244 Columbus Place&amp;quot;,
          &amp;quot;employer&amp;quot; : &amp;quot;Euron&amp;quot;,
          &amp;quot;email&amp;quot; : &amp;quot;bradshawmckenzie@euron.com&amp;quot;,
          &amp;quot;city&amp;quot; : &amp;quot;Hobucken&amp;quot;,
          &amp;quot;state&amp;quot; : &amp;quot;CO&amp;quot;
        },
        &amp;quot;sort&amp;quot; : [
          0
        ]
      },
... 9 more&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;기본적으로, hits의 배열(검색에대한 결과)은 검색 조건에 맞는 첫 10개의 documents를 포한한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;이 응답 JSON에는 결과값과 다음과 같은 정보를 포함하고 있다.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;took : query를 위해 소요된 시간. milliseconds&lt;/li&gt;
&lt;li&gt;timed_out: 검색 요청이 시간 초과가 되었는지 여부 확인&lt;/li&gt;
&lt;li&gt;_shards: 얼마나 많은 수의 shard가 검색되었는지, 그중 몇개의 shard가 성공/실패/건너띄었는지 의 정보&lt;/li&gt;
&lt;li&gt;max_score: 유사한 document중 가장 높은 점수&lt;/li&gt;
&lt;li&gt;hits.total.value: 얼마나 많은 수의 document가 조건과 부합하였는지&lt;/li&gt;
&lt;li&gt;hits.sort: 정렬 포지션 (관련 점수로 정렬되지 않았을 경우)&lt;/li&gt;
&lt;li&gt;hits._score: document의 유사 점수 (match_all를 사용시에 사용 불가)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;다음과 같이 sort를 제한할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;curl -X GET &amp;quot;localhost:9200/bank/_search?pretty&amp;quot; -H &amp;#39;Content-Type: application/json&amp;#39; -d&amp;#39;
{
  &amp;quot;query&amp;quot;: { &amp;quot;match_all&amp;quot;: {} },
  &amp;quot;sort&amp;quot;: [
    { &amp;quot;account_number&amp;quot;: &amp;quot;asc&amp;quot; }
  ],
  &amp;quot;from&amp;quot;: 10,
  &amp;quot;size&amp;quot;: 10
}
&amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;또한, 다음과 같이 특정 문구를 검색할 수 있다.&lt;/p&gt;
&lt;p&gt;이 경우에, elasticsearch의 점수 알고리즘에 의해서 score를 측정하고, 가장 높은 점수 순으로 정렬된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;curl -X GET &amp;quot;localhost:9200/bank/_search?pretty&amp;quot; \
-H &amp;#39;Content-Type: application/json&amp;#39; -d&amp;#39;
{
  &amp;quot;query&amp;quot;: { &amp;quot;match&amp;quot;: { &amp;quot;address&amp;quot;: &amp;quot;mill lane&amp;quot; } }
}
&amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 경우에는, mill와 lane을 포함하는 document를 가져오고, 점수화 하여 보여준다.&lt;/p&gt;
&lt;p&gt;반면, &lt;code class=&quot;language-text&quot;&gt;mill lane&lt;/code&gt; 을 모두 포함하고 싶은 경우에는 다음과 같이 진행한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;curl -X GET &amp;quot;localhost:9200/bank/_search?pretty&amp;quot; \
-H &amp;#39;Content-Type: application/json&amp;#39; -d&amp;#39;
{
  &amp;quot;query&amp;quot;: { &amp;quot;match_phrase&amp;quot;: { &amp;quot;address&amp;quot;: &amp;quot;mill lane&amp;quot; } }
}
&amp;#39;

# 결과
&amp;#39;
...
    &amp;quot;max_score&amp;quot; : 9.507477,
    &amp;quot;hits&amp;quot; : [
      {
        &amp;quot;_index&amp;quot; : &amp;quot;bank&amp;quot;,
        &amp;quot;_type&amp;quot; : &amp;quot;_doc&amp;quot;,
        &amp;quot;_id&amp;quot; : &amp;quot;136&amp;quot;,
        &amp;quot;_score&amp;quot; : 9.507477,
        &amp;quot;_source&amp;quot; : {
          &amp;quot;account_number&amp;quot; : 136,
          &amp;quot;balance&amp;quot; : 45801,
          &amp;quot;firstname&amp;quot; : &amp;quot;Winnie&amp;quot;,
          &amp;quot;lastname&amp;quot; : &amp;quot;Holland&amp;quot;,
          &amp;quot;age&amp;quot; : 38,
          &amp;quot;gender&amp;quot; : &amp;quot;M&amp;quot;,
          &amp;quot;address&amp;quot; : &amp;quot;198 Mill Lane&amp;quot;,
          &amp;quot;employer&amp;quot; : &amp;quot;Neteria&amp;quot;,
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이 경우, 정확히 맞는 단어를 포함해야 하는 경우로 보인다, 다음과 같은 경우는 아무것도 나오지 않는다&lt;/p&gt;
&lt;p&gt;완벽하게 단어가 매칭 되어야 한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;curl -X GET &amp;quot;localhost:9200/bank/_search?pretty&amp;quot; \
-H &amp;#39;Content-Type: application/json&amp;#39; -d&amp;#39;
{
  &amp;quot;query&amp;quot;: { &amp;quot;match_phrase&amp;quot;: { &amp;quot;address&amp;quot;: &amp;quot;mi lane&amp;quot; } }
}

# 결과
...
&amp;quot;hits&amp;quot; : {
    &amp;quot;total&amp;quot; : {
      &amp;quot;value&amp;quot; : 0,
      &amp;quot;relation&amp;quot; : &amp;quot;eq&amp;quot;
    },
    &amp;quot;max_score&amp;quot; : null,
    &amp;quot;hits&amp;quot; : [ ]
  }...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;보다 복잡한 쿼리를 진행하기 위해서는 &lt;code class=&quot;language-text&quot;&gt;bool&lt;/code&gt; 쿼리를 사용해야 한다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;bool&lt;/code&gt; 을 사용하여 복수의 쿼리 조건을 합칠 수 있다.&lt;/p&gt;
&lt;p&gt;이를 활용하여 Boolean query에서는 다음 세가지 조건을 구사할 수 있다. (==query clause)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;required (&lt;code class=&quot;language-text&quot;&gt;must&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;desirable (&lt;code class=&quot;language-text&quot;&gt;should&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;undesirable (&lt;code class=&quot;language-text&quot;&gt;must_not&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위 query clause중 &lt;code class=&quot;language-text&quot;&gt;must&lt;/code&gt; 와 &lt;code class=&quot;language-text&quot;&gt;should&lt;/code&gt; 는 얼마나 잘 맞는지가 document의 relevance score에 영향을 미친다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;must_not&lt;/code&gt; 은 &lt;code class=&quot;language-text&quot;&gt;filter&lt;/code&gt; 처럼 다뤄진다. 이 부분은 score에 영향을 미치지 않는다.&lt;/p&gt;
&lt;p&gt;예시)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;curl -X GET &amp;quot;localhost:9200/bank/_search?pretty&amp;quot; -H &amp;#39;Content-Type: application/json&amp;#39; -d&amp;#39;
{
  &amp;quot;query&amp;quot;: {
    &amp;quot;bool&amp;quot;: {
      &amp;quot;must&amp;quot;: [
        { &amp;quot;match&amp;quot;: { &amp;quot;age&amp;quot;: &amp;quot;40&amp;quot; } }
      ],
      &amp;quot;must_not&amp;quot;: [
        { &amp;quot;match&amp;quot;: { &amp;quot;state&amp;quot;: &amp;quot;ID&amp;quot; } }
      ]
    }
  }
}
&amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;must_not&lt;/code&gt; 이외에도, 명시적으로 필터의 속성을 이용 함으로서 포함하거나 불포함 하고자 하는 document를 정해줄 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;curl -X GET &amp;quot;localhost:9200/bank/_search?pretty&amp;quot; -H &amp;#39;Content-Type: application/json&amp;#39; -d&amp;#39;
{
  &amp;quot;query&amp;quot;: {
    &amp;quot;bool&amp;quot;: {
      &amp;quot;must&amp;quot;: { &amp;quot;match_all&amp;quot;: {} },
      &amp;quot;filter&amp;quot;: {
        &amp;quot;range&amp;quot;: {
          &amp;quot;balance&amp;quot;: {
            &amp;quot;gte&amp;quot;: 20000,
            &amp;quot;lte&amp;quot;: 30000
          }
        }
      }
    }
  }
}
&amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;aggregations&lt;/h3&gt;
&lt;p&gt;이 작업은, 공통된 요소로 묶어서 보는 요약본 같은 느낌이다. (집합)&lt;/p&gt;
&lt;p&gt;예를 들어, How many account holders are in Texas?” or “What’s the average balance of accounts in Tennessee? 와 같은 질문을 던져볼 수 있다.&lt;/p&gt;
&lt;p&gt;terms 를 이용하여 다음과 같이 질의할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;curl -X GET &amp;quot;localhost:9200/bank/_search?pretty&amp;quot; -H &amp;#39;Content-Type: application/json&amp;#39; -d&amp;#39;
{
  &amp;quot;size&amp;quot;: 0,
  &amp;quot;aggs&amp;quot;: {
    &amp;quot;group_by_state&amp;quot;: {
      &amp;quot;terms&amp;quot;: {
        &amp;quot;field&amp;quot;: &amp;quot;state.keyword&amp;quot;
      }
    }
  }
}
&amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이 경우에, 우리는 field중에 state의 값에 따라 group을 생성해 준다.&lt;/p&gt;
&lt;p&gt;위의 group&lt;em&gt;by&lt;/em&gt;state는 namepix 정도로 생각하면 될듯 하다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;# 결과
{
  &amp;quot;took&amp;quot; : 100,
  &amp;quot;timed_out&amp;quot; : false,
  &amp;quot;_shards&amp;quot; : {
    &amp;quot;total&amp;quot; : 1,
    &amp;quot;successful&amp;quot; : 1,
    &amp;quot;skipped&amp;quot; : 0,
    &amp;quot;failed&amp;quot; : 0
  },
  &amp;quot;hits&amp;quot; : {
    &amp;quot;total&amp;quot; : {
      &amp;quot;value&amp;quot; : 1000,
      &amp;quot;relation&amp;quot; : &amp;quot;eq&amp;quot;
    },
    &amp;quot;max_score&amp;quot; : null,
    &amp;quot;hits&amp;quot; : [ ]
  },
  &amp;quot;aggregations&amp;quot; : {
    &amp;quot;group_by_state&amp;quot; : {
      &amp;quot;doc_count_error_upper_bound&amp;quot; : 0,
      &amp;quot;sum_other_doc_count&amp;quot; : 743,
      &amp;quot;buckets&amp;quot; : [
        {
          &amp;quot;key&amp;quot; : &amp;quot;TX&amp;quot;,
          &amp;quot;doc_count&amp;quot; : 30
        },
        {
          &amp;quot;key&amp;quot; : &amp;quot;MD&amp;quot;,
          &amp;quot;doc_count&amp;quot; : 28
        },
        {
          &amp;quot;key&amp;quot; : &amp;quot;ID&amp;quot;,
          &amp;quot;doc_count&amp;quot; : 27
        },
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;aggregation을 중첩하여 더 복잡한 요약본을 생성할 수도 있다 .&lt;/p&gt;
&lt;p&gt;이 경우에는 주별 평균 계좌 잔고를 측정할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;curl -X GET &amp;quot;localhost:9200/bank/_search?pretty&amp;quot; \
-H &amp;#39;Content-Type: application/json&amp;#39; -d&amp;#39;
{
  &amp;quot;size&amp;quot;: 0,
  &amp;quot;aggs&amp;quot;: {
    &amp;quot;group_by_state&amp;quot;: {
      &amp;quot;terms&amp;quot;: {
        &amp;quot;field&amp;quot;: &amp;quot;state.keyword&amp;quot;
      },
      &amp;quot;aggs&amp;quot;: {
        &amp;quot;average_balance&amp;quot;: {
          &amp;quot;avg&amp;quot;: {
            &amp;quot;field&amp;quot;: &amp;quot;balance&amp;quot;
          }
        }
      }
    }
  }
}
&amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;또, 다음과 같이 정렬도 가능하다. .&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;curl -X GET &amp;quot;localhost:9200/bank/_search?pretty&amp;quot; -H &amp;#39;Content-Type: application/json&amp;#39; -d&amp;#39;
{
  &amp;quot;size&amp;quot;: 0,
  &amp;quot;aggs&amp;quot;: {
    &amp;quot;group_by_state&amp;quot;: {
      &amp;quot;terms&amp;quot;: {
        &amp;quot;field&amp;quot;: &amp;quot;state.keyword&amp;quot;,
        &amp;quot;order&amp;quot;: {
          &amp;quot;average_balance&amp;quot;: &amp;quot;desc&amp;quot;
        }
      },
      &amp;quot;aggs&amp;quot;: {
        &amp;quot;average_balance&amp;quot;: {
          &amp;quot;avg&amp;quot;: {
            &amp;quot;field&amp;quot;: &amp;quot;balance&amp;quot;
          }
        }
      }
    }
  }
}
&amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[JS Map에서 forEach, key값 뽑기 & Array에서 indexof vs findIndex]]></title><description><![CDATA[JS에서 Map도 기본적으로 forEach가 된다. MDN 문서에 따르면, Map에 기본적으로 forEach가 제공된다. 흔히 사용하는 Array.prototype.forEach…]]></description><link>https://sukjae.github.io/daily-study/daily/2019-11-10/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/daily/2019-11-10/</guid><pubDate>Sun, 10 Nov 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;JS에서 Map도 기본적으로 forEach가 된다.&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach&quot;&gt;MDN 문서&lt;/a&gt;에 따르면, Map에 기본적으로 forEach가 제공된다.&lt;/p&gt;
&lt;p&gt;흔히 사용하는 Array.prototype.forEach()와는 콜백 함수로 전달되는 인자가 살짝 다르지만, 그래도 사용법은 동일하다.&lt;/p&gt;
&lt;h3&gt;Array.prototype.forEach()&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;arr.forEach(callback(currentValue [, index [, array]])[, thisArg]);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;위의 예시에서 있듯이, 콜백의 인자는 순서대로 &lt;code class=&quot;language-text&quot;&gt;currentValue&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;index&lt;/code&gt;, 그리고 &lt;code class=&quot;language-text&quot;&gt;array&lt;/code&gt; 가 주어진다.&lt;/p&gt;
&lt;h3&gt;Map.prototype.forEach()&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;myMap.forEach(callback[, thisArg])&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;유사하게 &lt;code class=&quot;language-text&quot;&gt;Map&lt;/code&gt; 에서의 콜백의 인자는 순서대로 &lt;code class=&quot;language-text&quot;&gt;element value&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;element key&lt;/code&gt;, 그리고 &lt;code class=&quot;language-text&quot;&gt;Map&lt;/code&gt; 이 주어진다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Array&lt;/code&gt; 의 &lt;code class=&quot;language-text&quot;&gt;index&lt;/code&gt; 대신에 &lt;code class=&quot;language-text&quot;&gt;Map&lt;/code&gt; 은 &lt;code class=&quot;language-text&quot;&gt;element key&lt;/code&gt; 를 제공하고, 모두가 알다싶이 이 key값에는 함수나 다른 객체같은 것들도 들어올 수 있어 매우 유용할 것 같다.&lt;/p&gt;
&lt;p&gt;그리고, 신기하게 &lt;code class=&quot;language-text&quot;&gt;forEach&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;map&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;reduce&lt;/code&gt; 와 같은 함수형에 적합한 기능중에서 &lt;code class=&quot;language-text&quot;&gt;Map&lt;/code&gt; 에서는 &lt;code class=&quot;language-text&quot;&gt;forEach&lt;/code&gt;만 제공하는 듯 하다.&lt;/p&gt;
&lt;h2&gt;JS에서 indexOf와 findIndex의 차이&lt;/h2&gt;
&lt;p&gt;이름이 비슷해서 햇갈렸다. 둘의 차이는 간단하다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Array.prototype.indexOf()&lt;/code&gt; 는 첫 인자로 찾고자 하는 값을 넘긴다&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Array.prototype.findIndex()&lt;/code&gt; 는 첫 인자로 콜백 함수를 넘긴다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;둘간의 사용법중에서 가장 큰 차이는, &lt;code class=&quot;language-text&quot;&gt;findIndex&lt;/code&gt;의 경우에 객체나 배열같이 원시값이 아닌 것들을 탐색할때 주로 사용되는 듯하다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/a/41443138&quot;&gt;스택 오버플로우 참고&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;JS에서 숫자의 자릿수 구하기&lt;/h2&gt;
&lt;p&gt;다음과 같이 접근하면 된다. 더 좋은 방법이 있는지 찾아봐야 겠다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; num &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;123&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; digit &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; num&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length
&lt;span class=&quot;token comment&quot;&gt;// 3&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;JS의 Map에서 key 값만 배열로 뽑기&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; keys &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Array&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;myMap&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;keys&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; keys &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;myMap&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;keys&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/a/35341828&quot;&gt;스택 오버플로우 참고&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[웹 개발자들을 위한 잡다한 웹 지식 세미나]]></title><description><![CDATA[세미나 명 웹 개발자들을 위한 잡다한 웹 지식 세미나 일정 2019-11-06 19:00-21:00 장소 구글 스타트업 캠퍼스 발표자 이동휘 님 주제 구글 검색 엔진 이해하기, 구글 크롤러 봇은 JS…]]></description><link>https://sukjae.github.io/daily-study/conference/2019-11-06-google-web-knowledge/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/conference/2019-11-06-google-web-knowledge/</guid><pubDate>Wed, 06 Nov 2019 00:00:00 GMT</pubDate><content:encoded>&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;세미나 명&lt;/th&gt;
&lt;th&gt;웹 개발자들을 위한 잡다한 웹 지식 세미나&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;일정&lt;/td&gt;
&lt;td&gt;2019-11-06 19:00-21:00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;장소&lt;/td&gt;
&lt;td&gt;구글 스타트업 캠퍼스&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;발표자&lt;/td&gt;
&lt;td&gt;이동휘 님&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;주제&lt;/td&gt;
&lt;td&gt;구글 검색 엔진 이해하기, 구글 크롤러 봇은 JS를 어떻게 처리할까&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1&gt;기억에 남는 주제들&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;구글 검색 엔진 활용법&lt;/li&gt;
&lt;li&gt;서치 콘솔, 모바일 친화성 테스트, Lighthouse&lt;/li&gt;
&lt;li&gt;구글 크롤러 봇 &amp;#x26; 검색 결과는 SPA와 같은 JS앱을 어떻게 받아드릴까&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;구글 검색 엔진 활용법&lt;/h1&gt;
&lt;p&gt;대부분의 내용들은 내가 구글 검색을 활용하며 많이 사용하던 방식이라 익숙하였다. 그럼에도 잘 모르던 방법과 활용법을 배울 수 있었다.&lt;/p&gt;
&lt;p&gt;그 중에서 &lt;code class=&quot;language-text&quot;&gt;link:&lt;/code&gt; 의 기능이 새롭게 다가왔다. 나는 이 기능을 잘 활용 해 본적이 없는데, &lt;code class=&quot;language-text&quot;&gt;link&lt;/code&gt; 를 우리 사이트로 두고, &lt;code class=&quot;language-text&quot;&gt;site&lt;/code&gt; 또한 우리 사이트로 둠으로서 외부 사이트에서 우리 사이트 링크가 포함된 게시물의 개수를 파악할 수 있다.&lt;/p&gt;
&lt;p&gt;또한 강의를 들으면서 들었던 의문이, 만약 어떤 상황에서 &lt;code class=&quot;language-text&quot;&gt;link:&lt;/code&gt; 를 명령어가 아닌 검색의 일부로 사용하고 싶을때는 어떻게 활용해야 하나에 대한 고민이였다. 흔한 케이스는 아니지만, 예를 들어 에러 로그에 &lt;code class=&quot;language-text&quot;&gt;link:&lt;/code&gt; 와 같은 문구가 포함되어 있고 이 문구 전체를 검색하고 싶다면 어떻게 해야 할까? 이 부분은 아직 답을 찾지 못했다.&lt;/p&gt;
&lt;h1&gt;서치 콘솔, 모바일 친화성 테스트, Light House&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://search.google.com/search-console/about&quot;&gt;구글 서치 콘솔&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://search.google.com/test/mobile-friendly?hl=ko&quot;&gt;모바일 친화성 테스트&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developers.google.com/web/tools/lighthouse&quot;&gt;Lighthouse&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;강의에서 더 나은 웹을 만들기 위해서 이 세가지 도구를 추천하였다. 기존에 구글 서치 콘솔은 살펴만 보고 제대로 활용하지 않았는데, 이번 부스트 캠프 프로젝트를 해보면서 세가지 도구 모두를 활용해 보기로 마음을 먹었다.&lt;/p&gt;
&lt;p&gt;구글 서치 콘솔은 내가 소유권을 갖는 사이트에 대해 사용이 가능하고, 구글 검색엔진이 내 사이트를 어떻게 인식하는지 파악이 가능하다. 이 외에도 많은 부가 기능을 제공하지만, 결국 더 나은 웹을 만들기 위한 도구인것 같다.&lt;/p&gt;
&lt;p&gt;모바일 친화성 테스트 또한 구글 검색엔진이 사이트를 어떻게 인식하는지 파악을 하는것 같다. 그러나 이 경우에 사이트는 내 소유가 아니더라도 url만 입력하면 확인 가능하다. 이 도구는 모바일에 특화되어 있어 모바일 관련 정보를 위주로 제공한다.&lt;/p&gt;
&lt;p&gt;마지막으로 lighthouse 도 더 나은 웹을 만들기 위한 도구이다. 이 도구는 오픈소스 프로젝트 로서 신기하게 CI 과정중에 포함하여 분석을 활용할 수 있다.이 도구는 현재 웹에 대한 인사이트를 제공하고, 더 나은 방향을 위한 가이드를 제공한다.&lt;/p&gt;
&lt;h1&gt;구글 크롤러 봇 &amp;#x26; 검색 결과는 SPA와 같은 JS앱을 어떻게 받아드릴까&lt;/h1&gt;
&lt;h2&gt;구글봇은 계속 진화한다&lt;/h2&gt;
&lt;p&gt;강의중에 다음과 같은 인상적인 말을 들었다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;구글봇이 변해야지, 사이트가 변해서는 안된다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이에 대한 설명을 보충하면…&lt;/p&gt;
&lt;p&gt;시대가 변하면서 웹에 JS가 무수히 많이 사용되고 있다. 그러면서 검색엔진의 크롤링 봇들이 이해를 하기 어려워졌다.
이러한 상황에서, 사이트가 구글봇에 맞추기 위해 JS를 포기하면서 맞추는 방법은 좋지않다는 의미이다.&lt;/p&gt;
&lt;p&gt;사이트가 추구하는 방향은 사용자에 최적화 하는것인데 그 도구로서 JS가 사용되었다면, 그 방법이 최적의 방법인것이다. 고객(사용자)를 위한 최적의 방법을 도출하였는데, 구글 봇에 맞추기 위해 이를 포기하는것은 옳지 않다는 뜻으로 받아들였다.&lt;/p&gt;
&lt;p&gt;이러한 문제를 해결하기 위해서 구글 봇도 진화를 거듭하였고, 현재는 우리가 사용하는 크롬 버전과 비슷한 환경에서 크롤링이 가능해졌다. 덕분에 구글봇은 ES6+, new Web APIs, Less polyfill을 제공할 수 있게 되었다.&lt;/p&gt;
&lt;p&gt;이 구글봇에 대한 더 자세한 키워드는 &lt;a href=&quot;https://webmasters.googleblog.com/2019/05/the-new-evergreen-googlebot.html&quot;&gt;evergreen Googlebot&lt;/a&gt;을 참고하면 될 것 같다.&lt;/p&gt;
&lt;h2&gt;구글봇과 Lazy loading&lt;/h2&gt;
&lt;p&gt;결국 최종적으로 구글 봇이 바라보는 방향은 일반적인 사용자가 바라보는 화면의 결과 그대로를 원하는 것 같다. 이를 위해서 충분한 시간을 (timeout을 정해두는 것 같다) 두고, JS파일들을 실행하며 화면에 적절한 결과물이 보여지기를 기다린다.&lt;/p&gt;
&lt;p&gt;여기서 조심해야 할 부분은, 일반적으로 많이 사용되었던 사용자 인터렉션을 필요로 하는 액션들(hover, click 등)을 통한 추가 정보 로딩은 여전히 해석이 어렵다는 점이다. 특히 Lazy loading과 같은 기법들을 많이 사용하면서 사용자 인터렉션의 결과로 정보를 얻어오곤 하는데, 이를 위한 다양한 표준 방법들이 등장하고 있다.&lt;/p&gt;
&lt;p&gt;그 예로 두가지 정도가 기억난다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;web을 위한 native image lazy-loading&lt;/li&gt;
&lt;li&gt;Intersection Observer&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;web을 위한 native image lazy-loading&lt;/h3&gt;
&lt;p&gt;첫번째 native lazy-loading 방법은 Chrome 75 부터 제공되는 기능이다. &lt;a href=&quot;https://addyosmani.com/blog/lazy-loading/&quot;&gt;자세한 설명&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;다음과 같이 작성하면, 브라우저에서 기본적으로 lazy loading을 제공해 주며 기존에 사용하던 scroll의 위치에 따른 이벤트 등록 등이 필요없게 된다. 또한 기존의 이벤트 방식에 비해 구글 봇이 이해를 할 수 있음이 중요한 부분인 것 같다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 예시&lt;/span&gt;
&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;img src&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;celebration.jpg&quot;&lt;/span&gt; loading&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;lazy&quot;&lt;/span&gt; alt&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;...&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;iframe src&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;video-player.html&quot;&lt;/span&gt; loading&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;lazy&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;iframe&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Intersection Observer (이하 IO)&lt;/h3&gt;
&lt;p&gt;이 방법은 매우 유용하고, 자주 사용될 수 있으므로 다른 포스트로 분리하겠다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API&quot;&gt;자세한 설명&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;최대한 요약하면, 기존 이벤트 방식과 다르게 메인 스레드를 점유하지 않고, 구글 봇이 이해 가능하다.&lt;/p&gt;
&lt;p&gt;여기서 내가 들었던 의문은, 어찌 되었든 IO또한 적합한 상황이 되어야 액션이 이루어질텐데, 구글봇은 그 적합한 상황을 어떻게 만드나에 대한 의문이였다. 내가 생각할 수 있는 두가지 상황은, 1. viewport를 아주 크게 잡아서 모든 IO가 반응하도록 한다 2. 실제 스크롤을 해서 해당 IO에 접근하여 반응하도록 한다.&lt;/p&gt;
&lt;p&gt;그러나, 두번째 방법은 기존의 이벤트 방식(스크롤을 통한)에서 해결이 어려웠던 부분인데 IO라고 해서 특별히 무언가 다른 수가 있을 것 같지 않았다. 즉, 이 가정을 위해서는 구글봇이 실제 스크롤을 내리는 작업을 해야 할 것 같았다.&lt;/p&gt;
&lt;p&gt;이에 대한 발표자님의 답변은, 구글봇은 그 화면은 매우 크게 잡는다고 언급해 주셨다. 즉, viewport를 매우 크게 잡음으로서 IO가 반응하도록 하는 방향을 따르는것 같다.&lt;/p&gt;
&lt;h2&gt;구글봇과 SPA&lt;/h2&gt;
&lt;p&gt;그러면 현재의 구글봇은 많이 사용되는 SPA형태의 앱을 어떻게 바라볼까?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;구글봇은 많이 진화하여 일반 사용자가 JS를 통해 완성되는 결과물과 흡사한 결과물을 볼 수 있게 되었다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;과거 SPA를 검색엔진에 노출하기 위해서는 SSR, Hydrate+SSR, Pre-rendering, Dynamic Rendering 등이 사용되곤 했다. 이들이 모두 해결하고자 하였던 문제는, 구글봇이 검색엔진에 사용될 정보를 수집하는 과정에서 일반적인 HTML과 같은 문서만 수집하기 때문에 SPA와 같이 JS 실행을 통하여 동적으로 문서를 생성하는 SPA의 경우는 검색엔진 노출이 잘 안이루어 진다는 점이였다.&lt;/p&gt;
&lt;p&gt;그러나, 위에 언급하였듯이 이제 구글봇은 발전을 통하여 JS파일을 실행하기 때문에 구글 검색엔진만을 위해서라면 크게 걱정을 안해도 될것 같다. 감사하게도 우리는 사용자(고객)에게 최고의 서비스를 제공하기 위한 고민에만 집중하면 될것 같다. (크게 고민 안해도 되지만, 그럼에도 노출하고자 하는 정보의 제공 과정은 염두에 두며 개발을 해야 한다.)&lt;/p&gt;
&lt;h1&gt;느낀점 요약&lt;/h1&gt;
&lt;p&gt;나는 SEO를 생각하면 우리(개발자)가 구글과 구글봇의 방식에 맞춰야 한다는 생각을 갖고 있었다. 그러나 우리가 해야 할 일은, 구글봇에 적합한 무언가를 만드는게 아니라 결국 사용자가 사용하기 좋은 서비스를 만드는 것에 목표를 두어야 함을 알게 되었다. 즉, 더 나은 웹을 만들기 위한 고민이 결과적으로 구글 봇의 방향과도 일치하는 것 같다.&lt;/p&gt;
&lt;p&gt;또, 지금 진행하고자 하는 프로젝트에 lighthouse를 접목하여 더 나은 웹을 만들어 보려 한다.&lt;/p&gt;
&lt;h2&gt;기타&lt;/h2&gt;
&lt;h3&gt;언급된 추가 정보들&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://hacks.mozilla.or.kr/&quot;&gt;모질라 웹기술블로그&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developers.google.com/web/updates/2017/04/headless-chrome&quot;&gt;Headless Chrome&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://schema.org/&quot;&gt;schema org&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;세부 주제&lt;/h3&gt;
&lt;p&gt;(1) 알아두면 쓸모있을 수도 있는(?!) 잡다하고 자잘한 웹 지식 (30분 강의, 20분 질의응답)
웹 개발자, 웹마스터, 웹 마케터 등 웹으로 밥 먹고 사는 사람들이 한번쯤 들어보거나 생각해봤던 자잘한 궁금증을 풀어보는 시간!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;고급 Google 검색 기법&lt;/li&gt;
&lt;li&gt;Google 봇의 눈으로 테스트하기&lt;/li&gt;
&lt;li&gt;DNS lookup 테스트 해보기&lt;/li&gt;
&lt;li&gt;robots.txt 파헤치기&lt;/li&gt;
&lt;li&gt;사이트맵 알아보기&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(2) Google 검색과 자바스크립트 사이트 (30분 강의, 20분 질의응답)
요즘 자바스크립트가 들어가지 않는 사이트가 없죠? React, Vue.js, Angular, AMP, 날이 갈수록 복잡해지는 자바스크립트 사이트, Google 검색은 자바스크립트로 중무장한 사이트를 제대로 이해할 수 있을까요? 이 세션에서는 Google I/O의 발표 내용을 바탕으로 Google이 동적인 페이지를 어떻게 다루는지 알아봅니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Agile Software Development with Scrum 2]]></title><description><![CDATA[원제 Agile Software Development with Scrum 제목 스크럼 저자 Ken schwaber, Mike beedle ISBN 9788991268470 독서 기간 2019-11-01 독서 량 1장 -…]]></description><link>https://sukjae.github.io/daily-study/read-a-book/scrum-ken-day2/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/read-a-book/scrum-ken-day2/</guid><pubDate>Fri, 01 Nov 2019 00:00:00 GMT</pubDate><content:encoded>&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;원제&lt;/th&gt;
&lt;th&gt;Agile Software Development with Scrum&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;제목&lt;/td&gt;
&lt;td&gt;스크럼&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;저자&lt;/td&gt;
&lt;td&gt;Ken schwaber, Mike beedle&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ISBN&lt;/td&gt;
&lt;td&gt;9788991268470&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;독서 기간&lt;/td&gt;
&lt;td&gt;2019-11-01&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;독서 량&lt;/td&gt;
&lt;td&gt;1장 - 2장&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;시작하기 앞서…&lt;/h2&gt;
&lt;p&gt;부스트 캠프에서 본격적인 프로젝트 시작에 앞서, 우리가 매일 수행하던 스크럼에 대한 깊이있는 이해를 위하여 책을 읽기 시작했다. 이 책을 통해서 스크럼이 갖고 있는 철학, 해결하고자 했던 문제, 그리고 그 방법을 익히고자 한다. 결과적으로, 스크럼을 성공적으로 프로젝트에 접목하고 싶다.&lt;/p&gt;
&lt;h2&gt;새로이 알게 된 내용들&lt;/h2&gt;
&lt;h3&gt;스크럼 동안에는 (p14)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;팀 외부의 어느 누구에 의해서도 방해를 받거나 지시를 받아서는 안 된다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;일일 스크럼에서는 (p14)&lt;/h3&gt;
&lt;p&gt;진행 상황을 검토하고, 제거해야 하는 장애물을 확인 하며, 팀의 진척 정도를 확인하게 된다.&lt;/p&gt;
&lt;h3&gt;스크럼이 개발자에게 제공하는 것 (p15)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;스크럼은 개발자들로 하여금 업무에 집중해서 재빨리 고품질의 제품을 만들어 내도록 하는데 필요한 모든 관리 및 통제권을 제공한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;왜 폭포수가 오늘날에 효과가 없는가 (p17)&lt;/h3&gt;
&lt;p&gt;우리는 프로젝트가 시작되기 전까지 요구사항이 무엇인지 이해할 수 없다.&lt;/p&gt;
&lt;p&gt;왜냐하면 사용자는 초기 버전의 소프트웨어를 보고 나서야 비로서 자신들이 무엇을 원하는지 알게 되기 때문이다.&lt;/p&gt;
&lt;p&gt;이로 인하여 설계와 요구사항은 끊임없이 변화 되고, 변화 되어야 한다.&lt;/p&gt;
&lt;h3&gt;단속 평형 효과 (p19)&lt;/h3&gt;
&lt;p&gt;변화는 하위 시스템이 병렬적으로 진화해서 함께 맞물려 가며 발생한다.&lt;/p&gt;
&lt;p&gt;그 과정이 처음에는 미비해 보이지만, 어느 짧은 순간 극적으로 변화가 두드러진다.&lt;/p&gt;
&lt;p&gt;컴포넌트에 변화를 이르키는 싱크 스텝이 지속적으로 들어옴에 따라 컴포넌트가 변화되며 서로 호응하며 변이를 이르킨다.
이러한 현상은 흡사 유전적 돌연변이로 인해 단속 평형 효과가 일어나는 것 처럼 보인다.&lt;/p&gt;
&lt;h3&gt;방법론이란 요리책과 같다 (p36)&lt;/h3&gt;
&lt;p&gt;적힌 조리법을 그대로 따라 하면 멋진 시스템이 나올것이다.&lt;/p&gt;
&lt;h3&gt;시스템 개발 산업의 공정 제어 모델 (p38)&lt;/h3&gt;
&lt;p&gt;전통적인 시스템 개발 산업은 부적절한 공정 제어 모델을 따라서 개발이 되고 있었다.&lt;/p&gt;
&lt;p&gt;이러한 인사이트는 실제 하드웨어 산업에서 공정 제어를 적용하는 전문가들에 의해 발견 되었고, 저자에게 전달 되었다.&lt;/p&gt;
&lt;p&gt;공정의 특성에 따라 다양한 제어 방법이 존재하고, 시스템 개발 산업에도 적절한 공정 제어 방법이 존재할 수 있음에도 이 방식이 잘못되어 왔다고 한다.
책에서 말하는 내용을 따르면, 기존의 시스템 개발 산업에서 쓰이던 방식은 개발이 너무 복잡하고 예측하기 어려움에도 불구하고 명시적인 접근법을 써 왔다고 한다.&lt;/p&gt;
&lt;p&gt;명시적 공정 제어 모델은 작업의 모든 부분을 완전히 이해하고 있어야 하고, 그 결과과 동일한 산출물은 내놓을 수 있는 모델이다. 이 모델의 특징중 하나는 프로세스나 테스크가 반복 가능하며 예측이 가능해야 하는데, 이는 단순 노동에서 적합한 방법이라 생각된다.&lt;/p&gt;
&lt;p&gt;반면, 소프트웨어 개발은 많은 사고와 창조성을 요구하는 지식 집약적인 사업이다. 그로 인하여 무언가 획일적으로 예측하고 제어 하고자 할 때 통제력 상실과 불완전한 제품 생산을 초래할 수 있다고 한다.&lt;/p&gt;
&lt;p&gt;결과적으로 지금껏 우리는 우리 분야의 여러 태스크들이 마치 시작과 종료가 예측 가능하기라도 한 듯이 명시적인 공업 프로세스처럼 서로 종속적으로 연결해왔다.&lt;/p&gt;
&lt;p&gt;조금 더 쉽게 풀어쓰면 우리는 예측하고, 반복하기 어려운 작업을 구태여 사전에 모두 예측하는 전략을 취하고 있었던 것이다.
예측 할 수 없음을 받아드리고, 그에 맞는 전략을 취한다면 더 옳바른 공정의 제어가 가능해 질것이다.&lt;/p&gt;
&lt;p&gt;이 책에서 그 방식으로 불확실성을 기반으로 하는 경험 주의적인 공정 제어 모델을 이용하도록 설득한다.&lt;/p&gt;
&lt;p&gt;이 모델에서 스크럼의 핵심 철학을 볼 수 있는데, 소프트웨어 개발이 불확실하고 이를 해결하기 위해 경험을 기반으로 지속적인 피드백을 통하여 점진적인 개선이 필요함을 뜻하는 것 같다&lt;/p&gt;
&lt;h3&gt;가능한 것을 하라 (p42)&lt;/h3&gt;
&lt;p&gt;스크럼의 기본이 되는 원칙중 하나이다.&lt;/p&gt;
&lt;p&gt;불가능한 것들에 매달리지 말고 가능한 것부터 생각하라는 의미이다. 더 풀어 쓴다면, 현 상황에서 불가능 한 것이 존재함을 인정하고, 그 불가능함에 매달리지 않으며, 현재로서 수행 가능한 최선의 작업을 먼저 접근 하라는 뜻이다.&lt;/p&gt;
&lt;p&gt;물론, 불가능이 우리에게 매우 중요한 우선순위를 갖고, 꼭 행해져야 하는 일이라면 현 상황에서 불가능 하더라도 이를 가능하게 만드는 작업이 필요하다.
뒤에 나오지만, 필요한 경우에 스프린트를 중단 하고서라도 해결하기도 한다.&lt;/p&gt;
&lt;h2&gt;용어 정리&lt;/h2&gt;
&lt;p&gt;단속 평형 : 생물의 진화적 변화는 긴 기간의 진화적 정지 상태와 함께 비교적 짧은 기간의 환경적 압력에 의해서 급격하게 일어난다는 이론.&lt;/p&gt;
&lt;p&gt;싱크 스텝 : 컴포넌트에 변화를 가하는 작업 단위&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Agile Software Development with Scrum 1]]></title><description><![CDATA[원제 Agile Software Development with Scrum 제목 스크럼 저자 Ken schwaber, Mike beedle ISBN 9788991268470 독서 기간 2019-10-31 독서 량…]]></description><link>https://sukjae.github.io/daily-study/read-a-book/scrum-ken-day1/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/read-a-book/scrum-ken-day1/</guid><pubDate>Thu, 31 Oct 2019 00:00:00 GMT</pubDate><content:encoded>&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;원제&lt;/th&gt;
&lt;th&gt;Agile Software Development with Scrum&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;제목&lt;/td&gt;
&lt;td&gt;스크럼&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;저자&lt;/td&gt;
&lt;td&gt;Ken schwaber, Mike beedle&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ISBN&lt;/td&gt;
&lt;td&gt;9788991268470&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;독서 기간&lt;/td&gt;
&lt;td&gt;2019-10-31&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;독서 량&lt;/td&gt;
&lt;td&gt;1장&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;시작하기 앞서…&lt;/h2&gt;
&lt;p&gt;부스트 캠프에서 본격적인 프로젝트 시작에 앞서, 우리가 매일 수행하던 스크럼에 대한 깊이있는 이해를 위하여 책을 읽기 시작했다. 이 책을 통해서 스크럼이 갖고 있는 철학, 해결하고자 했던 문제, 그리고 그 방법을 익히고자 한다. 결과적으로, 스크럼을 성공적으로 프로젝트에 접목하고 싶다.&lt;/p&gt;
&lt;h2&gt;새로이 알게 된 내용들&lt;/h2&gt;
&lt;h3&gt;스크럼은… (p1)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;스크럼은 공정 제어 이론을 바탕으로 한 경험주의적인(empinical) 접근법을 사용하며, 이 접근법은 시스템 개발에 유연성, 적응성, 생산성을 재도입했다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;처음 이 문장을 접했을 때, 이 내용이 스크럼의 핵심적인 내용을 내포하고 있을 거란 짐작은 하였지만 그 의미가 와닿지는 않았다. 뒷부분에 스크럼이 나오게 된 과정과 영감을 얻은 부분이 다뤄지는 내용을 통해 이 의미를 이해할 수 있었다.&lt;/p&gt;
&lt;h3&gt;전체성을 지향하는 기법(holistic method) (p1)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;럭비 경기에서 팀 동료들 간에 공을 재빨리 돌려서 전체 팀이 경기장에서 마치 한 몸처럼 움직이는 것과 비슷하다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이 책을 읽으면서 알게된 내용인데, 사실 스크럼이란 단어는 럭비(미식축구)에서 왔다고 한다.&lt;/p&gt;
&lt;h3&gt;스크럼과 XP의 관계 (p3)&lt;/h3&gt;
&lt;p&gt;스크럼은 익스트림 프로그래밍(XP)의 실천방법으로 사용된다.&lt;/p&gt;
&lt;p&gt;XP에서 나온 3가지 주요 요소를 보면 가치, 원칙, 실천 방법이 존재한다. 그 중에서 실천방법으로서 스크럼을 활용하는것이라 생각이 든다.&lt;/p&gt;
&lt;h3&gt;스크럼이 필요한 조직 (p5)&lt;/h3&gt;
&lt;p&gt;이 책에서 들고 있는 예시 상황을 보면, 다음과 같은 조직에서 스크럼이 필요한것 같다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;개발팀에게 공식/비공식적인 요구사항이 중구난방으로 수시로 전달된다.&lt;/li&gt;
&lt;li&gt;개발팀은 계속하여 다른이들의 요구사항을 들어야 한다.&lt;/li&gt;
&lt;li&gt;개발팀의 구현 우선순위는 상위 누군가에 의해 정해진다.&lt;/li&gt;
&lt;li&gt;이로 인해서 개발팀은 개발에 집중할 수 있는 시간이 없다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;스크럼이 이 방식을 해결하는 형태는 다음과 같다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;우선순위를 맡는 누군가(꼭 경영진일 필요는 없다)가 존재한다.&lt;/li&gt;
&lt;li&gt;우선순위는 절대적인게 아니고, 상황에 따라 변경된다.&lt;/li&gt;
&lt;li&gt;새로운 작업을(요구사항) 요청받는 창구를 하나로 만들어라.&lt;/li&gt;
&lt;li&gt;이를 하나의 목록으로 정리하라.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;결과적으로, 이러한 방식을 통하여 요구사항을 수집하고 우선순위를 받아내며 외부의 잡음을 막아낼 수 있는 수호자가 생기고, 개발팀은 개발에 전념할 수 있다.&lt;/p&gt;
&lt;h3&gt;나쁜 아이디어 (p6)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;“안 됩니다” 라고 얘기할 필요가 없어졌다. 대신 우선순위를 정하기만 하면 되었다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;“나쁜” 아이디어란 없었다. 단지, 도저히 구현될 것 같지 않은 아이디어만 있을 뿐이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;아이디어에 대해 기다 아니다 하며 구현 여부를 정하기 보다 상대적인 우선순위를 선택을 유보한다.&lt;/p&gt;
&lt;h3&gt;나도 회의를 하면서 많이 겪은 상황들 (p11)&lt;/h3&gt;
&lt;p&gt;회의 시간을 정해놓아도 하나의 주제가 던져지면, 여러 사람이 대화를 던지기 시작하고, 곧 팀 전체가 그 주제에 대한 최적의 답을 위한 토론에 휩싸여 버린다.&lt;/p&gt;
&lt;p&gt;이로 인하여 한가지 결정을 내리려고 할 때 마다 팀 전체가 거기에 매달리게 되었다.&lt;/p&gt;
&lt;p&gt;또한, 개발 팀이 아닌 다른 조직의 구성원들이 의견과 제안을 주기 시작하고, 이로 인하여 팀이 가져가야 할 초점이 흐려지곤 했다.&lt;/p&gt;
&lt;p&gt;결국 스크럼 회의는 혼돈스러운 난투로 변해갔고 그 효용성이 매일매일 떨어졌다.&lt;/p&gt;
&lt;p&gt;이러한 상황을 해결하기 위해 저자가 제시하는 방법은 다음과 같다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;오직 팀원들만이 발언할 수 있다. (나머지는 조용히 지켜만 본다.)&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;팀원들은 오직 세가지 주제에 대해서만 말할 수 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;지금까지 무엇을 했고&lt;/li&gt;
&lt;li&gt;다음에는 무엇을 할것이고&lt;/li&gt;
&lt;li&gt;무엇이 작업을 방해하고 있는지&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;제품 백로그는 결코 확정되지 않는다.(p12)&lt;/h3&gt;
&lt;p&gt;오히려 제품과 함께 성장하고 진화한다. 제품 백로그에서 우선순위가 가장 높은 항목이 가장 필요한 항목이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;누구나 제품 백로그의 내용들ㅇ을 제안할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이 내용을 보고 든 생각이, 내가 곧 진행할 프로젝트는 4인 1조이지만, 전체 캠프원이 자유롭게 우리의 제품에 의견을 남길 수 있는 구조를 만들면 어떨까 라는 생각이 들었다.&lt;/p&gt;
&lt;p&gt;프로젝트가 시작하면, 제품 백로그를 만들고 이를 온오프라인으로 접근이 가능하게 하여 누구나 참여할 수 있도록 하려 한다.&lt;/p&gt;
&lt;p&gt;그러기 위해서 오프라인에서는 화이트 보드를, 온라인에서는 트렐로를 사용하려 한다.&lt;/p&gt;
&lt;h3&gt;스프린트의 끝에는 (p13)&lt;/h3&gt;
&lt;p&gt;스프린트 동안에 개발 가능하다고 생각한 만큼의 제품 백로그를 선택한다. 그 결과 매 스프린트 종료시마다 새로운 기능이 추가되어 실행 가능한 제품이 인도되어야 한다.&lt;/p&gt;
&lt;p&gt;이 부분을 지속적인 배포를 말하는 듯 하다. 배포 주기를 스프린트 단위가 아닌 일일 배포를 잡는 방법도 있다.&lt;/p&gt;
&lt;h2&gt;용어 정리&lt;/h2&gt;
&lt;p&gt;스프린트: 한번의 반복 주기(Iteration)&lt;/p&gt;
&lt;p&gt;제품 증분(product increment): 스프린트의 결과물&lt;/p&gt;
&lt;p&gt;제품 책임자 : 제품 백로그 항목들에 우선순위를 부여할 수 있는 유일한 인물&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Extreme Programming Explained 2/E 3]]></title><description><![CDATA[원제 Extreme Programming Explained 2/E 제목 익스트림 프로그래밍 저자 Kent Beck ISBN 8991268102 독서 기간 2019-10-28 독서 량…]]></description><link>https://sukjae.github.io/daily-study/read-a-book/XP-kent-beck-day3/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/read-a-book/XP-kent-beck-day3/</guid><pubDate>Mon, 28 Oct 2019 00:00:00 GMT</pubDate><content:encoded>&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;원제&lt;/th&gt;
&lt;th&gt;Extreme Programming Explained 2/E&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;제목&lt;/td&gt;
&lt;td&gt;익스트림 프로그래밍&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;저자&lt;/td&gt;
&lt;td&gt;Kent Beck&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ISBN&lt;/td&gt;
&lt;td&gt;8991268102&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;독서 기간&lt;/td&gt;
&lt;td&gt;2019-10-28&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;독서 량&lt;/td&gt;
&lt;td&gt;5장&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;시작하기 앞서…&lt;/h2&gt;
&lt;p&gt;이 책은 한번 읽었었던 책이다. 너무 좋은 내용의 책이였고, 언젠간 나의 개발의 지침서로서 삼고자 마음을 먹고 있었다. 좋은 기회에 팀 프로젝트를 진행할 기회가 생겼고, 이에 앞서 XP의 정신과 철학을 프로젝트에 적용해보기 위해 다시 책을 읽기 시작하였다. 당시에도 추상적이였던 내용들을 최대한 정리하여 프로젝트에서 활용 가능한 지침들을 정리하도록 노력하려한다. &lt;/p&gt;
&lt;h2&gt;새로이 알게 된 내용들&lt;/h2&gt;
&lt;h3&gt;XP가 말하는 원칙 (p51)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;가치는 너무 추상적이라 행동의 직접적인 지침으로 삼을 수 없다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;소프트웨어의 개발을 함에 있어 XP의 지침으로 삼을 수 있는 원칙들이 필요하다. &lt;/p&gt;
&lt;h3&gt;인간성 (p52)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;인간이 소프트웨어를 작성한다는 사실을 무시하면 개발에 참여하는 사람들이 큰 대가를 치르게 된다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;즉, 인간이라는 존재에 대한 파악을 해야 하고, 인간은 욕구를 충족해야 하고, 약한 존재임을 염두에 두고 있어야 한다. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;친밀감은 참 좋은 것이지만, 일은 일이다. 사적인 일은 사적으로 처리해야 한다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;경제성 (p54)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;이 모든 것에 대해 결국 누군가 돈을 지불해야 한다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;상호 이익 (p55)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;XP에서는 “미래와 의사소통하기” 문제를 상호 이익이 되는 방법으로 해결한다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;여기서 “미래와 의사소통하기”는 장래 누군지 알 수 없는 사람이 코드를 유지보수해야 하는것을 고려하여 나의 생산성을 현저히 낮추는 상황에서 어떻게 타협을 볼지에 대한 내용인듯 하다. &lt;/p&gt;
&lt;p&gt;이를 위하여&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;자동화 테스트 작성&lt;/li&gt;
&lt;li&gt;리펙터링&lt;/li&gt;
&lt;li&gt;명시적인 메타포 집합에서 이름 골라 쓰기&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;결국 이를 통해 원하는 것은&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;내게 지금 이익이 되고&lt;/li&gt;
&lt;li&gt;나중에도 이익이 되고&lt;/li&gt;
&lt;li&gt;내 고객에게도 이익이 되는 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;실천 방법들을 찾는 것이다. &lt;/p&gt;
&lt;h3&gt;자기 유사성 (p56)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;과거 효과적이였던 방법들을 다시 적용해 보자. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;자연은 어떤 형태가 효과적이라는 사실을 발견하면, 그 형태를 이용할 수 있는 곳이라면 어디에나 그것을 이용한다.
이러한 자기유사성은 소프트웨어 개발에서도 사용되고, 이는 어떤 일을 시작하기에 좋은 방법이다. &lt;/p&gt;
&lt;h3&gt;개선 (p58)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;소프트웨어 개발에서는 ‘완벽하다’는 없고 ‘완벽해 지도록 노력한다’ 만 있다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;프로세스, 설계, 스토리 등을 처음부터 완벽하게 만드려고 하지 말자.
주기적인 의견 공유를 통해 점진적으로 발전 시켜보자. &lt;/p&gt;
&lt;h3&gt;다양성 (p59)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;갈등이 없는 팀은 없다. 관건은 생산적으로 풀 수 있는가다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;반성 (p60)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;좋은 팀은 그저 일만 하지 않으며, 어떻게 일하는지 왜 일하는지도 생각한다. 그들은 자신들이 왜 성공했으며, 왜 실패했는지 분석한다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;좋은 팀은 실수를 숨기려 하지 않고 오히려 실수를 드러내어 거기서 배운다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;아무 생각없이 그저 일하다 보니 잘하게 되었더라. 하고 말할 수 있는 사람은 없다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;흐름 (p61)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;개발의 모든 단계를 동시에 작업함으로써 가치 있는 소프트웨어를 흐르듯이 끊임없이 제공하는 것&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;기회 (p62)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;뛰어난 실력을 갖추려면, 문제를 단지 생존의 문제가 아니라 배움과 개선의 기회로 전환할 줄 알아야 한다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;잉여 (p62)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;잉여를 둠으로서 완전히 실패하더라도 다른 것들 덕분에 재앙은 면할 수 있다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;즉, 시스템에 큰 문제가 보이지 않더라도, 대안책들과 예방책들을 마련해 놓으라는 것이다. &lt;/p&gt;
&lt;h3&gt;실패 (p63)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;실패가 지식을 늘려주는 한, 그것은 허비가 아니다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;품질 (p64)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;품질은 제어할 수 있는 변수가 아니다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;아기 발걸음 (p66)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;큰 변화를 몰아서 수행하기 보다 할 수 있는 최소한의 일을 해가며 움직이자. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;아기 발걸음은, 단계를 잘게 쪼갤 때 생기는 부하가, 큰 변화를 시도했다가 실패해서 다시 원상태로 돌아갈 때 드는 낭비보다 훨씬 작다는 사실을 인정하는 것이다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;받아들인 책임 (p66)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;받아들인 책임의 원칙을 반영하는 실천방법의 한 예는, 어떤 일을 하겠다고 한 사람이 그 평가도 내리는 것이다.
비슷하게, 스토리를 구현할 책임을 가진 사람이 궁극적으로 스토리의 설계, 구현, 테스트까지 책임을 갖는 것이다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;결론 (p67)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;원칙이 있다면 실천방법들을 더 잘 이해할 수 있다. &lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[Extreme Programming Explained 2/E 2]]></title><description><![CDATA[원제 Extreme Programming Explained 2/E 제목 익스트림 프로그래밍 저자 Kent Beck ISBN 8991268102 독서 기간 2019-10-27 독서 량…]]></description><link>https://sukjae.github.io/daily-study/read-a-book/XP-kent-beck-day2/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/read-a-book/XP-kent-beck-day2/</guid><pubDate>Sun, 27 Oct 2019 00:00:00 GMT</pubDate><content:encoded>&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;원제&lt;/th&gt;
&lt;th&gt;Extreme Programming Explained 2/E&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;제목&lt;/td&gt;
&lt;td&gt;익스트림 프로그래밍&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;저자&lt;/td&gt;
&lt;td&gt;Kent Beck&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ISBN&lt;/td&gt;
&lt;td&gt;8991268102&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;독서 기간&lt;/td&gt;
&lt;td&gt;2019-10-27&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;독서 량&lt;/td&gt;
&lt;td&gt;4장&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;시작하기 앞서…&lt;/h2&gt;
&lt;p&gt;이 책은 한번 읽었었던 책이다. 너무 좋은 내용의 책이였고, 언젠간 나의 개발의 지침서로서 삼고자 마음을 먹고 있었다. 좋은 기회에 팀 프로젝트를 진행할 기회가 생겼고, 이에 앞서 XP의 정신과 철학을 프로젝트에 적용해보기 위해 다시 책을 읽기 시작하였다. 당시에도 추상적이였던 내용들을 최대한 정리하여 프로젝트에서 활용 가능한 지침들을 정리하도록 노력하려한다.&lt;/p&gt;
&lt;h2&gt;영감을 받은 내용들&lt;/h2&gt;
&lt;h3&gt;윌 로저스가 말한 것 처럼(p43)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;문제는 자네가 모르는 것 때문에 생기는 게 아니야. 잘못 아는 데서 생기지&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;개개인이 그냥 아는것에 초점을 맞추고, 개인 플레이를 하기보단 조직의 일원으로서 행동해야 한다.&lt;/p&gt;
&lt;p&gt;또한 누구나 자기 나름대로 중요하게 생각하는 것이 있다. 그러나 이러한 부분들을 조직의 구성원으로서 팀의 성공을 위해 통일할 필요가 있다 .&lt;/p&gt;
&lt;h2&gt;새로이 알게 된 내용들&lt;/h2&gt;
&lt;h3&gt;XP가 말하는 가치(p44)&lt;/h3&gt;
&lt;p&gt;XP는 개발을 이끌기 위해 다섯가지의 가치를 포용한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;의사소통&lt;/li&gt;
&lt;li&gt;단순성&lt;/li&gt;
&lt;li&gt;피드백&lt;/li&gt;
&lt;li&gt;용기&lt;/li&gt;
&lt;li&gt;존중&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;의사소통 (p45)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;우리는 한 팀이라는 느낌을 만들고, 효과적으로 협동하려면 의사소통이 중요하다. 하지만 효과적인 소프트웨어 개발에 필요한 것은 의사소통만이 아니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;단순히, 우리는 한 가족이고 소통을 잘 하는것 많이 중요한게 아니다. 5개의 가치 속에서 밸런스를 맞추는 것이 중요하다는 의미인것 같다.&lt;/p&gt;
&lt;h3&gt;단순성 (p45)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;오늘의 문제만 우아하게 해결할 만큼 단순한 시스템을 만드는 것&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;피드백 (p46)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;경험해 보기 전에 정해진 방향은 특히 수명이 짧다. 변화는 불가피 하지만, 변화는 피드백을 필요하게 만든다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;피드백의 양이 너무 많으면 문제가 생기기도 한다. 중요한 피드백들에 미처 대응하지 못하면, 이를 대처하기 위해 어느정도 피드백 주기를 늦출 필요가 있다.&lt;/p&gt;
&lt;h3&gt;용기 (p48)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;용기는 홀로 있을 때는 위험하지만, 다른 가치들과 조화를 이룰 때 강력해진다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;존중 (p49)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;모든 사람은 인간으로서 동등한 가치를 지닌다.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[Extreme Programming Explained 2/E 1]]></title><description><![CDATA[원제 Extreme Programming Explained 2/E 제목 익스트림 프로그래밍 저자 Kent Beck ISBN 8991268102 독서 기간 2019-10-26 독서 량 1장 -…]]></description><link>https://sukjae.github.io/daily-study/read-a-book/XP-kent-beck-day1/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/read-a-book/XP-kent-beck-day1/</guid><pubDate>Sat, 26 Oct 2019 00:00:00 GMT</pubDate><content:encoded>&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;원제&lt;/th&gt;
&lt;th&gt;Extreme Programming Explained 2/E&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;제목&lt;/td&gt;
&lt;td&gt;익스트림 프로그래밍&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;저자&lt;/td&gt;
&lt;td&gt;Kent Beck&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ISBN&lt;/td&gt;
&lt;td&gt;8991268102&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;독서 기간&lt;/td&gt;
&lt;td&gt;2019-10-26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;독서 량&lt;/td&gt;
&lt;td&gt;1장 - 3장&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;시작하기 앞서…&lt;/h2&gt;
&lt;p&gt;이 책은 한번 읽었었던 책이다. 너무 좋은 내용의 책이였고, 언젠간 나의 개발의 지침서로서 삼고자 마음을 먹고 있었다. 좋은 기회에 팀 프로젝트를 진행할 기회가 생겼고, 이에 앞서 XP의 정신과 철학을 프로젝트에 적용해보기 위해 다시 책을 읽기 시작하였다. 당시에도 추상적이였던 내용들을 최대한 정리하여 프로젝트에서 활용 가능한 지침들을 정리하도록 노력하려한다.&lt;/p&gt;
&lt;h2&gt;새로이 알게 된 내용들&lt;/h2&gt;
&lt;h3&gt;XP의 목표 (p19)&lt;/h3&gt;
&lt;p&gt;XP의 목표는, 뛰어난 소프트웨어의 개발이다.&lt;/p&gt;
&lt;h3&gt;XP란 (p23)&lt;/h3&gt;
&lt;p&gt;XP는 사회적 변화에 대한 것이다.&lt;/p&gt;
&lt;p&gt;XP는, 과거에는 잘 통했지만 지금은 일을 최고로 잘 하려고 하는데 방해가 될 뿐인 습관과 양식들을 버리는 것에 대한 이야기다.&lt;/p&gt;
&lt;p&gt;XP는, 우리를 보호해 주긴 하지만 생산성은 떨어뜨리는 방어수단들을 포기하는 것에 대한 이야기다.&lt;/p&gt;
&lt;h3&gt;XP는 다음과 같은 것들을 포함한다 (p24)&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;의사소통, 피드백, 단순성, 용기, 존중 같은 가치들에 바탕을 둔 소프트웨어 개발 철학.&lt;/li&gt;
&lt;li&gt;소프트웨어 개발을 개선하는데 쓸모가 있다고 증명된 실천방법들의 집합. 실천방법들은 서로 보완함으로써 각각의 효과를 증폭한다. 앞서 말한 가치들을 표현하는 것들이 실천방법으로 선택된다.&lt;/li&gt;
&lt;li&gt;상호 보완적인 원칙들. 가치를 실천 방법으로 옮기는 지적인 기법들의 집합이다. 여러분이 어떤 특정한 문제에 마주쳤는데 기존 실천 방법 중에 딱 맞는 것이 없을 때 유용하다.&lt;/li&gt;
&lt;li&gt;이 가치들을 공유하고, 동일한 실천방법들 중 상당수를 공유하는 공동체.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;운전하는 법 배우기 (p36)&lt;/h3&gt;
&lt;p&gt;자동차를 운전할 때와 비슷하게, 소프트웨어 개발은 방향을 한 번 맞춰놓고 그냥 유지 하면 안된다.&lt;/p&gt;
&lt;p&gt;매주 방향에 대한 결정을 내리면서도, 멀리 지평선 위 어느 지점이 목표 지점인지 마음속에 늘 생각해야 한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;운전은 차를 똑바른 방향으로 가도록 맞추어 놓고 그대로 두는게 아니야. 운전은 계속 신경을 쓰면서 방향을 조금씩 고쳐가는 거지.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;XP의 패러다임 (p36)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;깨어 있고 적응하며 변하는 것&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;실천 방법은 가치의 증거다 (p39)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;내가 천장짜리 이 문서를 작성한 이유는, 의사소통이라는 가치를 소중히 여기기 때문입니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;만약, 이보다 더 효과적인 방법이 있음에도 이를 선택하였다면, 이는 이 가치를 소중히 여기는게 아니다.
즉, 의사소통을 가치있게 여기는게 아닐 수 있다.&lt;/p&gt;
&lt;p&gt;의사소통을 가치있게 여긴다는 것은 내가할 수 있는 가장 효율적인 방법을 택했을 때 이루어진다.&lt;/p&gt;
&lt;h2&gt;이해가 잘 안갔던 부분들&lt;/h2&gt;
&lt;h3&gt;가치, 원칙, 실천방법&lt;/h3&gt;
&lt;p&gt;value, principles, practice 이 세가지를 항상 가슴에 품고 XP를 생각해야 한다.
하지만, 아직 이 세가지의 명확한 기준을 찾지 못했다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Test Driven Development 2]]></title><description><![CDATA[원제 Test Driven Development: by example 제목 테스트 주도 개발 저자 Kent Beck ISBN 9788966261024 독서 기간 2019-09-24, 15:00-16:00 독서 량 5장 -…]]></description><link>https://sukjae.github.io/daily-study/read-a-book/TDD-kent-beck-day2/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/read-a-book/TDD-kent-beck-day2/</guid><pubDate>Tue, 24 Sep 2019 00:00:00 GMT</pubDate><content:encoded>&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;원제&lt;/th&gt;
&lt;th&gt;Test Driven Development: by example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;제목&lt;/td&gt;
&lt;td&gt;테스트 주도 개발&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;저자&lt;/td&gt;
&lt;td&gt;Kent Beck&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ISBN&lt;/td&gt;
&lt;td&gt;9788966261024&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;독서 기간&lt;/td&gt;
&lt;td&gt;2019-09-24, 15:00-16:00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;독서 량&lt;/td&gt;
&lt;td&gt;5장 - 8장&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;이해가 잘 안갔던 부분들&lt;/h2&gt;
&lt;h3&gt;자바의 문법 (p77)&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token class-name&quot;&gt;Dollar&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt; object&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token class-name&quot;&gt;Money&lt;/span&gt; dollar&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Dollar&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; object&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; amount &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; dollar&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;amount&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 문법에서 &lt;code class=&quot;language-text&quot;&gt;amount&lt;/code&gt;는 Money의 protected property임에도 Dollar로 캐스팅 된 인스턴스에서 사용이 될 수 있음이 생소했다.&lt;/p&gt;
&lt;h2&gt;새로이 알게 된 내용들&lt;/h2&gt;
&lt;h3&gt;리펙토링의 과정 (p88)&lt;/h3&gt;
&lt;p&gt;이 부분에서 저자는 Money의 두 하위 클래스 (Dollar, Franc)의 사용이 많지 않아서 아예 없애버리고자 한다.&lt;/p&gt;
&lt;p&gt;여기서 보통의 나라면, 일단 두 클래스를 없애는 시도를 바로 하겠지만, 저자는 이러한 방식을 &lt;code class=&quot;language-text&quot;&gt;큰 단계를 밟는것&lt;/code&gt; 이라고 표현하였다.&lt;/p&gt;
&lt;p&gt;TDD를 보여주기 위해 단계적으로 어떤 방법을 거쳐야 하는지 정리해 주는데, 나는 이 부분이 단지 설명을 위한 보여주기 식 이상으로 TDD에 중요한 철학을 담고 있다고 생각한다.&lt;/p&gt;
&lt;p&gt;앞에서도 얘기가 나오지만, 설계를 통해 코드를 수정하는것이 아니라, Test를 통해 코드를 만들고, 이 Test를 수정함으로서 코드를 수정하는게 맞는 절차인듯 하다.&lt;/p&gt;
&lt;p&gt;이를 위해 저자는 어떤 가정( 하위 클래스에 대한 직접적인 참조가 적어지는게, 하위 클래스를 제거하기 위한 과정일 것이다)를 통하여 테스트를 우선 수정한다.&lt;/p&gt;
&lt;p&gt;앞으로 TDD를 수행하며 리펙토링을 하게 될 때, 내 머릿속의 설계를 바로 도입하기 보다는, 다음과 같은 절차로 진행함이 맞을것 같다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;가정(가설)을 세우고&lt;/li&gt;
&lt;li&gt;이 가정을 도달하기 위해 테스트를 수정하고&lt;/li&gt;
&lt;li&gt;이에 맞게 코드를 수정하는&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;중요한 포인트&lt;/h2&gt;
&lt;h3&gt;테스트 주기에서… (p71)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;테스트 작성, 컴파일 가능하게 하기, 실패하는지 확인하기, 실행하게 만들기 를 가능한 빠르게 진행해야 한다.&lt;/li&gt;
&lt;li&gt;그 이후 리펙토링(중복 제거)를 진행한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위 첫 4 단계를 빠르게 함으로서 새 기능이 포함되더라도, 그 결과물에 대해 잘 알고 있는 상태가 될 수 있다.&lt;/p&gt;
&lt;p&gt;빠르게 잘 아는 상태를 도달하기 위해서 어떠한 죄라도(안좋은 설계, 중복 등) 저질를 수 있는데, 설계보다 속도가 중요하기 때문이다.&lt;/p&gt;
&lt;p&gt;하지만, 적절한 시기에 적절한 설계를 해야한다. 돌아가게 만들고, 그 다음에 올바르게 만들어라&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Test Driven Development 1]]></title><description><![CDATA[원제 Test Driven Development: by example 제목 테스트 주도 개발 저자 Kent Beck ISBN 9788966261024 독서 기간 2019-09-23, 18:00-19:00 독서 량 1장 -…]]></description><link>https://sukjae.github.io/daily-study/read-a-book/TDD-kent-beck-day1/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/read-a-book/TDD-kent-beck-day1/</guid><pubDate>Mon, 23 Sep 2019 00:00:00 GMT</pubDate><content:encoded>&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;원제&lt;/th&gt;
&lt;th&gt;Test Driven Development: by example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;제목&lt;/td&gt;
&lt;td&gt;테스트 주도 개발&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;저자&lt;/td&gt;
&lt;td&gt;Kent Beck&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ISBN&lt;/td&gt;
&lt;td&gt;9788966261024&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;독서 기간&lt;/td&gt;
&lt;td&gt;2019-09-23, 18:00-19:00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;독서 량&lt;/td&gt;
&lt;td&gt;1장 - 4장&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;이해가 잘 안갔던 부분들&lt;/h2&gt;
&lt;h3&gt;동치성, 동일성, 동질성 (p62,63)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;세가지의 단어가 혼재되어 이해가 잘 안갔었음. 결국 모두 같은 의미로 사용되었다고 판단하였음&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;자바 문법을 잘 몰랐음 (p56)&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token class-name&quot;&gt;Dollar&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;times&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; multiplier&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Dollar&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;amount &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; multiplier&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;여기서 앞의 Dollar는 return값을 의미하고, 반환값으로 Dollar의 instance를 생성하여 전달한다.&lt;/p&gt;
&lt;h3&gt;int amount = 5 * 2 가 왜 중복인가? (p49)&lt;/h3&gt;
&lt;p&gt;책의 내용중에 아래와 같은 코드오 함께, 다음과 같은 문구가 나온다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token class-name&quot;&gt;Dollar&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; amount &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;여기에서 10은 다른 어딘가에서 넘어온 값이다. … 이제 5와 2가 두 곳에 존재한다. 따라서 우린 무자비하게 이 중복을 제거해야 한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;여기서 이해가 안 갔던 부분은, 위의 5 * 2가 어떤 부분에서 중복적으로 나오는지 였다.&lt;/p&gt;
&lt;p&gt;지금까지의 짐작으로는 assert하는 부분에 존재하는 결과 값 10 또한 5*2의 연산 결과임으로 중복이라 보는것 같다.&lt;/p&gt;
&lt;p&gt;그렇다면, 이 부분은 어떻게 바꿔야 하는가…
아직 잘 모르겠다.&lt;/p&gt;
&lt;h2&gt;새로이 알게 된 내용들&lt;/h2&gt;
&lt;h3&gt;Stub (p43)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;메소드의 input과 output만 적는 식으로 하여, 이 메소드가 호출되는 경우에 최소한 컴파일이 되도록 껍데기만 만들어 두는것&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;값 객체 패턴(value object pattern) (p59)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;객체를 값처럼 사용한다.&lt;/li&gt;
&lt;li&gt;객체의 인스턴스 변수가 생성자를 통해서 일단 설정된 후에는 결코 변하지 않도록 한다.&lt;/li&gt;
&lt;li&gt;독립된 값을 갖음을 보장한다. (어찌보면, private과 같은 느낌, 그러나 값이 변할 수 없는 의미에서 const와도 비슷한 느낌)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;TDD에서의 삼각측량&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;책에서 이 부분에 대한 설명은 매우 부족했다. 뒷 부분에 다뤄질지 모르지만, TDD의 핵심 전략임에도 앞에서 다뤄지는 내용이 너무 적었다.&lt;/li&gt;
&lt;li&gt;이 부분에 대해서 다른 블로그들을 검색하였고, 그 중에서 가장 그럴사한 내용을 정리하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Indirect measurement: Derive the design from few known examples of its desired external behavior by looking at what varies in these examples and making this variability into something more general&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Using at least two sources of information: start with the simplest possible implementation and make it more general only when you have two or more examples&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://feelings-erased.blogspot.com/2013/03/the-two-main-techniques-in-test-driven.html#targetText=Kent%20describes%20triangulation%20as%20the,the%20position%20of%20a%20unit.&quot;&gt;출처:feelings-erased&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;위 내용들로 내가 받은 느낌은 다음과 같다.&lt;/p&gt;
&lt;p&gt;테스트를 작성해야 하는데, 명확한(일반적인) 테스트 케이스와 구현해야 할 모델이 명확히 보이지 않을때 주로 사용하는것 같다.&lt;/p&gt;
&lt;p&gt;모델의 잘 알려진 일반적인 결과들(예를 들어, 1+1은 2임을 많이들 안다)을 통하여 간접적으로 보다 일반적인 모델을 찾아가는 과정인것 같다.&lt;/p&gt;
&lt;p&gt;또, 이를 위해서 하나의 큰 일반적인 사실만을 사용하는게 아니라, 가장 작은 단위의 정보들(일반적인 결과들)을 두개 이상 조합하여 일반적인 모델과 테스트 케이스를 만드는것을 목표로 하는듯 하다.&lt;/p&gt;
&lt;h2&gt;중요한 포인트&lt;/h2&gt;
&lt;h3&gt;TDD의 리듬 (p39)&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;재빨리 테스트를 하나 추가한다.&lt;/li&gt;
&lt;li&gt;모든 테스트를 실행하고 새로 추가한 것이 실패하는지 확인한다.&lt;/li&gt;
&lt;li&gt;코드를 조금 바꾼다.&lt;/li&gt;
&lt;li&gt;모든 테스트를 실행하고 전부 성공하는지 확인한다.&lt;/li&gt;
&lt;li&gt;리펙토링을 통해 중복을 제거한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;천재와 멍청이 사이에 존재하는 우리에게 필요한 단순한 법칙 (p37)&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;어떤 코드건 작성하기 전에 실패하는 자동화된 테스트를 작성하라.&lt;/li&gt;
&lt;li&gt;중복을 제거하라.&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 맴버쉽 28]]></title><description><![CDATA[Kubernetes 삽질기 2 구상중인 k8s + AWS 인프라 구성 v1  햇갈리는 부분 정리 K8s에 쓰일 docker image는 어느 레벨까지 dockerlize가 되어야 할까 드는 생각들은, os위에 node, 그리고 그 위에 Express…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-membership/28/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-membership/28/</guid><pubDate>Sun, 22 Sep 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;Kubernetes 삽질기 2&lt;/h2&gt;
&lt;h2&gt;구상중인 k8s + AWS 인프라 구성 v1&lt;/h2&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/daily-study/static/c873dff1aec1397af8353e0d34ae0e7c/d69c4/pole-infra-v1.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 73.64864864864865%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAADOElEQVQ4y41UeUhTcRz/vG0+55y6rV0q6TLLFiYddFBUFBV0UEaFdEAEneukg4yCooOKwi47DHVzOufUtbTD/knwj6ggKqKbkooKJNQoInPb+/Z9m+uyoB/vw/f3vu/z+7zv9R4A5DCUf4PyH37h7352QwOotX0QoHxU0UZ4aTWqaU0PHLJVsDX6yWG9QA6TP+LrDQ/zvbQBLikfSDZbUUnX+aYbzmAnnKGPcIU/oYI62XYoKqR2S43UnlkXtYJLakcvhD8w/yvKuhrkOE34ueLw59rbzhTizTLGJEA7Hoa8icDcU+CowGLAxoae02pOXaUxa/00R1/WuVtV3jWCSYNNVV07NWfbVuI/1zFfc2zLL483W3Q+akzzE6nlOjqlxXkXpS+pPqkZC92pcW7JwiVJSoseUHMKakSBFD+pYkpTiKMdvywOiljKqx5F0hVqyIj9jybg/NdMnPk4xlYXvqKrpwVyJ+Nyp9hQUGRQ9h/dTwc+WkuWhEqpXlcttXANV8TEI4JZe64pIndOaZu+kSi+IvQcsw/pf8lMxKm2QrO3O4CjrzZHPDVk0VRJzQav9IwFHVGaUjQRh9v/9LNoQzyUiiOvpqL027Atchr2hwp0kACtVbteQPpaAYOXaIS+EW4TpbDgLRZ8y4KbYm82/FZhFy03VQc7Ej3SRRx4OdTolZ5a66gDe+7PuDon/9yNdVvfuecvKcH+B7m6ohcjxYpQbZKHbsBNy6NtmX8gt2+A9qb6wkU8Uxn8IM/gCe5LKH7vQOGt9LSa0PqMAG3HomO5KYceFA+qDd7RHH580F76erfe9XlhYmWo2egNt3Igq6IZr3SOsTfSbe7sYx7icb8GmyLX7edSiyWdgcxL9EVZ3OaWHaqblIwnJGZcprWZftoVpS11jrVdoHvZ9eEXKAlGBJOL34i6JlJgx12kFTaoZhHJDRM1x1vLB/q6WsUjz0/KvPgW0mN6od3oKJuX7u0eB8HOg11weojtEp3IDlApD3XOv4ZXkC9zdo5gzpoM68CsH37rgGw2w+V9wcxp8jDB1vO3ELnNSfz5yKOi6w2BK4BERgJDC0Eh+2WuRqFUWgWlahTvR30HYfNZGbyh39YAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;pole infra v1&quot;
        title=&quot;pole infra v1&quot;
        src=&quot;/daily-study/static/c873dff1aec1397af8353e0d34ae0e7c/fcda8/pole-infra-v1.png&quot;
        srcset=&quot;/daily-study/static/c873dff1aec1397af8353e0d34ae0e7c/12f09/pole-infra-v1.png 148w,
/daily-study/static/c873dff1aec1397af8353e0d34ae0e7c/e4a3f/pole-infra-v1.png 295w,
/daily-study/static/c873dff1aec1397af8353e0d34ae0e7c/fcda8/pole-infra-v1.png 590w,
/daily-study/static/c873dff1aec1397af8353e0d34ae0e7c/efc66/pole-infra-v1.png 885w,
/daily-study/static/c873dff1aec1397af8353e0d34ae0e7c/d69c4/pole-infra-v1.png 1002w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;햇갈리는 부분 정리&lt;/h2&gt;
&lt;h2&gt;K8s에 쓰일 docker image는 어느 레벨까지 dockerlize가 되어야 할까&lt;/h2&gt;
&lt;p&gt;드는 생각들은, os위에 node, 그리고 그 위에 Express App이 올라가게 된다.&lt;/p&gt;
&lt;p&gt;이 과정에서 우리는&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;node 까지의 서버를 dockerlize할 수 있고,&lt;/li&gt;
&lt;li&gt;express app까지 모두 dockerlize할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;둘간의 장단점이 보이기는 하지만, 어떤 선택지가 최적인지는 감이 오지 않는다.&lt;/p&gt;
&lt;p&gt;1번 방식의 경우에는, os/node 의 버전이 업그레이드 되거나, 설치해야 할 도구들이 있을 경우만 image가 빌드되는 형태로 생각된다. 그 이후 express app은 aws의 EFS과 같은 방식으로 하나의 폴더를 여러 instance가 공유하거나, s3에서 ebs로 하나씩 옮겨서(copy) 서비스 하는 방식이 떠오른다. 어차피, 운영중에 사용자에 의해 서비스의 코드가 변하지 않을 것이다.&lt;/p&gt;
&lt;p&gt;예상되는 장단점은 다음과 같다&lt;/p&gt;
&lt;p&gt;장점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;image build를 매번할 필요가 없다&lt;/li&gt;
&lt;li&gt;production과 dev(local) 환경의 통일이 용이할듯 하다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;단점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;두가지 환경을 모두 관리해야 한다. 1) image 저장소, 2) 소스 코드 저장소&lt;/li&gt;
&lt;li&gt;배포에 부가적인 작업이 동반된다 (복사, 등)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;두 방법중에, 1번 방법이 현재로 나에게 가장 적합한듯한 이유는, dev환경에서의 k8s &amp;#x26; docker 를 이용한 서비스 개발이 어떻게 진행되어야 하는지 감이 안오기 때문이다.&lt;/p&gt;
&lt;p&gt;production의 상황에서는 k8s가 build된 image를 pull해서 인프라를 구성하는데, local dev 환경에서 해당 k8s 파일로 provision하면, 최신 image만 사용되기 때문에 추가적으로 해당 image를 수정하기 위해 어떤 작업이 동반되어야 하는지 감이 안온다.&lt;/p&gt;
&lt;p&gt;어떤 image를 수정하기 위해서는 우리가 local에서 개발하는 경험처럼 source code를 바꾸고 실행시키는 빠른 feedback이 필요한데 보통의 k8s의 경우에는 source code 변경 → image build → image push → image pull → provision의 과정이 매번 동반될 것 같기 때문이다. 우리가 local에서 hot reload와 같은 방식이 어려워지게 되고, 이는 개발 경험에 치명적인 영향을 끼칠것이다. (express app에 대한 소스코드가 살짝만 바뀌어도, 위 작업이 모두 동반되어야 하므로…)&lt;/p&gt;
&lt;p&gt;가장 이상적인 환경은, express까지 image화 하여 k8s에서는 ECR에서 받아 provision만 하면 되는 상황일 것이다.
이 프로세스는 원격에서는 어느정도 잡혀져 있지만, 로컬에서는 어떻게 되어야 하는지 알아보는 중이다.&lt;/p&gt;
&lt;p&gt;⇒ 이 부분에 대해 현재는 2번의 방법을 유지하면서 minikube + &lt;code class=&quot;language-text&quot;&gt;eval $(minikube docker-env)&lt;/code&gt; 조합으로 알아보고 있는 중이다. 이 방법을 사용하게 되면, 원격의 이미지 저장소로 push pull 과정 없이 local에서 build한 image를 k8s에서 그대로 사용할 수 있을것으로 기대된다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 맴버쉽 27]]></title><description><![CDATA[…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-membership/27/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-membership/27/</guid><pubDate>Sat, 21 Sep 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;각&lt;/h2&gt;
&lt;p&gt;각을 재는 일은 항상 어렵다. 이 일이 내가 예상한 시간내에 진행할 수 있는가를 미리 알 수 있다면 가장 좋지만 현실적으로 어렵다.
따라서, 일을 진행하며 이 작업이 시간내에 끝낼 “각” 인가를 매 순간 판단해야 하는데 나는 그 판단을 빠르게 내리지 못했다. 아마도 새로운 기술을 접하며 내가 알고 있는 지식과 실제 작업에 큰 차이가 있어서 그랬던것 같다. 일을 수행하면 조금만 더 가면 될거 같지만, 사실 저 멀리 존재하는 신기루 같은 작업도 있다. 이번에 내가 전체 인프라를 코드로 관리하기 위해 AWS CDK를 수행한것이 그런 느낌이였다. AWS라는 미지의 세계를 탐험하며 작업을 하는데, 시간내에 결과물을 내야 하는 이번 미션과 적절하지 못했다.&lt;/p&gt;
&lt;p&gt;회사생활을 하면서도 이 교훈을 잊지 않으려 한다. 회사 생활은 나 혼자 하는 일이 아닌, 누군가 함께 하는 일이다. 동료와 맺은 약속은 내 개인적인 코드의 가치보다 우선시 되어야 한다고 생각한다. 그렇게 해야 한 팀으로서 앞으로 나아갈 수 있을 것이다. 작업의 시한과 결과에 대한 약속을 꼭 지킬 수 있도록 항상 학습하고, 시도하며 연습해 봐야 할 것이다. 그러면서 익숙한 도구를 바탕으로 작업을 수행하고, 추후 더 발전된 형태로 다시 작성하는 점진적 발전을 잊지 말자.&lt;/p&gt;
&lt;p&gt;오늘은 도저히 시간내에 끝낼 수 없을 것 같아 늦었지만 팀원들에게 양해를 구하고 원래 하던 작업(프런트 엔드)로 돌아왔다. 이주 가량의 시간동안 성과를 내지 못해 팀원들에게 미안한 마음이 크며, 남은 시간 동안이라도 최대한 집중하여 의미있는 결과물에 도달하고 싶다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 맴버쉽 26]]></title><description><![CDATA[왜 성과를 내지 못했을까 한정된 시간속에서 주어진 과제를 수행하기 위해 최선을 다해야 한다. 이번 프로젝트 6~…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-membership/26/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-membership/26/</guid><pubDate>Fri, 20 Sep 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;왜 성과를 내지 못했을까&lt;/h2&gt;
&lt;p&gt;한정된 시간속에서 주어진 과제를 수행하기 위해 최선을 다해야 한다. 이번 프로젝트 6~7주차 동안에도 매 순간 최선을 다하고자 하였지만, 쉽지 않았다.
그럼에도 계속해서 시간을 투자하였으나, 성과가 없었다. 성과가 없으니 계속해서 답답함이 밀려오고, 작업이 미루어지면서, 그러한 작업이 쌓이고 쌓여 너무 큰 산이 되버렸다.&lt;/p&gt;
&lt;p&gt;그렇다고 이 기간동안 아무것도 안한것은 아니다. 조금이라도 작업을 하고자 일주일 내내 부스트 캠프에 왔고, 뭐라도 들여다 보곤 했다. 계속해서 머릿속으로 구상하고, 내가 알고 있는 내용을 검증해가며 나아가고자 했지만 쉽지 않다.&lt;/p&gt;
&lt;p&gt;이번 성과없는 작업의 연속은 내 방식이 잘못되었거나, 내 예측이 잘못되었거나 둘중에 하나의 문제 인것 같다.&lt;/p&gt;
&lt;p&gt;항상 무언가를 작업할떄, 제대로 알고 작업하고 싶다는 마음이 강하다. 내가 생각하는 최적의 답이 있으면, 그 답과 근사한 결과물을 만들고 싶고, 내가 내린 결론과 근사한 방법을 찾거나 구현하기 위해 노력한다. 여기서 문제는, 그 방법을 찾거나 알아가는 과정에 너무 많은 시간이 소요된다는 점이다.&lt;/p&gt;
&lt;p&gt;이번 과제의 경우에 우리 팀은 현재 CI/CD가 어느정도 구축되어 있는 상태였다. 그럼에도 나는 이번 프로젝트 동안 가져가고 싶은 한가지로서 인프라를 정했고, 그것을 취하기 위해서 내가 내린 최적의 방법을 구현하기 위해 내 방식대로 다시 만들기로 결정하였고, 팀원들을 설득하였다.
CI/CD와 관련하여 내 개인적으로 내린 결론이 있었고, (Docker, Ochastration 도구, CI/CD 파이프 라인 등) 그 결론에 도달하기 위해 간단하게만 알고 있던 부분들을 하나씩 파고 들었다. 그러나 대부분 기본적인 내용만 알고 있었고, 생소하여 그 기술들을 익히는데 너무 많은 시간이 소요되었다. 그래서 약속하였던 1주일의 시간을 지키지 못하였고, 이 작업은 현재도 계속 진행중이다. 실제로 코드를 작성하기 시작한게 2~3일 정도 된것을 고려하면 내가 모르는 지식을 채우기 위해 대략 1주일 가량을 소요한 셈이다.&lt;/p&gt;
&lt;p&gt;늦었지만, 지금과 같이 단기간 결과물을 내야 하는 프로젝트에서 이러한 접근 방법이 적절하지 않았을 수 있겠다는 생각을 하게 되었다.
어쩌면, 기술적인 나의 이상향을 어느정도 타협을 봤어야 하는것은 아닐까? 내 현 수준과 맞지 않은, 오르기 너무 힘든 산을 고른건 아닌가 싶다.&lt;/p&gt;
&lt;p&gt;아니면 내가 기술 구현에 대한 시간 소요를 제대로 측정하지 못한것에서 온 문제일 수 있다. 나는 처음 작업을 시작할 때, 이미 모든게 잘 갖추어져 있을것이라 가정하였고 그래서 작업 시간은 5일정도로 고려하였다. 그러나 작업을 하면 할수록 해야할 것들이 늘어갔고, 배워야할 것들도 늘어났다. 위와 같은 결론이지만, 결국 내가 시간내에 끝낼 수 없는 작업을 시작한건 아닌가 싶다.&lt;/p&gt;
&lt;p&gt;그렇다면, 미래에 있을 또 다른 프로젝트에서 이러한 시행착오를 반복하지 않기 위해서 어떻게 해야할까. 개인적으로 내린 결론은 다음과 같다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;유사한 경험을 많이 만들어서 소요 시간 측정에 대한 정확도를 높이자&lt;/li&gt;
&lt;li&gt;멘탈을 부여잡고 천천히 점진적으로 쌓아가자.&lt;/li&gt;
&lt;li&gt;계속해서 팀원과 소통하자&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;특히 3번에 대해서 어제 오늘 중요함을 많이 느끼게 되었다. 소통을 통해 작업에 걸리는 시간을 매우 단축시킬 수 있다. 신기하게도 혼자 끙끙대는 문제들이 남에게 설명 하는것 만으로도 정리가 되고, 해결되기도 한다는 점이다. 또한 보통 작업이 막힐때는 다른 시야에서 바라봐줄 동료가 필요하다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 맴버쉽 25]]></title><description><![CDATA[Kubernetes 삽질기 1 햇갈리는 부분 정리 약 결함 k8s 는 loosely coupled 되어 있다. 오로지 라벨 만으로 템플릿을 확인하여, 작업된다. Rolling update 새로운 pod 띄우고, 기존 pod…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-membership/25/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-membership/25/</guid><pubDate>Thu, 19 Sep 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;Kubernetes 삽질기 1&lt;/h2&gt;
&lt;h2&gt;햇갈리는 부분 정리&lt;/h2&gt;
&lt;h3&gt;약 결함&lt;/h3&gt;
&lt;p&gt;k8s 는 loosely coupled 되어 있다. 오로지 라벨 만으로 템플릿을 확인하여, 작업된다.&lt;/p&gt;
&lt;h3&gt;Rolling update&lt;/h3&gt;
&lt;p&gt;새로운 pod 띄우고, 기존 pod 바꾸고… 반복한다.&lt;/p&gt;
&lt;p&gt;실제로는 현재 pod가 존재하는 replica set을 그대로 하나 더 생성하여 옮기고 삭제하는 작업이 진행된다.&lt;/p&gt;
&lt;p&gt;문제는, 이미 새로운 replica set으로 다 옮겨진 이후에는, 기존의 것으로 바꿔치기가 어렵다. (이미 삭제 되었으므로)&lt;/p&gt;
&lt;h2&gt;yaml, 어떻게 작성할까&lt;/h2&gt;
&lt;p&gt;k8s에서는 object라고 불린다.&lt;/p&gt;
&lt;p&gt;참고: &lt;a href=&quot;https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/&quot;&gt;https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Kubernetes Objects are persistent entities in the Kubernetes system.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;A Kubernetes object is a “record of intent”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;object’s configuration에서는 두가지 요소가 존재한다: spec, status&lt;/p&gt;
&lt;p&gt;spec은 desired state for the object&lt;/p&gt;
&lt;p&gt;status는 actual state of the object&lt;/p&gt;
&lt;h3&gt;구성 요소&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;apiVersion&lt;/code&gt; - Which version of the Kubernetes API you’re using to create this object&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;kind&lt;/code&gt; - What kind of object you want to create&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;metadata&lt;/code&gt; - Data that helps uniquely identify the object, including a &lt;code class=&quot;language-text&quot;&gt;name&lt;/code&gt; string, &lt;code class=&quot;language-text&quot;&gt;UID&lt;/code&gt;, and optional &lt;code class=&quot;language-text&quot;&gt;namespace&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;spec&lt;/code&gt; - What state you desire for the object&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;production cluster와 dev cluster를 어떻게 동기화 할까&lt;/h2&gt;
&lt;p&gt;ㅇㅋ 이제 production cluster를 어떻게 구성해야 하는지 감이 오기 시작했다.&lt;/p&gt;
&lt;p&gt;그러나, 이 구성을 어떻게 다른 동료 개발자들이 사용할 수 있게 도움이 되는 도구로 만들것인지는 또 다른 얘기다.&lt;/p&gt;
&lt;p&gt;가장 큰 문제는, 배포된 k8s 인프라를 어떻게 개발에 활용하는가 이다.&lt;/p&gt;
&lt;p&gt;물론, 이미 배포된 k8s api를 연결하여 개발 하는것은 말도 안되는 일이다.&lt;/p&gt;
&lt;p&gt;이를 위해 상상해 볼 수 있는 것들은 다음과 같다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;현재 prod의 인프라 구성과 동일한 구성을 그대로 복붙하여 dev 환경을 따로 만들고, 그 api에 연결하여 새로운 기능을 개발한다&lt;/li&gt;
&lt;li&gt;현재 prod의 인프라 구성과 동일한 구성을 그대로 복붙하여 개발자당 하나의 개별 dev 환경을 만든다&lt;/li&gt;
&lt;li&gt;현재 prod의 인프라 구성에 대한 명세를 로컬에서 그대로 실행시켜 인프라를 구축하낟.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;1, 2번에 대해…&lt;/h3&gt;
&lt;p&gt;k8s는 label에 붙은 name이나 주어진 ip 로 cluster 내에서 통신한다.&lt;/p&gt;
&lt;p&gt;물론, 이 값들은 cluster내에서만 유효하기 때문에, 외부에서 이 값으로 바로 접근이 안된다.&lt;/p&gt;
&lt;p&gt;서비스를 개발하며, 로컬에서 계속해서 서버도 껏다 키고 http요청을 보내기도 해야 하는데, prod에서 사용될 주소 규칙이 아닌, 외부에서 사용하는 규칙(api)을 사용하여 개발하면 그 값을 다시 바꿔야 하는 문제가 있다.&lt;/p&gt;
&lt;p&gt;물론, 그 값을 환경변수로서 dev/prod 에 따라 다른값을 넣도록 할 수 도 있지만 그 방법 또한 무언가 어색함이 있다.&lt;/p&gt;
&lt;p&gt;또 다른 문제로는, 새로운 기능이 아닌 특정 기능을 수정해야 할 경우이다.&lt;/p&gt;
&lt;p&gt;이미 인프라가 올라가 있고, 그 인프라의 api에 포함되어있는 기능을 수정하여 테스트를 하기 위해서는 무언가 어색한 작업들이 분명 동반될 것이다.&lt;/p&gt;
&lt;p&gt;그럼에도 인프라 관리자의 입장에서는 일단 구현하기 가장 쉬운 방법이다.&lt;/p&gt;
&lt;p&gt;결론적으로…&lt;/p&gt;
&lt;p&gt;staging 단계의 인프라 하나는 필요할 듯 하지만, 개발자를 위해 1개 이상의 dev 인프라를 클라우드에 구축할 필요는 없어 보인다.&lt;/p&gt;
&lt;h3&gt;3번에 대해 …&lt;/h3&gt;
&lt;p&gt;가장 이상적인 방법이지만, 그 방법이 명확히 그려지지 않는다.&lt;/p&gt;
&lt;p&gt;일단, k8s와 docker의 특성상 어느 환경에서도 인프라 전체가 구축됨은 맞다. 그러나 몇가지 어색한? 이해가 가지 않는? 부분들이 존재한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;k8s를 AWS에서 사용하게 되면, k8s의 인터페이스를 통해 AWS에서 제공하는 다양한 리소스를 사용하게 된다. 아무리 k8s가 제공하는 인터페이스를 따라 어느 환경에서도 구성이 된다 하지만, 그 결과가 동일할까?&lt;/li&gt;
&lt;li&gt;그냥 kubectl로 하면 되나? 그러면 minikube 같은 도구는 왜 있는거지?&lt;/li&gt;
&lt;li&gt;AWS에서 제공하는 DB나, EBS, EFS같은 도구를 사용하게 된다면 로컬에서 이 환경을 어떻게 동일하게 구축할 수 있을까? 호스트의 PS를 활용해야 하나?&lt;/li&gt;
&lt;li&gt;만약 EKS를 쓰거나, kops를 쓸 경우 master 는 어떻게 작동되나? 결국 우리가 개발하는 앱은 워커 노드에 들어갈텐데… 마스터 또한 프로비전 되어야 하나&lt;/li&gt;
&lt;li&gt;앱에서 사용되는 모든 쿠버 스타일 API는 어떻게 작성/관리 되어야 하는가… swagger?&lt;/li&gt;
&lt;li&gt;RBAC 가 필요한데, 로컬과 클라우드가 다르면 어떻게 작동해야 할까&lt;/li&gt;
&lt;li&gt;AWS에서 제공하는 DB나, EBS, EFS같은 도구를 사용하게 된다면 로컬에서 이 환경을 어떻게 동일하게 구축할 수 있을까? 호스트의 PS를 활용해야 하나?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;설정을 Runtime에서 바꿔치기 하는 방법도 존재하는 듯 하다.&lt;/p&gt;
&lt;p&gt;service-overrides가 있고, 값이 바꿔치기 된다.&lt;/p&gt;
&lt;p&gt;어떤 파일을 두어 로컬에서 바꿔치는 방법도 있고,&lt;/p&gt;
&lt;p&gt;helm을 활용하는 방법도 있을 것 같다.&lt;/p&gt;
&lt;p&gt;몇가지 보이는 방향들이 있다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 맴버쉽 24]]></title><description><![CDATA[Socket.IO 삽질기 2 부스트 캠프 프로젝트 중에 채팅 기능을 구현해야 했고, 그 기술로 웹소켓을 선정하였다. 
개인적으로 두가지 후보를 고민하였는데, 하나는 AWS의 api gateway에서 제공하는 websocket…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-membership/24/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-membership/24/</guid><pubDate>Wed, 18 Sep 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;Socket.IO 삽질기 2&lt;/h2&gt;
&lt;p&gt;부스트 캠프 프로젝트 중에 채팅 기능을 구현해야 했고, 그 기술로 웹소켓을 선정하였다.
개인적으로 두가지 후보를 고민하였는데, 하나는 AWS의 api gateway에서 제공하는 websocket이고, 다른 하나는 socket.io였다. &lt;/p&gt;
&lt;p&gt;전자는 서버리스라는 매력 때문에 사용해보고 싶었고, 후자는 Node를 사용하는 현 상황에서 적합해 보였다. &lt;/p&gt;
&lt;p&gt;결국 Socket.IO를 사용하게 되었고, 그 과정에서 개인적으로 느낀점들을 적어본다. &lt;/p&gt;
&lt;h2&gt;Socket.IO에서 namespace와 room의 차이&lt;/h2&gt;
&lt;p&gt;처음에 들었던 느낌은, namespace라는 prefix와 같은 것이 존재하고, 그 내부에 room을 둘 수 있는 구조라 생각했엇다.
그래서, 직감적으로 들었던 생각들은, namespace를 &lt;code class=&quot;language-text&quot;&gt;/chat&lt;/code&gt;으로 두고, 그 이후에 &lt;code class=&quot;language-text&quot;&gt;roomId&lt;/code&gt;를 room으로 둠으로서 두 유저간의 private chat을 구현할 수 있지 않을까 생각하였다. &lt;/p&gt;
&lt;p&gt;둘이 항상 같이 쓰일 것이라 생각하였지만, namespace와 room은 쓰이는 용도에서 차이가 있었다. (사실 항상 같이 쓰이긴 한다)&lt;/p&gt;
&lt;p&gt;작성된지 조금 지난 글이지만, 둘의 차이를 어느정도 짐작할 수 있는 글이 있다 .&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/a/11751954/5755608&quot;&gt;socket.io rooms or namespacing?, 2015&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이 내용을 정리하면 다음과 같다 .&lt;/p&gt;
&lt;h3&gt;공통점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;둘 모두 서버에서 생성된다&lt;/li&gt;
&lt;li&gt;복수의 namespace와 복수의 room은 같은 connection 위에 존재한다&lt;/li&gt;
&lt;li&gt;해당 namespace/room에 연결된 사용자에 한해서만 메세지가 전달된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;namespaces 의 특징&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;client에서(사용자에 의해) 연결이 시작된다&lt;/li&gt;
&lt;li&gt;사용자는 서버에서 namespace가 이미 존재한 경우에만 연결할 수 있다.&lt;/li&gt;
&lt;li&gt;auth 관련 기능을 사용할 수 있다&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;room의 특징&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;서버쪽에서만 연결할 수 있다. &lt;/li&gt;
&lt;li&gt;namespace에 속해있다. (global)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 내용속에서 내가 가져갈 중요한 정보는, namespace는 client, room은 server 측에서 연결이 이루어진다는 것이다. &lt;/p&gt;
&lt;h2&gt;연결을 동적으로 만들 수 없을까&lt;/h2&gt;
&lt;p&gt;나의 첫 아이디어는, (유저(구매자) + 유저(판매자) + 상품) 를 통하여 채팅ID를 생성하고, 그 채팅Id를 room 으로서 사용하려 하였다. &lt;/p&gt;
&lt;p&gt;namespace는 일단은 chat을 두었는데, 채팅 ID는 사용자가 만들기 전까지 알 수 없었다.
모든 가능성을 다 만들어 두고 하드코딩 할 수 없는 노릇이고, 이를 동적으로 만들 방법이 필요하였다 &lt;/p&gt;
&lt;p&gt;그 해결법이 잘 보이지 않았는데, 그 이유는 namespace/room 모두 string 형태로 하드코딩 하여 이벤트를 등록하는 형태였다.
바보같지만, 처음에는 하드코딩되어 있으므로 그 부분을 변수로 치환할 생각을 못하고 서버 코드를 작성시 무조건 지정해 주어야 하는지 알았다. &lt;/p&gt;
&lt;p&gt;이 부분은 반은 맞고 반은 틀렸는데, 그 이유는 namespace의 경우는 생각한것 처럼 처음 생성시 string 형태로 지정해 줘야 하는 반면,
room의 경우에는 약간의 트릭을 가미하면 동적으로 string을 전달할 수 있었다. &lt;/p&gt;
&lt;p&gt;즉, 사용자에게 어떤 값을 받거나, 서버측에서 추가적으로 값을 생성하여 room의 string을 대체할 수 있었다. &lt;/p&gt;
&lt;p&gt;간단한 방법이지만, 이 방법을 찾기까지 시간이 많이 걸렸다. 그 이유는 이러한 방식이 생소했기 때문도 있는것 같다.
결론적으로, 다음과 같은 스타일로 작성해 볼 수 있다. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// # 서버&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// namespace : chat 생성&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; chatIO &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; io&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;/chat&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// 일단은 chat으로 연결을 함&lt;/span&gt;
chatIO&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;connection&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 연결한 뒤, 사용자로 부터 emit을 받아서 입장&lt;/span&gt;
  socket&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;enterRoom&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;roomId&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 기존의 socket에 leave하는 부분은 일단 생략&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 사용자가 emit한 정보에 포함되어 있는 roomId를 토대로 room을 생성 및 등록&lt;/span&gt;
    socket&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;roomId&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token comment&quot;&gt;// 여기서 사용자가 message를 emit하면, 아래 callback이 실행&lt;/span&gt;
    socket&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;message&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;// 이 부분이 중요&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;// 사용자 중에서 chat/roomId에 연결고리를 갖는 사용자에 한해서&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;// 전달 받았던 메세지를 돌려 보냄&lt;/span&gt;
      chatIO&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;roomId&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;emit&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;message&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; msg&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// # 클라이언트&lt;/span&gt;
socket&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;socketIOClient&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;http://localhost:5000/chat&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
socket&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;emit&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;enterRoom&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; roomId&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;코드를 살펴보면, 굉장히 난해하다…
일단 위에서 말했듯이, &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;namespace는 정적으로만 생성 가능하다&lt;/li&gt;
&lt;li&gt;room은 동적으로 생성이 가능하다. (존재하는 sockets에 join하는 방법이다)&lt;/li&gt;
&lt;li&gt;사용자는 namespace에 연결을 시도할 수 있다&lt;/li&gt;
&lt;li&gt;사용자는 room에 연결을 시도할 수 없다&lt;/li&gt;
&lt;li&gt;room은 오로지 서버에서 연결을 시도할 수 있다&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;3~5번의 내용을 바탕으로 위 코드를 본다면, 편법이 보인다. &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;사용자는 클라이언트에서 일단 chat(namespace)에 연결하고&lt;/li&gt;
&lt;li&gt;enterRoom에 roomId를 emit하고&lt;/li&gt;
&lt;li&gt;서버는 사용자가 emit한 enterRoom에서 roomId를 전달받아서&lt;/li&gt;
&lt;li&gt;동적으로 socket에 room을 등록한다&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;마지막으로 중요한 특징이 있는데, &lt;a href=&quot;https://stackoverflow.com/a/30442764/5755608&quot;&gt;참고&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;클라이언트에서는
namespace의 경우에는 emit을 할 수 있는 반면,
room의 경우에는 특정 room으로 emit할 수 없다&lt;/p&gt;
&lt;p&gt;서버에서는
namespace,room 을 갖는 유저 모두에게 emit할 수 있다.&lt;/p&gt;
&lt;h2&gt;socket.io에서 인증은 어떻게?&lt;/h2&gt;
&lt;p&gt;일단 connection을 하기 위한 인증은 &lt;a href=&quot;https://socket.io/docs/migrating-from-0-9/#Authentication-differences&quot;&gt;공식문서&lt;/a&gt;에서도 나와있다. &lt;/p&gt;
&lt;p&gt;socket.io는 middleware를 제공하며, io connection 이전에 유저의 auth를 확인하는 로직을 넣어주면 된다. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;io&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;use&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;socket&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; next&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; handshakeData &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; socket&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;request&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// make sure the handshake data looks good as before&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// if error do this:&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// next(new Error(&apos;not authorized&apos;));&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// else just call next&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이 부분에서, JWT와 같은 방식을 사용해 유저의 기본적인 AuthN을 확인할 수 있다. &lt;/p&gt;
&lt;p&gt;또, 이 &lt;code class=&quot;language-text&quot;&gt;io.use&lt;/code&gt; 를 활용하여, 각가의 namespace 이전에도 별도의 로직을(middleware를) 넣을 수 있으니, 그 활용법이 다양하다. &lt;/p&gt;
&lt;h2&gt;그렇다면 권한은?&lt;/h2&gt;
&lt;p&gt;문제는 AuthZ이다. &lt;/p&gt;
&lt;p&gt;일차적으로 사용자 인증정보를 확인하여 connection을 만들어 주었으나, 우리의 채팅 서비스의 경우에는 판매자/구매자 만이 해당 채팅방에 들어갈 권리를 가져야 한다.
아무런 방어책도 없는 상황에서는 roomId만 안다면 누구나 chat 에 들어갈 수 있으므로 적합하지 않다. &lt;/p&gt;
&lt;p&gt;이 방법에 대해서는 아직 그 해결법을 찾고 있는 중이지만, 세가지 방법이 있을 것 같다. 물론, 비효율적인 방법이 포함되어 있으므로 이해 바란다.(일단 선 구현!)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;매 요청마다 비동기적으로 roomId를 DB에서 조회하여 판매자/구매자 ID를 받아오고 요청과 비교한다&lt;/li&gt;
&lt;li&gt;사용자가 enterRoom을 하는 최초의 순간에만 비동기적으로 roomId를 DB에서 조회하여 판매자/구매자 ID를 받아오고 요청과 비교한다&lt;/li&gt;
&lt;li&gt;사용자가 채탕방에 입장하는 순간(재입장 포함) 클라이언트로 oauth 토큰이 발급되고, 그 토큰안에는 roomId가 포함되어 있어 매 요청마다 권한을 확인한다&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;첫번째 방법은, 서버에 너무 부담이 크다. 물론 구현은 너무 쉽다… 하지만 패스!&lt;/p&gt;
&lt;p&gt;두번째 방법은 괜찮은 방법인듯 하고, 어느정도 최소한의 보안적인 측면을 만족하는 듯 하다.
이 과정을 위해서는 보안적인 소켓 통신이 필요하고 &lt;a href=&quot;https://stackoverflow.com/a/6601067&quot;&gt;다음과 같은 세팅을 할 수 있다.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;마지막 방법은 토큰의 만료시간이 존재한다는 점에서 두번째 보다는 조금 더 나은것 같기도 하다. 그러나, 별도의 OAuth 시스템을 구축해야 하고, 매 요청마다 검증을 해야 하므로 까다로운 방법이다. 과연 그 노력대비 얻는 부수 효과가 어느정도 일지 고민이다. &lt;/p&gt;
&lt;p&gt;일단 세가지 옵션중에서 잠재적으로 두번째 옵션을 선택하였다. 이 부분은 차차 더 고민하도록 한다. &lt;/p&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 맴버쉽 23]]></title><description><![CDATA[부스트 캠프 프로젝트 중에 채팅 기능을 구현해야 했고, 그 기술로 웹소켓을 선정하였다.
개인적으로 두가지 후보를 고민하였는데, 하나는 AWS의 api gateway에서 제공하는 websocket이고, 다른 하나는 socket.io…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-membership/23/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-membership/23/</guid><pubDate>Tue, 17 Sep 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;부스트 캠프 프로젝트 중에 채팅 기능을 구현해야 했고, 그 기술로 웹소켓을 선정하였다.
개인적으로 두가지 후보를 고민하였는데, 하나는 AWS의 api gateway에서 제공하는 websocket이고, 다른 하나는 socket.io였다.&lt;/p&gt;
&lt;p&gt;전자는 서버리스라는 매력 때문에 사용해보고 싶었고, 후자는 Node를 사용하는 현 상황에서 적합해 보였다.&lt;/p&gt;
&lt;p&gt;결국 Socket.IO를 사용하게 되었고, 그 과정에서 개인적으로 느낀점들을 적어본다.&lt;/p&gt;
&lt;h2&gt;Socket.IO는 websocket의 구현이 아니다?&lt;/h2&gt;
&lt;p&gt;웹소켓을 편리하게 이용하기 위해 socket.io를 사용하려 하였는데, 이 무슨 뚱딴지 같은 소리인가…&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://socket.io/docs/&quot;&gt;docs에 보면 다음과 같이 안내되어 있다.&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;What Socket.IO is not&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Socket.IO is NOT a WebSocket implementation. Although Socket.IO indeed uses WebSocket as a transport when possible, it adds some metadata to each packet: the packet type, the namespace and the packet id when a message acknowledgement is needed. That is why a WebSocket client will not be able to successfully connect to a Socket.IO server, and a Socket.IO client will not be able to connect to a WebSocket server either. Please see the protocol specification here.&lt;/p&gt;
&lt;p&gt;내 마음대로 받아드리자면, Socket.IO는 WebSocket의 명세를 그대로 따라 만든 implementation이 아니라, 개량된 구현체인것 같다. Socket.IO는 전송시에 WebSocket를 활용하지만, 부가적으로 정보들을 함께 포함시켜 전달한다.&lt;/p&gt;
&lt;p&gt;그로 인하여, 보통의 WebSocket client 도구들이 Socket.IO와 궁합이 잘 안맞을 수 있으니 주의하도록 하자.&lt;/p&gt;
&lt;p&gt;다행히, js 진영에서는 &lt;code class=&quot;language-text&quot;&gt;socket.io-client&lt;/code&gt; 를 통하여 기능을 제공한다.&lt;/p&gt;
&lt;h2&gt;namespace &amp;#x26; room&lt;/h2&gt;
&lt;p&gt;처음 Socket.IO를 접하였을때, 그 쉬운 사용법에 굉장한 충격을 받았다.
client와 server에서 코드 몇줄을 작성하면, connection이 된 client 모두가 참여 가능한 채팅방이 5분도 안되어 완성되었다.&lt;/p&gt;
&lt;p&gt;그러나 우리는 모두가 참여하는 채팅방이 아닌 1:1 채팅방을 구현해야 했다. webRTC 를 이용하여 p2p 채팅을 private하게 하는 것을 고려할 수 있지만, 우리의 경우에는 모든 채팅 기록을 저장해 두었다가 사용자에게 전달하는 방식을 택하기로 하였다.&lt;/p&gt;
&lt;p&gt;그래서 튜토리얼을 따라 만든 “모두가 참여하는 채팅방”에서 1:1 로 운영되는 채팅방을 어떻게 만들 수 있을까 고민이 되었다.&lt;/p&gt;
&lt;p&gt;가장 단순 무식한 방법은, 매 client측에서의 emit마다, 그 정보를 분석하여 서버쪽에서 임의의 인증&amp;#x26;권한 프로세스를 녹이는 방법이다. 즉, server쪽에서 하나의 socket을 열고, 그 과정에서 수동적으로 교통정리를 하는것이다.&lt;/p&gt;
&lt;p&gt;이 방법을 굉장히 쉽게 구현할 수 있음에도, 하지 않으려 했던 이유는 이 방법이 썩 마음에 들지 않았기 때문이다. 매 요청마다 사용자와 사용자 대화방의 정보를 조회하기 위해 DB를 조회해야 하는 상황이 마음에 들지 않았고, 사용자간의 채팅방의 구분이 굉장히 얕은(?) 처리 방식으로 정리되는게 마음에 들지 않았다.&lt;/p&gt;
&lt;p&gt;내가 생각하는 1:1 통신 방법은 특별한게 아니고 너무 일반적인 구현이기 때문에 그에 대한 방법(구현 방법)이 있을것이 분명했다.&lt;/p&gt;
&lt;p&gt;그래서 그 아이디어를 찾기 위해 여러 stackoverflow를 한참 뒤졌지만…&lt;/p&gt;
&lt;p&gt;결국 정답은 공식 문서에 있었다…&lt;/p&gt;
&lt;p&gt;지금까지 내린 결론으로는, namespace로 연결하는 현 채널이 ‘chat’으로 논리적으로 분리하고, 사용자 별로 고유한 ‘room’정보를 따로 두어 한번 더 분리하는 방식을 택하기로 하였다.&lt;/p&gt;
&lt;h3&gt;Multiplexing support&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;In order to create separation of concerns within your application (for example per module, or based on permissions), Socket.IO allows you to create several Namespaces, which will act as separate communication channels but will share the same underlying connection.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;namespace&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;In order to create separation of concerns within your application (for example per module, or based on permissions), Socket.IO allows you to create several Namespaces, which will act as separate communication channels but will share the same underlying connection.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;room&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Within each Namespace, you can define arbitrary channels, called Rooms, that sockets can join and leave. You can then broadcast to any given room, reaching every socket that has joined it.This is a useful feature to send notifications to a group of users, or to a given user connected on several devices for example.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 맴버쉽 22]]></title><description><![CDATA[…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-membership/22/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-membership/22/</guid><pubDate>Mon, 16 Sep 2019 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;이번주는 시간적 여유가 없어 한주의 마지막에 회고를 진행하였다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;일주동안의 고민들&lt;/h2&gt;
&lt;h3&gt;이슈작성&lt;/h3&gt;
&lt;p&gt;이슈를 작성하기 위해 템플릿을 작성하였고, 이 과정에서 우리만의 규칙을 정의하였다.
정해진 규칙을 따라 작성하는데 시간이 많이 걸리지 않을것이라 생각 하였으나, 이는 착각이였다. 폼은 정해져 있더라도, 그 내용을 얼마나 깊이있게 작성할지는 순전히 작성자의 몫이므로 나 뿐만 아니라 팀원 모두가 이슈를 작성하는데 많은 시간이 걸렸다.&lt;/p&gt;
&lt;p&gt;생각해 보면, 이슈에 디테일한 내용을 적을 필요가 있었나 싶다.
이슈는, 나 혹은 팀원이 해당 작업을 수행하도록 최소한의 배경과 진행 이유등을 전달하면 된다.
진짜 팀원을 설득하는 작업은 PR에서 진행되어야 하는데, 우리는 이슈에서 너무 많은 내용을 적었다.&lt;/p&gt;
&lt;p&gt;특히, 팀원중 한분은 이슈를 적기위해 학습을 하는데 너무 많은 시간이 들었고, 이는 결과적으로 학습을 하였기에 도움은 되지만 너무 많은 에너지가 소모 되었기에 좋지 않은 경험이였다.&lt;/p&gt;
&lt;p&gt;이런 경험을 하고, 팀원간의 협의를 통하여 이슈작성에 드는 에너지를 줄이는 방향으로 잡았다. 이슈를 작성하기 위한 배경과, 설득은 최소화하고 이 내용을 구현과 PR에 사용하는것으로 어느정도 해결될 듯 하다.&lt;/p&gt;
&lt;p&gt;어쩌면, 이슈 작성에 격식을 없애고 들이는 최대 시간을 고정하는 방향도 좋을 수 있을것 같다.&lt;/p&gt;
&lt;h3&gt;디테일에 너무 집중하는 것은 아닌지&lt;/h3&gt;
&lt;p&gt;생각보다 업무의 속도가 붙지를 않는다. 나는 일을 진행함에 있어, 문서 작성과 기술에 대한 학습은 타협할 수 없는 부분이라 생각하였다. 모든 작업에는 문서화가 동반되어야 하고, 남에게 설명할 수 있을 정도록 기술을 학습해야 한다고 생각했다.&lt;/p&gt;
&lt;p&gt;근데, 이렇게 일을 진행하니 예상보다 딜레이가 많이 발생하였다. 원하던 작업량에 한참 못 미치는 결과물이 나왔고, 이러한 나의 작업 방식에 고민을 하게 되었다.&lt;/p&gt;
&lt;p&gt;만약, 이 과정이 단기간에 진행되는 해커톤 형태라면 이런 고민은 없었을듯 하다. 최소한의 시간동안 최고의 효율을 낼 수 있는 방향을 위하여 문서작성, 기술학습, 좋은 코딩 등을 포기하였을 것이다. 그러나 이 과정은 7주라는 긴 기간동안 진행되고, 이 과정에서 넘어짐 없이 잘 달려나가야 한다.&lt;/p&gt;
&lt;p&gt;우리는 스크럼이란 방법을 통해 어느정도 나침반을 찾은 것 같지만, 소요시간을 측정하고 완성도를 맞추는데 아직 어려움이 많다.&lt;/p&gt;
&lt;p&gt;종합적으로 생각하였을때, 어찌 되었든 우리의 목표는 목적지에 도달하는 것 이다. 목적지에 도달하기 위해서 지금 현재 내가 타협을 봐야할 부분은 무엇이고, 미래에 회사에서 일을할 때 타협을 봐야할 부분들은 무엇인지 고민을 해 봐야 하겠다.&lt;/p&gt;
&lt;h3&gt;공통의 규칙을 자동화 하는것은 너무나 좋은 일이다&lt;/h3&gt;
&lt;p&gt;이번 프로젝트에서 (거의) 처음 협업을 하였고, 그 과정에서 공통의 규칙을 검증하는 일을 자동화 하였다.
항상 이러한 부분을 구두로 말하여 통일하곤 하였는데, 사람은 항상 그러하듯 실수하기 마련이다. 과거에는 이러한 내용을 간단하게 노트에 적어 공유하곤 했는데, 이 부분들을 문서화 하고 자동화 하니 실수가 많이 줄어드는 것이 보인다.&lt;/p&gt;
&lt;p&gt;linter나 prettier, test 등을 아무리 말해도 지켜지지 않는 경우들이 있고, 이러한 일들로 팀원끼리 트러블이 생겨선 안된다. 기계적으로 이 문제들을 해결하고, 그 과정을 신경쓰지 않아도 된다는 인식 만으로도 개발의 능률을 올려주는 것 같다.&lt;/p&gt;
&lt;p&gt;또, master 브랜치로 push하는것과 같은 실수를 앞으로 하지 않을것이니 문제를 최소화할 수 있어 좋다.&lt;/p&gt;
&lt;p&gt;이러한 규칙들과 자동화 도구를 조금 더 고민하여 실무에 적용하도록 하자.&lt;/p&gt;
&lt;h2&gt;회고&lt;/h2&gt;
&lt;p&gt;이번주도 일주일 내내 컨디션이 좋지 않았다. 너무 무리를 해서 그런지 캠프 기간 내내 평생 아프지 않던 몸이 약해지고 있는것 같다. 감기나 몸살도 거의 걸리지 않았었는데, 캠프 기간동안 몇번이나 약해졌는지 모르겠다. 비타민 자주 챙겨 먹고, 잠을 푹 자도록 하자.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 맴버쉽 21]]></title><description><![CDATA[…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-membership/21/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-membership/21/</guid><pubDate>Sun, 15 Sep 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;번다운 차트&lt;/h2&gt;
&lt;p&gt;이번 프로젝트에서 스크럼의 철학을 가지고 프로젝트를 관리하며, 이 과정에서 백로그로 전체 작업의 현황을 관리한다. 스크럼에서는 계속적인 피드백을 통해 점진적으로 발전하는것이 매우 중요하다. 그래서 단순히 백로그 현황만을 보거나 매주 스크럼 미팅을 하는 것 이외의 보조 수단이 필요하고, 그 수단으로 번다운 차트가 있다.&lt;/p&gt;
&lt;p&gt;캠프에서 관련 내용을 배우지 않아서 무언가 어려운 방식이라 생각했는데, 어렵다기 보다는 손이 가는 작업인것 같다. 수단 자체는 굉장히 간단하고, 팀과 약속을 정해서 매일 매일 반복하여 작업하면 수월하게 나온다.&lt;/p&gt;
&lt;h3&gt;방식&lt;/h3&gt;
&lt;p&gt;가로축은 스프린트 1주기를 두고, 세로는 해당 스프린트에서 남은 작업량(실제 시간이 아니여도 된다)을 둔다.&lt;/p&gt;
&lt;p&gt;그리고 그 차트에 매일 작업한 양을 표시한다. (결과적으로 남은 작업양이 계속해서 표시된다)&lt;/p&gt;
&lt;p&gt;차트는 다음과 같은 형태를 띄고 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/0/05/SampleBurndownChart.png/650px-SampleBurndownChart.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;출처 제타 위키&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;번다운 차트는 가장 이상적으로는 왼쪽 상단에서부터 오른쪽 하단으로 직선의 형태를 띄며 작업양이 0으로 수렴되는 형태를 띄지만, 모두가 알다싶히 이런 결과는 나오지 않는다. (오히려 나오는게 이상한것이라 한다) 그래프는 뱀처럼 위 아래로 흔들리지만, 이런 이상적인 수직선을 염두에 두고 나아간다면 최대한 근사한 그래프가 그려질것 같다.&lt;/p&gt;
&lt;p&gt;번다운 차트에서 가장 중요한것은 지속적으로 차트의 추이를 보면서 계속해서 작업들을 돌아보며 앞으로 나아가는 것이다. (무언가 나침반 같다) 경사가 너무 가파라서 예측보다 총 작업이 너무 일찍 끝날것 같으면, 스프린트에 작업량을 추가하는 방법도 있다. 또, 경사가 너무 완만하여 예측보다 총 작업이 너무 늦게 끝날 것 같으면 스크럼 마스터와 상의 후에 우선순위가 낮은 작업을 이번 스프린트에서 제거하는 방법도 있다.&lt;/p&gt;
&lt;p&gt;번다운 차트를 활용하여 지속적으로 우리가 한 작업들과 예측하였던 시간을 고려하여 미래에 있을 작업들의 시간에 대한 예측을 고도화 하는 것이 중요하다.&lt;/p&gt;
&lt;h3&gt;목표로 하는 것&lt;/h3&gt;
&lt;p&gt;우리가 해야할 작업과, 할 수 있는 작업들 사이에 균형을 잘 맞추어 프로젝트 개발 동안 용기를 갖고 나아갈 수 있으면 좋겠다.&lt;/p&gt;
&lt;h3&gt;한계&lt;/h3&gt;
&lt;p&gt;우리의 경우는 스프린트가 1주일동안 진행된다. 앞선 글에서 언급 하였듯이 스크럼에서 스프린트 단위가 너무 짧은 것은 아닌가 고민하였고, 번다운 차트를 통한 지속적인 피드백에 있어서도 1주일이라는 시간이 너무 짧은건 아닌가 우려된다. 상황에 따라서 우리의 팀 자체적으로 2~3주 정도로 늘릴 계획도 있다.&lt;/p&gt;
&lt;p&gt;또 번다운 차트를 매일 작성하지 않으면 추적의 의미가 없어진다. 이를 위해 팀원 모두의 협력과 동의가 있어야 가능하다.&lt;/p&gt;
&lt;h2&gt;회고&lt;/h2&gt;
&lt;p&gt;오늘은 부캠원 분들의 기획을 볼 수 있었다. 다들 다양한 생각을 갖고, 다양한 목표를 갖고 행동하는 것이 보기 좋았다. 그 과정에서 내가 부족한 서류화에 대한 많은 인사이트도 얻을 수 있어서 뜻깊은 하루였다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[AWS SAM 에서의 Update, 불사조 서버]]></title><description><![CDATA[AWS SAM이란 AWS SAM은 CloudFormation의 확장. 이용을 더 쉽게 해주는 도구이다. SAM 업데이트 시에 데이터 유실 조심 Template 에서 Attribute 를 Update시에 data losses…]]></description><link>https://sukjae.github.io/daily-study/daily/2019-09-15/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/daily/2019-09-15/</guid><pubDate>Sun, 15 Sep 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;AWS SAM이란&lt;/h2&gt;
&lt;p&gt;AWS SAM은 CloudFormation의 확장.&lt;/p&gt;
&lt;p&gt;이용을 더 쉽게 해주는 도구이다.&lt;/p&gt;
&lt;h2&gt;SAM 업데이트 시에 데이터 유실 조심&lt;/h2&gt;
&lt;p&gt;Template 에서 Attribute 를 Update시에 data losses가 있을 수 있다.&lt;/p&gt;
&lt;p&gt;이는, 기존의 stack에서 업데이트시에 불가피하게 새로운 resource를 만들어야 할 때 발생한다.&lt;/p&gt;
&lt;p&gt;예를 들어, dynamodb에 Replacement 작업이 생길경우, 안에 들어있던 데이터가 모두 소실되고,&lt;/p&gt;
&lt;p&gt;cognito의 Replacement작업이 생길경우, 가입한 모든 유저 정보가 사라지는 것 이다 .&lt;/p&gt;
&lt;p&gt;CF에 리소스를 업데이트할때 발생 할 수 있는 옵션은 다음과 같다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Update with no interruption:&lt;/strong&gt; Your resource is updated in place without any disruption to normal use.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Update with some interruption:&lt;/strong&gt; Your resource is still the same resource, but there will be some downtime as the update is applied.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Replacement:&lt;/strong&gt; An entirely new resource is created to replace your existing resource.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;여기에서 Replacement가 중요한데, 이를 방지하기 위해서 Update시에 기존 resource를 retain하는 방법과 아예 delete를 iam으로 막는 방법 등이 있다.&lt;/p&gt;
&lt;h2&gt;phoenix server&lt;/h2&gt;
&lt;p&gt;마틴 파울러의 블로그 글에서 처음 접한 글이다.&lt;/p&gt;
&lt;p&gt;가장 간단하게 말하면, 이미 프로비전 된 서버에 직접적인 수정이 가해질 경우에 이게 쌓여서 Configuration Drift를 형성하고, 이는 지속적으로 쌓여 관리가 어려워진다.&lt;/p&gt;
&lt;p&gt;이를 방지하기 위해 주기적으로 서버를 무의 상태로 만들고(재로 만들고) 다시 살리는 흡사 불사조와 같은 구성을 해볼 수 있다.&lt;/p&gt;
&lt;p&gt;이 때에도 서버를 다 다운시킬때 데이터의 유실을 어떻게 처리할 지 고민해 봐야 하는데, 위의 SAM(CF) 업데이트 시의 데이터 유실과는 다른 양상이지만 (의도적으로 제거하기 때문에) 비슷한 고민을 해야하는듯 하다.&lt;/p&gt;
&lt;p&gt;백업을 어떻게 자동화하고, 유사시에 이를 백업에서 바로 살릴 수 있는 전략등이 필요하다.&lt;/p&gt;
&lt;p&gt;이에 대한 연장으로 드는 생각은, 모든 서버를 불사조 서버로 구성할 필요는 없을듯 하다.&lt;/p&gt;
&lt;p&gt;예를들어 cognito나 dynamodb등 과 같은 민감한 정보들은 따로 application stack으로 분리하여 관리함이 나을것 같다.&lt;/p&gt;
&lt;p&gt;어차피 Dynamodb나 cognito와 같은 서버는 AWS측에서 managing하므로 나의 책임이 아니다. 따라서 이를 굳이 phoenix server와 같은 방법으로 유지하는 작업이 불필요할 듯 하다.&lt;/p&gt;
&lt;h2&gt;Canary vs Blue-Green deployment&lt;/h2&gt;
&lt;p&gt;두 방법은 한가지 크게 비슷한 부분이 있는 듯 하다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;두 방법 모두 동시에 이전 버전과 최신 버전(수정 버전)에 대한 구성(서버, 스택)을 동시에 띄어 놓는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;둘의 차이점은,&lt;/p&gt;
&lt;p&gt;Canary는 단계적으로 (점진적으로) traffic을 이동시키는 반면, blue-green은 준비가 되면 한번에 이동시킨다.&lt;/p&gt;
&lt;p&gt;(canary는 0:10, 1:9, 5:5…:0:10 이런식으로, blue green은 스위치 처럼 딱!)&lt;/p&gt;
&lt;h2&gt;오늘 본 좋은 자료들&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://kief.com/automated-server-management-lifecycle.html&quot;&gt;Automated Server Management Lifecycle&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://kief.com/configuration-drift.html&quot;&gt;Configuration Drift&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.alexdebrie.com/posts/understanding-cloudformation-updates/&quot;&gt;CloudFormation의 업데이트에 대한 내용 및 이에 대한 대처 방법 정리&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://martinfowler.com/bliki/PhoenixServer.html&quot;&gt;PhoenixServer&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 맴버쉽 20]]></title><description><![CDATA[…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-membership/20/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-membership/20/</guid><pubDate>Sat, 14 Sep 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;유저 스토리를 작성하며&lt;/h2&gt;
&lt;p&gt;오늘 에픽, 유저스토리, 테스크를 작성하였다. 스크럼을 진행하면서 실행 단위를 피처리스트로 할지 유저스토리를 할지 고민하다가 유저스토리를 사용하게 되었다.&lt;/p&gt;
&lt;p&gt;나의 생각에서 개발자 입장에서 기술을 하나씩 나열해 가는 것 보다 유저 입장에서 필요한 기능을 상황별로 작성하는 것이 다음과 같은 이유로 적절해 보였다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;기반없이 무에서 유를 창조하듯이 기능을 하나씩 뽑는것 보다 논리적이여 보였다.&lt;/li&gt;
&lt;li&gt;사용자 입장에서 필요한 상황을 위주로 작성하다보니 핵심적인 내용을 놓치지 않을 수 있을듯 하였다.&lt;/li&gt;
&lt;li&gt;우리가 원하는 서비스의 방향을 더 구체적으로 표현할 수 있을 것 같았다.&lt;/li&gt;
&lt;li&gt;스프린트 주기동안 작업을 나눌 단위를 더 명확하게 구분할 수 있을 것 같았다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;팀원분들도 의견에 동의하여 유저스토리 방식으로 서비스를 구체화 하였다.&lt;/p&gt;
&lt;p&gt;우리는 에픽이라는 큰 범주를 정하고, 그 에픽 안에 적절한 유저스토리를 작성 하였다. 그 후 유저스토리 안에서 작업해야 할 요소들(Task)를 나누었다. 여기서 Task가 우리 개발자 입장에서 체크리스트이자 피처 리스트 라고 가정하였다.&lt;/p&gt;
&lt;p&gt;이렇게 작성된 에픽, 유저스토리, 테스크는 추후 백로그에 유저스토리별로 기록하고자 하였다. 스프린트 주기마다 구현하고자 하는 유저스토리를 대기로 올리고, 하나의 유저스토리를 작성하며 그에 따른 테스크(체크리스트)를 맞추고자 하였다.&lt;/p&gt;
&lt;p&gt;이런 작업 중에 조심하였던 부분들은, 유저스토리를 너무 세세하게 작성하지 않고자 노력했다는 점이다. 예를 들어, 사용자가 로그인시 입력 내용에 대한 검증을 필요로 할 경우 각각의 입력 요소 별로 검증을 한다는 유저스토리를 따로 두지 않으려 하였다.&lt;/p&gt;
&lt;h3&gt;개선의 여지가 있는 부분들&lt;/h3&gt;
&lt;p&gt;지금 생각해보면, 에픽을 정하고 유저 스토리를 정하기 보다 유저스토리를 우선 정하는게 적절했을 것 같다.
우리는 하나의 큰 카테고리를 에픽으로서 정하고, 그 카테고리속에서 원하는 상황을 유저스토리로 작성해 나갔다. 지금 생각해보면 이 과정이 충분히 유저의 입장에서(개발을 제외한체) 유저스토리를 도출했다고 보여지지 않는다.&lt;/p&gt;
&lt;p&gt;차라리 유저스토리를 정해가면서 그 크기가 너무 비대해질경우에 에픽으로 빼는 방식으로 나아갔으면 더 유저의 입장에서 분석이 가능했을 것 같다.&lt;/p&gt;
&lt;h2&gt;회고&lt;/h2&gt;
&lt;p&gt;갑자기 해야 할 공부와 작업들이 너무 많이 떠올랐다. 그 때문에 책을 읽어도 눈에 들어오지 않고, 집중도 되지 않았다. 9시쯤 되어서 컨디션 조절을 하기 위해 집으로 일찍 들어갔다.&lt;/p&gt;
&lt;p&gt;우리는 마라톤을 달리고 있음을 잊지 말자. 매 순간 최선을 다하되, 전력 질주하지 말자.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 맴버쉽 19]]></title><description><![CDATA[…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-membership/19/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-membership/19/</guid><pubDate>Fri, 13 Sep 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;팀 프로젝트에서 내가 알고 있는 지식을 (많이) 어필하는게 좋을까&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;지금은 배우는 단계. 내가 말하는 기술이 정답처럼 전해져서 우리 팀의 시야를 좁히고 있지 않은가?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;대부분의 상황에서 나는 주도적으로 내가 갖고 있는 생각을 전달하고 어필하는것을 좋아한다. 서로의 의견을 주고 받고 토론을 하면서 우리만의 정답을 찾아가는 과정을 즐기는 편이다. 현재 프로젝트에서도 내가 갖고 있는 지식들을 기반으로 다양한 의견을 펼치고 있다.&lt;/p&gt;
&lt;p&gt;여기서 내가 갖고 있는 지식들은 경험을 통해 채득한것이 아닌, 글을 통해 접하게된 경우가 대부분이다. 물론 신뢰할 소스에서 납득이 갈만한 정보들을 위주로 정리하지만, 나 또한 최선의 답이라 장담할 수 없다. 적어도 내가 갖고 있는 자원중에서 최선의 답일 뿐이다.&lt;/p&gt;
&lt;p&gt;우리는 현재 단기간 프로젝트를 진행하고 있고, 이 과정속에서 무언가를 배우고 있다. 즉, 우리는 무언가를 배워가는 단계인 셈이다. 이러한 상황에서 내가 어떤 기술적인 선택에 대해 확신에 찬 목소리로 말하면, (물론 이게 유일한 정답은 아니라고 항상 말한다) 팀원들이 그 특정 기술로 시야가 좁혀지는건 아닌가 걱정된다.&lt;/p&gt;
&lt;p&gt;다음과 같은 생각이 들면서 시야가 좁아질 수 있을 것 같다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;내가 말한 기술이(혹은 방법이) 최선의 방법이다&lt;/li&gt;
&lt;li&gt;내가 말한 기술을 위주로 검색을 하다보니, 그 내용만 파악하게 된다. (검색어의 확장이 어렵다)&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;내가 말한 기술이(혹은 방법, 도구) 최선의 방법이다&lt;/h3&gt;
&lt;p&gt;이렇게 생각이 들게되면, 다른 기술(방법)에 대해 연구를 하지 않게 된다. 물론 내가 갖고 있는 여러 의견중에 최선의 방법이라 어필하지만, 이게 전체중에 최선인지는 모른다. 더 좋은 방법이 있을 수 있으나, 이를 놓치게 된다.&lt;/p&gt;
&lt;h3&gt;2. 내가 말한 기술을 위주로 검색을 하다보니, 그 내용만 파악하게 된다. (검색어의 확장이 어렵다)&lt;/h3&gt;
&lt;p&gt;한정된 시간속에서 어떤 기술이 왜 쓰이고, 이에 대한 어떤 대체제들이 있고, 각각의 대체제들이 제공하는 가치가 무엇인지 파악이 필요하다. 그래야만 그 기술들 간의 객관적인 비교가 가능해지는 것 같다.&lt;/p&gt;
&lt;p&gt;내가 말한 기술을 우선적으로 검색하다 보면, 그 기술만을 파악하게 된다. 그러다 보면 그 기술의 대체제를 파악하기 어렵고, 비교가 없어진다.&lt;/p&gt;
&lt;h2&gt;어떻게 하면 팀 모두가 넓은 시야를 갖고 학습할 수 있을까&lt;/h2&gt;
&lt;p&gt;우선, 팀 전체가 주체적인 성향을 갖고 있으며 기술에 대한 흥미가 대단히 높거나 지식이 높은 경우, 이 걱정을 할 필요가 없다. 계속해서 최선의 답을 찾기위해 토론을 진행 할 것이고, 자연스럽게 팀이 도출한 최선의 답을 찾게 될것이다.&lt;/p&gt;
&lt;p&gt;그러나 만약 그렇지 못한 경우에는 (특히 모두 배우는 중일 때) 어떻게 공통의 최선의 답을 찾아갈 수 있을까.
내 생각에는 크게 두가지 방법이 있는 것 같다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;특정 기술, 도구, 방법을 언급하지 않은채 그 ‘것’이 해결하고자 하는 문제만을 언급한다.&lt;/li&gt;
&lt;li&gt;개인적인 최선의 답을 찾은 경로 (개인적으로 정리한 글, 블로그, 뉴스 등)을 공유한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;특정 기술, 도구, 방법을 언급하지 않은채 ‘그것’이 해결하고자 하는 문제만을 언급한다.&lt;/h3&gt;
&lt;p&gt;예를 들어, CI/CD를 구현하기 위해서 Travis, Jenkins등 다양한 도구들이 존재한다. 이러한 도구들을 바로 언급하기 보다는 CI/CD가 무엇이고, 어떤 문제를 해결하기 위한 도구인지 먼저 찾은 뒤 공유한다. (혹은 찾도록 장려한다)&lt;/p&gt;
&lt;p&gt;그런뒤에 해결하고자 하는 문제별로 적절한 도구들을 비교하며 탐색하고, 최선의 답을 찾는다.&lt;/p&gt;
&lt;h3&gt;개인적인 최선의 답을 찾은 경로 (개인적으로 정리한 글, 블로그, 뉴스 등)을 공유한다.&lt;/h3&gt;
&lt;p&gt;비슷한 내용의 글을 보고, 서로 동의할 수 있는지를 본다. 단편적으로 이 기술을 사용하자! 라고 하는것 보다 디테일한 설명을 포함하는 글들을 활용하면 모두가 동의할 수 있는 최선의 답에 가까워질 것 같다.&lt;/p&gt;
&lt;p&gt;위 두가지 방법을 적극 활용하여 시야를 좁히지 않은채로 모두가 동의하는 최선의 답을 찾고자 노력해야 겠다.&lt;/p&gt;
&lt;h2&gt;회고&lt;/h2&gt;
&lt;p&gt;오늘 프로젝트 이후에 바로 &lt;a href=&quot;https://github.com/sukjae/daily-study/blob/master/conference/2019-11-06-google-web-knowledge.md&quot;&gt;컨퍼런스에 참여&lt;/a&gt;를 하여 지치는 하루였다. 그럼에도 오늘도 많은걸 느끼고 배울 수 있어 유의미한 시간이였다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 맴버쉽 18]]></title><description><![CDATA[스크럼이 옳바른 선택일까? 스크럼이 정말 좋은 개발론임에는 이견이 없다. 하지만, 모든 개발론이 그러하듯 하나의 절대적인 방법은 없으며, 상황에 따라 적절한 방법을 선택해야 하는것 같다. 우리의 경우에는 7주라는 시간동안…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-membership/18/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-membership/18/</guid><pubDate>Thu, 12 Sep 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;스크럼이 옳바른 선택일까?&lt;/h2&gt;
&lt;p&gt;스크럼이 정말 좋은 개발론임에는 이견이 없다. 하지만, 모든 개발론이 그러하듯 하나의 절대적인 방법은 없으며, 상황에 따라 적절한 방법을 선택해야 하는것 같다.&lt;/p&gt;
&lt;p&gt;우리의 경우에는 7주라는 시간동안 3명의 팀원이서 프로젝트를 진행한다. 스크럼에서 말하는 스프린트 주기는 보통 30일 단위를 갖으며, 우리는 그렇게 하기에는 너무 촉박하다. 대략 1~2주 정도를 스프린트 단위로 해야 하는데, 그 시간동안 의미있는 결과를 도출하고 그 과정에서 점진적인 개선을 (피드백을) 할 수 있는지 의문이긴 하다.&lt;/p&gt;
&lt;p&gt;또 드는 생각은, 팀의 구성원이 너무 적다는 것이다. 스크럼 책에서 추천하는 인원은 5명이며 이 인원은 순수 프로젝트 인원이고, 개발에 영향을 직간접적으로 끼치는 인원은 이보다 훨씬 많을 것이다. 그렇다면, 우리는 3명이라는 인원이 제대로 스크럼을 진행할 수 있을지 의문이다.&lt;/p&gt;
&lt;p&gt;우리의 상황에 100% 적절한 개발론은 아닐 수 있지만, 그럼에도 불구하고 나는 두가지 이유로 이 스크럼을 계속하려 한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;스크럼과 XP가 추구하는 가치와 필요성 그 자체에 큰 동의를 한다.&lt;/li&gt;
&lt;li&gt;팀의 구성원이 너무 적은 부분은, 외부 인원을 구성원으로 활용하면 된다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;스크럼과 XP가 추구하는 가치와 필요성 그 자체에 큰 동의를 한다&lt;/h3&gt;
&lt;p&gt;앞서 [스크럼] 책에서 작성하였듯이, 스크럼과 XP가 해결하고자 하는 문제 그리고 추구하는 가치가 마음에 든다.
특히, 소프트웨어 개발에서 처음부터 완벽한 설계와 개발은 불가능 하고 이를 해결하기 위해 점진적인 발전을 이루어야 한다는 점에서 공감이 되었다. 이 외에도 다양한 부분에서 큰 공감을 가졌지만, 이에대한 자세한 내용은 독후감에서 다루도록 한다.&lt;/p&gt;
&lt;h3&gt;팀의 구성원이 너무 적은 부분은, 외부 인원을 구성원으로 바꾸면 된다&lt;/h3&gt;
&lt;p&gt;현재 우리 팀은 3명의 적은 인원으로 진행된다. 앞서 언급하였듯이 이 인원은 프로젝트를 진행하는데 조금 적은 인원인것 같다. 여기서 우리는 그냥 상황을 받아들이고 힘든것을 안고 갈 수 있다. 처음에는 그냥 받아드리려 하였으나, 생각해보니 우리가 도움을 받을 수 있는 인원이 더 많이 있다는것을 떠올리게 되었다.&lt;/p&gt;
&lt;p&gt;단편적으로는 마스터님, 코드리뷰어님 들이 있지만 우리와 함께하는 부스트 캠프 전체의 도움을 받을수도 있을 것 같다는 생각이 들었다. 이를 위하여 모두가 우리의 프로젝트에 참여할 수 있는 형태로 만들어 보기로 했다. 아이디어는 다음과 같다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;우리의 백로그와 현황판을 자리에 세워놓는다&lt;/li&gt;
&lt;li&gt;이 정보를 누구나 확인할 수 있다&lt;/li&gt;
&lt;li&gt;이 정보의 백로그에는 누구나 작업을 추가할 수 있다 (우선순위는 팀만이 정한다)&lt;/li&gt;
&lt;li&gt;스프린트 종료 후에 데모를 진행하고, 이 데모에 누구나 참여할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이를 통하여 결과적으로 나는 사람들과 협업을 하는 경험을 해보길 원한다.&lt;/p&gt;
&lt;h2&gt;우리의 기술블로그를 만들어 보는건 어떨까&lt;/h2&gt;
&lt;p&gt;우리는 현재 팀에서 매일 회의 내용을 기록하고, 매일 데일리 스크럼 미팅을 통해 도출되는 내용을 기록하고 있으며, 매 스프린트 종료 마다 기능 목록 업데이트를 포함한 회의 내용을 정리하고 있다. 이 세가지 내용은 우리의 레포지토리에서 위키에 저장되며, 이는 프로그램에서 필수로 장려하는 사항들이다.&lt;/p&gt;
&lt;p&gt;나는 이 외에도 우리 팀이 제작중인 서비스에 대한 기술블로그를 만들어 보려는 계획을 갖고 있다. 네이버, 우형, VCNC 등 다양한 기업들이 자사 서비스에 대한 기술을 공유하는 블로그를 운영하고 있다. 우리가 제작하는 서비스도 실제 서비스처럼 기술블로그를 만들면, 그 과정에서 정리도 되고 지식 공유도 될 수 있을거란 기대가 있다.&lt;/p&gt;
&lt;p&gt;사실 이 기술블로그를 만들려는 이유중에는, 내가 회사를 바라볼때 가장 중요하게 보는 요소중 하나이기 때문이다. (기업의 공유에 대한 가치 인식) 나도 이러한 공유를 프로젝트 동안 지속적으로 이루어내고 싶다.&lt;/p&gt;
&lt;h2&gt;회고&lt;/h2&gt;
&lt;p&gt;오늘은 12층 공용 라운지에 처음 갔다. 강남의 풍경이 한눈에 보이는 곳이였고, 8층보다 쾌적하여 자주 올것 같다.&lt;/p&gt;
&lt;p&gt;오늘 한쪽 기획서를 작성하였는데, 그 과정에서 팀원들에게 너무 단호하게 얘기한건 아닌가 걱정된다. 내 생각을 표현하는건 좋지만, 항상 상대방의 의견을 한번 더 듣도록 하자.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 맴버쉽 17]]></title><description><![CDATA[멤버십 프로젝트를 시작하여 이제 2달간의 멤버십 프로젝트가 시작되었다. 약 7주간의 시간동안…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-membership/17/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-membership/17/</guid><pubDate>Wed, 11 Sep 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;멤버십 프로젝트를 시작하여&lt;/h2&gt;
&lt;p&gt;이제 2달간의 멤버십 프로젝트가 시작되었다. 약 7주간의 시간동안 3명의 팀원이 힘을 함쳐 하나의 프로젝트를 성공적으로 수행해야 한다.&lt;/p&gt;
&lt;p&gt;이 과정속에서 내가 얻어가고자 하는것이 무엇이고, 이를 위해 어떻게 할것인지 생각해 보았다.&lt;/p&gt;
&lt;h3&gt;얻고자 하는 것&lt;/h3&gt;
&lt;p&gt;내가 얻어가고자 하는 것은 명확한것 같다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;한가지 일에 몰입하여 완성된 결과물을 도출하는 경험&lt;/li&gt;
&lt;li&gt;사람들과 협업하며 세상의 구성원으로서 참여하는 경험&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;한가지 일에 몰입한 경험은 많다. 그러나 나는 그에 대한 결과물을 내놓은적이 매우 적다. 그 이유는&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;항상 무언가를 혼자 하였고&lt;/li&gt;
&lt;li&gt;세상 모든것에 흥미를 갖고있었다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;혼자 무언가를 진행하면서 멀리가지 못하였고, 세상 모든것에 흥미를 갖으면서 다른 신기한 것들에 관심이 돌아가곤 하였다. 이번 경험을 통해서 나는 두달이라는 시간동안 3명의 팀원(나 포함)이 함께 나아가는 경험을 한다.
혼자 함으로서 멀리 가지 못한 경험을 이번 과정을 통해 얻어갈 수 있을것 같으며 결과적으로 하나의 목표 지점에 도달할 수 있을것 같다.&lt;/p&gt;
&lt;h3&gt;얻기 위해 하고자 하는 것&lt;/h3&gt;
&lt;p&gt;사람들과의 협업은 그냥 자연스레 이루어 지지 않는다. 항상 의견이 충돌하게 되고, 그 방법에 대해 혼란이 오곤 한다.&lt;/p&gt;
&lt;p&gt;가장 중요한 것은 팀원간의 마음을 잘 맞추기 위해 노력하는 것이지만, 기술적인 협업 방법 또한 중요하다고 생각한다. 마구잡이식 개발 방법은 결과적으로 팀 내에 혼란을 가져오게 되고, 선배 개발자들이 겪었던 문제들을 우리는 단시간에 최대한 피해가야 한다.&lt;/p&gt;
&lt;p&gt;그러기 위해 나는 선배 개발자들이 협업을 위해 노력한 흔적들을 따라가고, 그 과정에서 우리만의 길을 찾고자 노력할 것이다.&lt;/p&gt;
&lt;p&gt;지금 XP와 스크럼 등 애자일에 관한 책은 많이 읽어보고 있다. 이 책들의 내용이 내가 찾고자 하였던 협업의 길을 어느정도 보여주는 듯 하다.
물론, 개발 방법론은 다양하며 팀의 상황과 조건들에 따라 선택되어야 함을 알고 있다. 그러나, 나는 이 방법론들에서 추구하는 가치와 방향을 존중하며, 상황에 초월하는 무언가를 나에게 보여줄 것이라 기대하고 있다.&lt;/p&gt;
&lt;p&gt;아직은 그 방법이 구체적으로 보이지 않으나, 팀과 협업을 통해 책에 나오는 다양한 방법들을 시도할 계획이며 결과적으로 더 나은 소프트웨어를 만듬과 동시에 우수한 협업의 경험을 느껴보고 싶다.&lt;/p&gt;
&lt;h2&gt;회고&lt;/h2&gt;
&lt;p&gt;요즘 잠을 설친다. 그로 인해 제대로된 숙면을 취하지 못하고 캠프에서도 졸음이 계속 밀려오고 있다. 커피를 마시지만, 피곤함은 쉽게 가시질 않는것 같다.&lt;/p&gt;
&lt;p&gt;그로 인해 팀원들에게 계속해서 피곤한 모습을 보였고, 이는 팀 전체 분위기를 흐트려 놓을 수 있는 부분이므로 컨디션 조절에 신경을 써야 겠다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 맴버쉽 16]]></title><description><![CDATA[오늘의 고민들 React에서 useEffect의 실행 흐름 이해하기 다음과 같은 컴포넌트는, 결국 몇번의 “work” 로그를 찍을까? 정답: 3번 그렇다면, 다음은? 정답:…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-membership/16/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-membership/16/</guid><pubDate>Tue, 10 Sep 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;오늘의 고민들&lt;/h2&gt;
&lt;h3&gt;React에서 useEffect의 실행 흐름 이해하기&lt;/h3&gt;
&lt;p&gt;다음과 같은 컴포넌트는, 결국 몇번의 “work” 로그를 찍을까?&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; React&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; useEffect&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; useState &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;react&quot;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; ReactDOM &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;react-dom&quot;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;./styles.css&quot;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;App&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; b&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;work&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;token function&quot;&gt;useEffect&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;h1&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;h1&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; rootElement &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;root&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
ReactDOM&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;App &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; rootElement&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;정답: 3번&lt;/p&gt;
&lt;p&gt;그렇다면, 다음은?&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; React&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; useEffect&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; useState &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;react&quot;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; ReactDOM &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;react-dom&quot;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;./styles.css&quot;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;App&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; b&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;work&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;token function&quot;&gt;useEffect&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;h1&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;h1&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; rootElement &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;root&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
ReactDOM&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;App &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; rootElement&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;정답: 2번!&lt;/p&gt;
&lt;p&gt;오늘 다른 부캠원분께서 위와 같은 코드에서 어떻게 작동할지 여쭈어 보았다.&lt;/p&gt;
&lt;p&gt;당시에는 나도 useEffect 두번째 인자의 default value 가 무엇인지 명확히 알지 못하여 선뜻 말하기 어려웠다.&lt;/p&gt;
&lt;p&gt;documentation에 따르면 다음과 같이 나와있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;By default, effects run after every completed render, but you can choose to fire them only when certain values have changed.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;출처: &lt;a href=&quot;https://reactjs.org/docs/hooks-reference.html#useeffect&quot;&gt;https://reactjs.org/docs/hooks-reference.html#useeffect&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이에 대한 실제 구현 코드를 읽지는 못했지만, 매 render마다 App함수가 돈다는 것을 알 수 있다.
물론, 위와같이 App함수를 임의로 실행시켜 어떤 로직을 처리하는것은 좋지 않다. 그러나, 이러한 질문들로 인해 useEffect에 대해 더 이해를 할 수 있는 좋은 기회였다.&lt;/p&gt;
&lt;p&gt;결국, useEffect의 두번째 인자가 없으면, &lt;code class=&quot;language-text&quot;&gt;매 render가 종료&lt;/code&gt;될 때 마다 useEffect가 실행된다.&lt;/p&gt;
&lt;p&gt;반면, useEffect의 두번째 인자로 빈 배열을 넣으면, &lt;code class=&quot;language-text&quot;&gt;mount 와 unmount&lt;/code&gt; 상황에서만 실행된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;그러므로 맨 첫번째 코드를 해석하면 다음과 같을것 같다.&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;App함수로 진입&lt;/li&gt;
&lt;li&gt;useState 초기화 및 분해&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;console.log &lt;code class=&quot;language-text&quot;&gt;1회&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;useEffect callback등록&lt;/li&gt;
&lt;li&gt;render시작 (이때 a === 0)&lt;/li&gt;
&lt;li&gt;render 종료, mount 종료&lt;/li&gt;
&lt;li&gt;render가 완료되었으므로 useEffect로 전달된 callback 실행!&lt;/li&gt;
&lt;li&gt;callback을 통해 state a의 값을 0에서 1 로 전환&lt;/li&gt;
&lt;li&gt;전후로 state가 갱신 되었으므로, 다시 App으로 진입&lt;/li&gt;
&lt;li&gt;어떠한 방식으로 인해 useState를 sync 맞추고&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;console.log &lt;code class=&quot;language-text&quot;&gt;2회&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;useEffect callback등록&lt;/li&gt;
&lt;li&gt;전후 state가 변했으므로, render시작 (이때 a === 1)&lt;/li&gt;
&lt;li&gt;render 종료, update 종료&lt;/li&gt;
&lt;li&gt;render가 완료되었으므로 useEffect로 전달된 callback 실행!&lt;/li&gt;
&lt;li&gt;callback을 통해 state a의 값을 1에서 1 로 전환&lt;/li&gt;
&lt;li&gt;전후로 state가 갱신 되었으므로, 다시 App으로 진입&lt;/li&gt;
&lt;li&gt;어떠한 방식으로 인해 useState를 sync 맞추고&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;console.log &lt;code class=&quot;language-text&quot;&gt;3회&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;useEffect callback등록&lt;/li&gt;
&lt;li&gt;전후 state가 동일하므로, render 안함(shouldComponentUpdate() 영향)&lt;/li&gt;
&lt;li&gt;… 대기&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;반면, 두번째 코드를 해석하면 다음과 같을것 같다.&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;App함수로 진입&lt;/li&gt;
&lt;li&gt;useState 초기화 및 분해&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;console.log &lt;code class=&quot;language-text&quot;&gt;1회&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;useEffect callback등록&lt;/li&gt;
&lt;li&gt;render시작 (이때 a === 0)&lt;/li&gt;
&lt;li&gt;render 종료, mount 종료&lt;/li&gt;
&lt;li&gt;mount가 완료되었으므로 useEffect로 전달된 callback 실행!&lt;/li&gt;
&lt;li&gt;callback을 통해 state a의 값을 0에서 1 로 전환&lt;/li&gt;
&lt;li&gt;전후로 state가 갱신 되었으므로, 다시 App으로 진입&lt;/li&gt;
&lt;li&gt;어떠한 방식으로 인해 useState를 sync 맞추고&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;console.log &lt;code class=&quot;language-text&quot;&gt;2회&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;useEffect callback등록&lt;/li&gt;
&lt;li&gt;전후 state가 변했으므로, render시작 (이때 a === 1)&lt;/li&gt;
&lt;li&gt;render 종료, update 종료&lt;/li&gt;
&lt;li&gt;… 대기&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;오늘의 회고&lt;/h2&gt;
&lt;p&gt;항상 나는 베스트 프렉틱스로 문제를 접근하고, 이러한 안티패턴처럼 생각되는 방식은 생각을 아예 하지 않으려 하였다. 그냥, 리엑트 스럽지 않다는 핑계로…&lt;/p&gt;
&lt;p&gt;그러나, 오늘 이 경험을 통해 새롭게 생각을 바꾸게 되었다. 베스트 프렉티스처럼 예상 가능한 상황이 아닌, 내 예상과 달리 움직이는 전혀 예상치 못한 상황을 생각하며 더 많이 배울 수 있는것 같다. 종종 이러한 이상한(?) 시도를 많이 해야겠다. 이러한 과정속에서 그 흐름을 더욱 명확하게 이해할 수 있을것 같다.&lt;/p&gt;
&lt;p&gt;오늘 또 들게 된 생각은, 부스트 캠프원들이 정말 많은 노력을 하고 계신다는 생각이 들었다. 개개인이 모두 하나에 몰두하여 굉장한 퀄리티의 성과를 내곤 한다. 이를 통하여 나 또한 자극을 받을 수 있었고, 더 열심히 해야겠다는 생각을 강하게 갖게 하였다.&lt;/p&gt;
&lt;p&gt;앞으로 남은 프로젝트 기간 주도적으로 참여하여 의미있는 결과물을 완성하고 싶다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 맴버쉽 15]]></title><description><![CDATA[오늘의 고민들 React에서 hooks가 어떻게 HOC를 대체하는가 React에서는 보통 cross-cutting concerns(공통의 관심사)를 해결하기 위해서 사용되었다. Component…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-membership/15/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-membership/15/</guid><pubDate>Mon, 09 Sep 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;오늘의 고민들&lt;/h2&gt;
&lt;h3&gt;React에서 hooks가 어떻게 HOC를 대체하는가&lt;/h3&gt;
&lt;p&gt;React에서는 보통 cross-cutting concerns(공통의 관심사)를 해결하기 위해서 사용되었다.&lt;/p&gt;
&lt;p&gt;Component끼리 공통의 로직 혹은 값을 공유하기 위해 사용되었고, 이러한 정보를 사용하고자 하는 컴포넌트에 주입하는 형태로 사용되었다. 반면 이로 인해, 값과 로직의 출처를 알기 어렵고, 과도한 복잡성이 동반된다.&lt;/p&gt;
&lt;p&gt;React의 공식문서를 참고하면, Hooks의 개념을 통해 이 HOC 패턴을 걷어낼 수 있다고 한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Do Hooks replace render props and higher-order components?
Often, render props and higher-order components render only a single child. We think Hooks are a simpler way to serve this use case. There is still a place for both patterns (for example, a virtual scroller component might have a renderItem prop, or a visual container component might have its own DOM structure). But in most cases, Hooks will be sufficient and can help reduce nesting in your tree.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;출처: &lt;a href=&quot;https://reactjs.org/docs/hooks-faq.html#do-hooks-replace-render-props-and-higher-order-components&quot;&gt;https://reactjs.org/docs/hooks-faq.html#do-hooks-replace-render-props-and-higher-order-components&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;주의해야 할 점은, Hooks를 통해 HOC나 render props가 불필요해 진것은 아니다. 여전히 Class components의 용도가 존재하듯이 HOC나 render props의 방식으로 해결해야 하는 문제들이 존재한다. 단지, 대부분의 경우에 Hooks를 통한 방법이 simpler한 방법일 뿐이다.&lt;/p&gt;
&lt;p&gt;그렇다면, 어떻게 Hooks가 HOC를 대체할 수 있는 것일까?&lt;/p&gt;
&lt;p&gt;나의 생각은 이러하다.&lt;/p&gt;
&lt;p&gt;기존의 Class 방식에서는 state와 event handler들을 클래스 외부로 빼내어 전달할 방법이 마땅치 않았다. (redux 등 제외) 그런 상황에서 class로 거대하게 감싸서 공통으로 사용될 값 또는 로직을 전달해야 했고, 이게 HOC 방법이다.&lt;/p&gt;
&lt;p&gt;반면, Hooks는 react가 기본적으로 제공하는 hooks를 활용하여 custom hooks를 제작할 수 있다.
이러한 custom hooks는 또 다시 별도의 파일(함수)로 분리가 가능하다. 즉, 원하는 로직이 하나의 Class Component에 종속되던 방식에서 벗어나서 독립된 로직으로 존재할 수 있다.&lt;/p&gt;
&lt;p&gt;hooks는 이러한 방식으로 cross-cutting concern을 해결하고, 더 간결하고 재사용 가능한 해결책을 보인것이다.&lt;/p&gt;
&lt;h2&gt;오늘의 회고&lt;/h2&gt;
&lt;p&gt;오늘 다시 나의 모습으로 돌아올 수 있었다.&lt;/p&gt;
&lt;p&gt;주어진 여러 선택지 속에서 끊임없이 고뇌하며, 내 중심과 가치를 잊지 않고자 최선의 선택을 하였다.&lt;/p&gt;
&lt;p&gt;지금 이 선택을 통하여, 미래에 보다 성장한 모습이 되고 싶다.&lt;/p&gt;
&lt;p&gt;앞으로 남은기간 최선을 다하여 최고의 결과물을 내도록 하겠다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 맴버쉽 14]]></title><description><![CDATA[오늘의 고민들 React의 props를 통하여 동일한 값을 너무 깊게 내려야 한다면? 예를 들어, 상위 컴포넌트에서 자식 컴포넌트로 특정 props…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-membership/14/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-membership/14/</guid><pubDate>Sun, 08 Sep 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;오늘의 고민들&lt;/h2&gt;
&lt;h3&gt;React의 props를 통하여 동일한 값을 너무 깊게 내려야 한다면?&lt;/h3&gt;
&lt;p&gt;예를 들어, 상위 컴포넌트에서 자식 컴포넌트로 특정 props를 내려야 하는 상황이다.
한 두 단계 내리는 것은 크게 문제될게 없어보이고, 정상적이여 보인다.&lt;/p&gt;
&lt;p&gt;그런데, 만약 특정 값을 너무 많이 내려야 하는 상황이면 어떻게 대처할까?
예를 들어, name, age라는 값은 5단계 내려야 하는 상황이라 생각해보자 .&lt;/p&gt;
&lt;p&gt;이에 대한 나의 3가지 접근법은 다음과 같다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;그대로 props를 하나씩 내린다. (&lt;code class=&quot;language-text&quot;&gt;name={name} age={age}&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;컴포넌트가 꼭 상하 관계를 갖어야 할까? sibling의 형태가 될 순 없을까?&lt;/li&gt;
&lt;li&gt;context 혹은 redux store 등 React의 기본 정보의 흐름이 아닌 글로벌하게 둔다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;1. 그대로 props를 하나씩 내린다.&lt;/h4&gt;
&lt;p&gt;처음 props를 계속해서 내리게 되는 상황에 이게 잘못되고 있는건 아닌가? 하는 고민이 들 수 있다.
어쩌면, 전혀 잘못된게 아닐 수 있다.&lt;/p&gt;
&lt;p&gt;나는 React사용시 위에서 아래로 props를 통한 값의 전달은 지극히 정상적인 React의 설계 방식이며, 애초에 그렇게 라이브러리가 디자인 되었다고 본다.
그러므로 부자연스럽더라도, React스러운 사고를 함이 옳을때도 있다.&lt;/p&gt;
&lt;h4&gt;2. 컴포넌트가 꼭 상하 관계를 갖어야 할까? sibling의 형태가 될 순 없을까?&lt;/h4&gt;
&lt;p&gt;또 생각해볼 수 있는 부분이다. 위 문제에서 값을 위에서 아래로 반복적으로 내리는 패턴에서 이상함을 느낄 수 있다.&lt;/p&gt;
&lt;p&gt;근데 여기서 생각해 봐야할 중요한 부분은, 가장 근본적으로 상하의 구조가 적절하냐는 질문일것 같다.
해당 정보를 상위 컴포넌트에서 들고 있음이 이상하다는 의미는, 반대로 그 정보(값)가 해당 컴포넌트에 속할 필요가 없을 수 있다는 의미이기도 하다.&lt;/p&gt;
&lt;p&gt;보통, 부모-자식간의 관계는 둘 간의 어떠한 포함관계가 있기에 작성되곤 한다.
서로 크게 연관이 없는 컴포넌트임에도 부모-자식의 형태를 띄고 있다면, 이를 형제-형제 의 형태로 바꿔보는 생각을 고려해볼 수 있다.&lt;/p&gt;
&lt;h4&gt;3. context 혹은 redux store 등 React의 기본 정보의 흐름이 아닌 글로벌하게 둔다.&lt;/h4&gt;
&lt;p&gt;꼭 필요할때 사용하면 좋을듯 하다.
이 두 방식은 React에 굉장히 친화적이지만, 나에게 있어 이 둘은 치트키 같다.
치트키를 너무 남발하면, 실제 게임 하는 방법을 잊어버릴 수 있다.&lt;/p&gt;
&lt;p&gt;어디까지나 상태 관리가 너무 복잡해지고, 그 깊이가 너무 깊어져서 도저히 관리가 힘들때 적용을 고려하자. 그 전까지는 1번과 2번을 최 우선해야 한다고 생각한다. (나에게 있어 이 두 방식이 가장 React 스러운 방식인듯 하므로)&lt;/p&gt;
&lt;h2&gt;오늘의 회고&lt;/h2&gt;
&lt;p&gt;오늘은 개인적인 사정으로 캠프에 오래 있지 못하였다. 그로인해 개인적인 학습에 집중하기 어려웠고, 배운게 별로 없다.
그럼에도 아주 사소한 배움이라도 공유하기 위해 이 글을 작성하였다.앞으로 공유의 방식은 이렇게 진행하고자 한다. 아무리 사소한것이라도 매일 공유하도록.&lt;/p&gt;
&lt;p&gt;그렇지만, 주어진 코어시간에 배움을 많이 얻지 못한건 너무 아쉽다.
과제를 제대로 수행하고 있지 못하고 있다.&lt;/p&gt;
&lt;p&gt;빨리 모든게 결정이 되어 프로젝트에 집중할 수 있도록 하자.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 맴버쉽 13]]></title><description><![CDATA[오늘의 고민들 React에서 어떻게 하나의 변화에 대해, 연쇄적으로 다른 변화를 이르킬 수 있을까 Redux, context 등을 고려하지 않고, 순수하게 React의 사고 방식으로 부모에서 자녀로 props…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-membership/13/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-membership/13/</guid><pubDate>Sat, 07 Sep 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;오늘의 고민들&lt;/h2&gt;
&lt;h3&gt;React에서 어떻게 하나의 변화에 대해, 연쇄적으로 다른 변화를 이르킬 수 있을까&lt;/h3&gt;
&lt;p&gt;Redux, context 등을 고려하지 않고, 순수하게 React의 사고 방식으로 부모에서 자녀로 props를 내리는 형태로 가정하자.&lt;/p&gt;
&lt;p&gt;만약, 부모의 객체에서 어떤 이벤트가(여기서는 클릭) 발생하여 그로 인해 부모와 자식에 존재하는 값이 동시에 변해야 한다면 어떻게 해볼 수 있을까?&lt;/p&gt;
&lt;p&gt;가장 쉬운 방법은, 자식에 있는 값은 부모로 올리는 것이다.
다음 예제에서는, 부모의 &lt;code class=&quot;language-text&quot;&gt;초기화&lt;/code&gt; 버튼을 누르면, 그에 따라 부모에 있는 값과(totalCount) 자식에 있는 값(count)이 동시에 초기화(0으로 설정)이 된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 부모&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;App&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;totalCount&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; setTotalCount&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;count&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; setCount&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;clearCount&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;setTotalCount&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;setCount&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;div className&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;App&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
      &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Counter count&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;count&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; setCount&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;setCount&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
      &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;button onClick&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;clearCount&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;초기화&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;button&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;가능은 하겠지만, 만약 자식이 여러개가 생기고 그 값을 모두 부모가 들고 있어야 한다고 생각해보자.. 힘들어 진다.&lt;/p&gt;
&lt;p&gt;물론 무조건 잘못된 방법은 아니지만, 이 경우에 각각의 count에 대한 값은 Counter가 들고 있는 형태가 더 적절할것 같다. 그리하여, Counter 스스로도 독립 가능한 컴포넌트로서의 역할을 할 수 있도록 하면 좋을듯 하다.&lt;/p&gt;
&lt;p&gt;두번째로 할 수 있는 방식은, 변화에 대한 기준값을 자식에 제공하는 것이다.
React의 life cycle 혹은 hooks를 잘 활용하면, 변화에 대한 어떤 기준점에 대해서 특정 행동을 취할 수 있다.
이러한 방식이 조금 더 React 스러운 방식같다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 부모&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;App&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;totalCount&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; setTotalCount&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;clearCount&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;setTotalCount&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;div className&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;App&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
      &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Counter clear&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;totalCount &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
      &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;button onClick&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;clearCount&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;초기화&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;button&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// 자식&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;Counter&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; clear &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;count&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; setCount&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// 부모로부터 내려오는 clear라는 props의 변화에 따라 useEffect를 실행한다.&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 만약, clear가 되어 totalCount가 0 이 되었다면, 이 컴포넌트 또한 0으로 설정한다.&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;useEffect&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;clear&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token function&quot;&gt;setCount&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;clear&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;count&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위에 작성 되었듯이, useEffect의 두번째 인자로 관찰 하고자 하는 인자를 제공하여 그 값에 변화가 생길때 useEffect를 실행하고자 하였다.
이렇게 된다면, 상위의 어떤 이벤트가 발생하는지는 모르지만 그 결과로 어떤값(totalCount)이 0 이 된다면, 이 컴포넌트 또한 업데이트를 진행한다.&lt;/p&gt;
&lt;h2&gt;오늘의 회고&lt;/h2&gt;
&lt;p&gt;근래에 여러 일들이 곂치고, 나름 바쁜 일들이 있어서 회고를 진행하지 못하였다.
계속하여 시간을 내지 못한 나의 모습을 반성하고, 오늘부터 다시 회고를 시작하고자 한다.&lt;/p&gt;
&lt;p&gt;나의 성장을 확인하고, 돌아보기 위해서는 회고는 필수적인것 같다.&lt;/p&gt;
&lt;p&gt;나와의 약속을 먼저 지킬 수 있는 사람이 되도록 하자.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 맴버쉽 12]]></title><description><![CDATA[오늘의 고민들 모던한 웹 환경에서 사용자 인증과 권한 부여는 어떻게 이루어 질까 위 내용을 살펴보며 중요한 키워드 몇가지가 눈에 띄었다. OAuth2.0 OpenID Connect SAML SSO JWT…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-membership/12/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-membership/12/</guid><pubDate>Fri, 06 Sep 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;오늘의 고민들&lt;/h2&gt;
&lt;h3&gt;모던한 웹 환경에서 사용자 인증과 권한 부여는 어떻게 이루어 질까&lt;/h3&gt;
&lt;p&gt;위 내용을 살펴보며 중요한 키워드 몇가지가 눈에 띄었다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OAuth2.0&lt;/li&gt;
&lt;li&gt;OpenID Connect&lt;/li&gt;
&lt;li&gt;SAML&lt;/li&gt;
&lt;li&gt;SSO&lt;/li&gt;
&lt;li&gt;JWT&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;재밌는 점은, 여러 인증방식이 사용하는(목표하는) 환경에 따라 서로 다른 기술을 사용한다는 점이다.
이러한 기술들을 더 학습하고, 이번 과제에서 적용해보고자 노력하고 있다.&lt;/p&gt;
&lt;h3&gt;OAuth2.0, OpenID Connect 왜 쓸까?&lt;/h3&gt;
&lt;p&gt;이러한 Auth관련 서버를 직접 구축하지 않고 제 3의 벤더에서 제공받는 이유가 무엇일까?&lt;/p&gt;
&lt;p&gt;이 의문에 대해 아래 동영상을 시청하며 어느정도 공감가는 결론에 도달할 수 있었다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Auth관련 보안 업데이트를 진행한다던지,&lt;/li&gt;
&lt;li&gt;서버를 유지 보수하는 등의 작업이 필요하고&lt;/li&gt;
&lt;li&gt;이는 유저 정보 보호를 위해 필수적이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;그러나, 서비스 제공차 측면에서 Auth관련 서버와 서비스를 유지하기란 쉽지 않다.&lt;/p&gt;
&lt;p&gt;그래서, 이를 하나의 신뢰되는 서비스 업체에서 관리를 위임하고, 제공받는 방법을 사용한다.&lt;/p&gt;
&lt;h3&gt;OpenID 는 Authentication을 위한 프로토콜이고, OAuth2.0은 Authorization을 위한 것이다.&lt;/h3&gt;
&lt;p&gt;그런데… OpendID 는 OAuth2.0위에 구현되어 있다.&lt;/p&gt;
&lt;p&gt;여기서 든 의문은(아직 해결되지 않았지만)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Authorization은 Authentication에 대한 정보를 일부 포함하고 있을텐데…&lt;/li&gt;
&lt;li&gt;어떻게(왜) 더 많은 정보를 갖고 있는 것에서 더 작은 정보를 갖고 잇는 것을 개발(사용)하는 것 일까&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;더 학습이 필요하다&lt;/p&gt;
&lt;h2&gt;오늘의 회고&lt;/h2&gt;
&lt;p&gt;오늘은 집에 물이 세서 급하게 가야했다.&lt;/p&gt;
&lt;p&gt;학습해야 할 것이 많고, 구현해야 할 것이 많았지만,&lt;/p&gt;
&lt;p&gt;내 의지와 상관없는 외부 요인으로 목표를 달성하지 못해 아쉽다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 맴버쉽 11]]></title><description><![CDATA[마스터 클래스 DBMS의 ORM을 사용하지 않고 Query…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-membership/11/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-membership/11/</guid><pubDate>Thu, 05 Sep 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;마스터 클래스&lt;/h2&gt;
&lt;h3&gt;DBMS의 ORM을 사용하지 않고 Query를 구현하는 것에 대하여…&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;좋은 시도라고 생각한다.&lt;/li&gt;
&lt;li&gt;아무리 추상화가 잘 되어 있다고 하더라도, 개발자라면 로우한 레벨에서 다뤄보는 경험을 필수적으로 해야한다고 생각한다.&lt;/li&gt;
&lt;li&gt;개인적으론 귀찮아서, 관심 없어서 진지하게 시도해보지 않았는데, 이번 기회에 한번 시도해볼 수 있을것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;SOAP - XML RPC&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;이기종간의 통신 방법 정의&lt;/li&gt;
&lt;li&gt;결국에 REST나 SOAP이나 해결하고자 하는 문제는 비슷하였음. 방법에 차이가 있었을 뿐.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;여러개의 서버가 하나의 세션 디비 공유하기 위해서는?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;세션 클러스터링 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Data vs Database vs DBMS&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Data: 데이터, 저장 가능한 값&lt;/li&gt;
&lt;li&gt;Database: 데이터 저장하는 곳&lt;/li&gt;
&lt;li&gt;DBMS: 데이터베이스를 관리하는 시스템&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;NoSQL은 CAP을 중요시하고&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;잘 몰랐던 부분이다. AWS의 Dynamodb나 S3가 얼마큼의 consistency, availability, partition tolerance를 중요하게 생각하고 갖고 있는지 외우기만 했지 이 정보가 의미하는 바를 제대로 알지 못했다.&lt;/li&gt;
&lt;li&gt;오늘 강의를 통해서 이 세가지 요소가 DB에서 정통적으로 중요하게 보는 요소이고, 이 모두를 제공하기 힘드니 셋중에 하나 이상을 타협보는 형태로 감을 알게 되었다.&lt;/li&gt;
&lt;li&gt;근래의 Cloud의 환경에서는 consistency를 타협본다고 한다. (eventually consistency를 떠올리자.)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;SQL은 ACID를 중요시한다&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;트랜잭션과 같은 작업은 ACID를 보장하기 위해 SQL을 주로 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;오늘의 고민들&lt;/h2&gt;
&lt;h3&gt;REST 하지 않다&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;우리가 일반적으로 작성하는 API는 REST하지 않음을 알게 되었다.&lt;/li&gt;
&lt;li&gt;그리고, 이 REST에서 타협을 보아서 HTTP API를 작성하곤한다.&lt;/li&gt;
&lt;li&gt;이렇게 작성된 API를 REST라고 불르는건 옳지 않다고 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;여기서 든 나의 생각은…&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;이렇게 REST를 지키기 어렵고, 존재하기 힘든 이론이라면, 이에 대해 타협을 본 개량형 REST 이론은 왜 나오지 않는걸까,,,,&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;시간 날때 한번 파보도록 하겠다.&lt;/p&gt;
&lt;h3&gt;클라우드란 무엇인가?&lt;/h3&gt;
&lt;p&gt;오늘 동료분께서 클라우드에 올리는것과 로컬 서버에 올리는게 근본적으로 무엇에 차이가 있는지와, 클라우드가 무엇인지 물어봤다.
이에 대한 나의 답은,&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;클라우드는 가상화를 이용하여 서버를 사용자가 필요로 할 때 효율적으로 제공하게 도와주는 기술이다. 이와 더불어 규모의 경제를 통하여 사용자에게 가성비 높은 서비스를 제공한다.&lt;/li&gt;
&lt;li&gt;로컬에서 올리는거랑 클라우드 서버에 올리는거랑 기술적으로 무언가 큰 차이가 있는건 아니다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;다만, 클라우드 밴더별로 더 나은 서비스를 제공하기 위해 기본적인 무언가를 녹여서 제공하고, 이런 부분에 차이가 있을 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;예를 들어, 일정한 Range의 포트가 미리 예약되어있어 사용할 수 없다던지&lt;/li&gt;
&lt;li&gt;VPC에서 IP주소중 일부분이 예약되어 있다던지&lt;/li&gt;
&lt;li&gt;서버의 특정 위치에 기본적인 AWS정보가 녹아있다던지…등등&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;오늘의 회고&lt;/h2&gt;
&lt;p&gt;또!!!!! 지각을 하였다.
왜 스스로의 다짐을 지키지 못하는가…
내일이 나의 마지막 기회라 생각하고 다시는 지각하지 말자.&lt;/p&gt;
&lt;p&gt;오늘은 전반적으로 아는 지식을 돌아보는 시간이였다.
다행히 내가 관심 있던 분야의 내용들 위주였기 때문에 수업에 집중하여 참여할 수 있었다.&lt;/p&gt;
&lt;p&gt;그렇지만, 내가 명확하게 알지 못하던 부분도 몇개씩 보였다. 이런 부분을 정리하여 바로잡을 필요가 있다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 맴버쉽 10]]></title><description><![CDATA[프로젝트를 완성하지 못한 이유 계획의 부재 지나친 고민 컨디션 저조 빠르게 구현을 해보지 못함(최소한 사용가능한 모습으로 만드는것을 우선시 했어야 함)…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-membership/10/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-membership/10/</guid><pubDate>Wed, 04 Sep 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;프로젝트를 완성하지 못한 이유&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;계획의 부재&lt;/li&gt;
&lt;li&gt;지나친 고민&lt;/li&gt;
&lt;li&gt;컨디션 저조&lt;/li&gt;
&lt;li&gt;빠르게 구현을 해보지 못함(최소한 사용가능한 모습으로 만드는것을 우선시 했어야 함)&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;1. 계획의 부재&lt;/h3&gt;
&lt;p&gt;지난주까지 스크럼을 통하여 유저 스토리를 구성하고 체크리스트를 만들었다.&lt;/p&gt;
&lt;p&gt;그러나, 이 작업에 시간이 지나치게 많이 소요 되는듯 하여 이번 과제에서는 스크럼이나 백로그 등을 구성하지 않았다.&lt;/p&gt;
&lt;p&gt;그러나 이 부분은 나의 큰 착오였다. 체크리스트를 만들지 않으니, 내가 얼마나 했는지, 얼마나 해야 하는지가 명확하게 보이지 않았고, 나태하게 프로젝트를 진행하다가 마지막날에 과제가 쏟아지는 결과로 돌아왔다.&lt;/p&gt;
&lt;p&gt;스크럼이나 백로그 등은 선택이라 할 수 있겠지만, 개발자로서 나침반이 되어줄 체크리스트는 필수적인 요소인듯하다.&lt;/p&gt;
&lt;p&gt;이 부분을 절실히 느꼈으니, 앞으로는 모든 작업에 체크리스트 작성을 최우선으로 진행해야 하겠다.&lt;/p&gt;
&lt;h3&gt;2. 지나친 고민&lt;/h3&gt;
&lt;p&gt;과제를 실제로 만들지 않고, 사고로만 실험하여 기획하였다.&lt;/p&gt;
&lt;p&gt;직접 만들어보지 않으니, 과제의 난이도를 파악함에 있어 실수를 하였고, 지나치게 얕잡아 보아 고민을 너무 많이 했다.&lt;/p&gt;
&lt;p&gt;특히 재사용이 가능한 라이브러리화 라는 부분에 지나치게 몰입되어서 오버 엔지니어링이 된것 같다. 이 부분은 리펙토링을 통해 이루어졌어야 했던 것 같다.&lt;/p&gt;
&lt;p&gt;앞으로는 고민을 하기 앞서 만들어 보는 것을 우선시 해야겠다.&lt;/p&gt;
&lt;p&gt;고민과 만드는것이 교차되며 쌓여야 원하는 결과물이 나오는것 같다.&lt;/p&gt;
&lt;h2&gt;나의 원래 계획&lt;/h2&gt;
&lt;h3&gt;1. 재사용이 가능한 라이브러리화&lt;/h3&gt;
&lt;p&gt;가장 처음에 고민하였던 부분은, 이 과제를 통해 나온 결과물을 어떻게 다른 프로젝트에 접목할 수 있을지 였다.&lt;/p&gt;
&lt;p&gt;특히, ReactJS에 어떻게 접목할 수 있을지 고민하였는데, 결론적으로 좋지 않은 고민이였다.&lt;/p&gt;
&lt;p&gt;처음에 나는 이 캐러셀 라이브러리를 유니버셜 캐러셀 이라는 이름으로 JS 를 사용하는 모든 라이브러리에서 활용 가능한 방법을 찾아보고 싶었다.&lt;/p&gt;
&lt;p&gt;당시 든 생각은, VanilaJS에서 사용되는 가장 근본적인 기능들(Event, Event listener, DOM Element)를 사용하면, 이 VanilaJS를 바탕으로 만들어진 모든 라이브러리에서 사용이 가능하지 않을까 라는 나이브한 생각을 갖고있었다.&lt;/p&gt;
&lt;p&gt;그러나 이러한 생각은 다음과 같은 점에서 잘못되었다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;모든 라이브러리(React, Vue, Angular)가 동일한 철학을 갖고 움직이는게 아니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;가장 크게 잘못 생각하고 있던 부분이다. 내가 설계하고자 했던 라이브러리는 이벤트 드리븐 방식인것 같다.&lt;/p&gt;
&lt;p&gt;즉, 특정 이벤트에 따라 어떤 액션이 트리거되고, 이 결과로 또 다른 이벤트를 받아서 원하는 결과를 (view의 수정) 수행하고자 했다.&lt;/p&gt;
&lt;p&gt;그러나, React의 작동방식은 Event Driven과 전혀 다른 철학을 갖고 있다. React에서 값은 상위에서 하위로 흐르고, view를 수정하는것은 이벤트가 아닌, 값의 변화이다.&lt;/p&gt;
&lt;p&gt;물론, React에서 제공하는 기능(useRef)등으로 event를 componet에 등록할 수 있지만, 이는 React의 설계방식을 무시하는 형태가 되버린다.&lt;/p&gt;
&lt;p&gt;다른 라이브러리도 동일한것 같다.&lt;/p&gt;
&lt;p&gt;결국, 변화에 대해 다른 철학을 갖는 라이브러리들 모두에서 사용 가능한 유니버셜한 라이브러리는, 하나의 통일된 방법으로는 만들수 없는것 같다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DOM element를 추상화?하여 제공하기도 한다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;대부분의 라이브러에서 쉽게 DOM Element를 쉽게 빼올 수 없는 것 같다.&lt;/p&gt;
&lt;p&gt;모던한 FE 라이브러리에서는 이 부분이 추상화 되어 있어서, 뒷쪽에서 DOM Element로 변형하는듯 하다.&lt;/p&gt;
&lt;p&gt;그러므로, 이 DOM Element를 직접 등록하고자 하였던 나의 생각은 쉽지 않다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;결론&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;결국 나는 VanilaJS만을 사용하는 프로젝트에서 재 사용이 가능한 라이브러리를 만들기로 하였다,.&lt;/p&gt;
&lt;h3&gt;2. 컴포넌트는 로직에 대해 알지 못해야 함 (뷰와 로직의 분리)&lt;/h3&gt;
&lt;p&gt;이전에 작업을 수행하면서, 컴포넌트에(보통은 HTML 엘리먼트) 그 컴포넌트가 수행해야 하는 로직을 넣곤 했다. 그러나 라이브러리의 특성상 사용자가 원하는 컴포넌트에 직접 로직을 넣는 방식은 좋지 않다고 생각했다.&lt;/p&gt;
&lt;p&gt;즉, 사용자는 캐러샐 기능을 사용하기 위해 직접 컴포넌트에(HTML 엘리먼트) 접근하여 캐러셀 로직을 추가하면 안된다고 생각했다.&lt;/p&gt;
&lt;p&gt;그러기 위해서 정해진 어떤 컴포넌트에 접근하여 로직을 추가하는 방식(예를 들어, &lt;code class=&quot;language-text&quot;&gt;getElementById&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;getElementByTagName&lt;/code&gt; 등등) 보다는, 해당 컴포넌트에 대한 레퍼렌스를 캐러셀 라이브러리가 들고 있는 방식이 좋겠다고 생각했다&lt;/p&gt;
&lt;p&gt;그러기 위해서 캐러셀 라이브러리에 &lt;code class=&quot;language-text&quot;&gt;addComponenet&lt;/code&gt; 라는 메소드를 만들었고, 사용자는 이 메소드의 인자로 컴포넌트(HTML 엘리먼트)를 전달하면 되는 방식이다.&lt;/p&gt;
&lt;p&gt;이 &lt;code class=&quot;language-text&quot;&gt;addComponent&lt;/code&gt;에 Element가 들어가게 되면, 캐러셀 라이브러리는 캐러셀 작동에 필요한 값을 html custom attribute로 넣는다.(&lt;code class=&quot;language-text&quot;&gt;data-carousel-index&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;data-carousel-direction&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;그 후, 캐러셀의 작동을 위한 CustomEvent와 사용자가 캐러셀 작동을 원하는 추가적인 이벤트(&lt;code class=&quot;language-text&quot;&gt;click&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;mouseover&lt;/code&gt;등 DOM Event)를 해당 엘리먼트에 등록한다.&lt;/p&gt;
&lt;p&gt;마지막으로, 이 엘리먼트에 대한 레퍼렌스를 캐러샐의 내부 배열에 저장한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/**
 *
 * @param {HTMLElement} htmlElement
 * @param {Function} cb
 * @param {Object} option
 * @param {Object} events
 */&lt;/span&gt;
&lt;span class=&quot;token function-variable function&quot;&gt;addComponent&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;token parameter&quot;&gt;htmlElement&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  cb&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  option &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; index&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;elementList&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; direction&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  events &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; click&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; mouseover&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;isElement&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;htmlElement&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;option&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;index&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    htmlElement&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;setAttribute&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;INDEX_ATTR&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; option&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;index&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;option&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;direction&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    htmlElement&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;setAttribute&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;DIRECTION_ATTR&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; option&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;direction&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// adding default carousel event name&lt;/span&gt;
  htmlElement&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;addEventListener&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;EVENT_NAME&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;cbWrapper&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;handleActivation&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; cb&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// adding DOM api default events : click, mouseover,...&lt;/span&gt;
  Object&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;keys&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;events&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;forEach&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;eventName&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;events&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;eventName&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      htmlElement&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;addEventListener&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;eventName&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;cbWrapper&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;handleIndex&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; cb&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// adding given element to internal array to send event later&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;elementList&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;htmlElement&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 Carousel 클래스(UniCar) 사용 방법 (JS에서)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; carousel &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;UniCar&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;cb&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// some callback&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// target element, without direction&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; card &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;card&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
carousel&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;addComponent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;card&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; cb&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; index&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; val&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; direction&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// target element, with direction&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; rightButton &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;right-button&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
carousel&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;addComponent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;rightButton&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; cb&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; direction&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3. 하나의 이벤트에 대해서 다수의 컴포넌트가 반응해야 한다.&lt;/h3&gt;
&lt;p&gt;처음에는, 이 목표를 달성하기 위해서 Event의 capturing을 사용하려 하였다.&lt;/p&gt;
&lt;p&gt;상위의 엘리먼트에서 이벤트가 발생하면, 이 이벤트가 전파되어 하위의 모든 엘리먼트에 이벤트가 잡힐 줄 알았다.&lt;/p&gt;
&lt;p&gt;그러나, 생각과는 다르게 Event의 capturing은 Event가 발생한 곳 (CurrentTarget)까지만 찍고 다시 올라오는 것으로 확인 되었다.&lt;/p&gt;
&lt;p&gt;그러므로, 상위의 엘리먼트에서 이벤트를 Dispatch 시키더라도, 더 깊이 들어가는게 아니라 최상위에서 해당 엘리먼트까지만 들어갔다가 나온다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/images/eventflow.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;이미지 출처: &lt;a href=&quot;https://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/events.html&quot;&gt;https://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/events.html&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;따라서, &lt;strong&gt;[하나의 이벤트에 대해서 다수의 컴포넌트가 반응해야 한다]&lt;/strong&gt; 를 수행하기 위해서 다른 방법을 이용해야 하였고, Observer 패턴과 비슷한 방식으로 진행하였다.&lt;/p&gt;
&lt;p&gt;캐러셀 클래스 내부에는 Dispatch를 해야하는 대상 Element들이 배열로 저장되어 있다.&lt;/p&gt;
&lt;p&gt;이 배열을 순회하면서 하나하나씩 CustomEvent를 Dispatch 함으로서 원하는 결과를 만들 수 있었다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token function-variable function&quot;&gt;emmitEvent&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// send current index stored inside Carousell class&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; event &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;CustomEvent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;EVENT_NAME&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    detail&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      currentIdx&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;currentIdx&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// loop elements which needed to be dispatched&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;elementList&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;forEach&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; element&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;dispatchEvent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;event&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;다만, 이 방법에도 문제가 있는데, 여기에서 dispatchEvent 는 sync하게 돌아간다.&lt;/p&gt;
&lt;p&gt;그러므로, 처음에 구성하였던 async하게 동시다발적으로 이벤트가 전달되는 방법과는 차이가 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Unlike “native” events, which are fired by the DOM and invoke event handlers asynchronously via the event loop, dispatchEvent invokes event handlers synchronously. All applicable event handlers will execute and return before the code continues on after the call to dispatchEvent.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;출처: MDN&lt;/p&gt;
&lt;h2&gt;앞으로의 계획(현 프로젝트 중심)&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;캐로셀의 로직 부분(커맨더)만 따로 분리하여 오픈&lt;/li&gt;
&lt;li&gt;DOM CustomEvent의 명세에 따르면, Dispatch 작업은 sync하게 움직인다. 이를 async하게 바꿔주는 작업이 필요&lt;/li&gt;
&lt;li&gt;UI 부분의 우선순위는 가장 뒤로…&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;앞으로의 계획(부스트 캠프를 임하며)&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;좀더 구체적인 시간 분배&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1일차에는 전반적인 스케줄에 대한 계획 수렴 (체크 리스트 필수!)&lt;/li&gt;
&lt;li&gt;2일차에 최소한의 작동하는 형태로 구현&lt;/li&gt;
&lt;li&gt;3일차에 리펙토링&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;컨디션 되돌리기&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;충분한 휴식 필요&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;작업 템포 올리기&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데드라인을 금요일이 아닌, 수요일로 바꾼다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 맴버쉽 9]]></title><description><![CDATA[…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-membership/9/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-membership/9/</guid><pubDate>Tue, 03 Sep 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;오늘 고민한것&lt;/h2&gt;
&lt;h3&gt;복잡한 관계에서 어떻게 상호 작용 할것인가.&lt;/h3&gt;
&lt;p&gt;이번 과제에서 하나의 중심이 되는 값이 존재하고(보통 현재의 인덱스의 위치), 이 값에 다수의 방법으로 변화를 줄 수 있다.&lt;/p&gt;
&lt;p&gt;여기까지는 간단한데, 문제는 이 하나의 중심값이 변화가 되면, 그와 동시에 다수의 view에 변화가 생긴다.&lt;/p&gt;
&lt;p&gt;React와 같은 단방향 흐름에서는 데이터(state)에 변화를 주면 이에 맞추어 화면(view)가 다시 랜더링 된다.&lt;/p&gt;
&lt;p&gt;그러나 vanilaJS 다른 특별한 무언가를 설정하지 않는 이상 이러한 sync한 변화는 이루어 지지 않는다.&lt;/p&gt;
&lt;p&gt;그래서 이러한 값의 변화에 따른 동시 다발적인 화면 갱신을 수행하기 위해서 두가지 방법을 생각해볼 수 있는데, push와 pull인것 같다.&lt;/p&gt;
&lt;h3&gt;일단 push방법은 가장 직관적이고 구현이 간단하다.&lt;/h3&gt;
&lt;p&gt;쉽게 생각해서 button 을 클릭하였을 때 이에 대한결과로 값을 갱신하고, 동시에 화면을 수정하는 것이다.&lt;/p&gt;
&lt;p&gt;vanilaJS에서 보통은 button에 addEventListener를 걸어준 다음에, 화면을 갱신할 것이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;buttonEle&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;addEventListener&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;click&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  someRootIndex &lt;span class=&quot;token operator&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
  document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;navbar&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;style&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;background &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;red&quot;&lt;/span&gt;
  document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;card&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;style&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;background &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;green&quot;&lt;/span&gt;
  document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;content&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;style&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;background &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;blue&quot;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이를 그림으로 그리면 이러한 흐름이다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 334px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/daily-study/static/093b2be1290529c1d3a129064c7df6c2/86d36/Untitled-01fd088f-eff8-48b6-9a55-7b54ec6193b1.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 68.24324324324324%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsSAAALEgHS3X78AAACm0lEQVQ4y4VUTUgUYRj+ZN3msHnIS0TRD52C/i5dokNeYibCMsxV1w1/ttyd1cyKrKAgKgPbRtb0oK77o6tpEbVaUhgUpYcCGSpwN4sOUR2C6Br7ffT2fDu7ZcFuAy/f+87M+8zzvD/DWJ6rO6XB1IxvJLVl8Es6zSOlMq6NiuG6GE9XR/hXV0x8Qyztu7zPCgAWZc6kttpIqmHEASO5b5SI2dwxSvSbRMHnsFmi0Euicw+JDg3xB/8HTGlbAXhW+ldNz4osw77GuPiiT4ikZ0ws+ibE24a4eA/GffKhrTbKbZkzIqwzKljvhx1ZhuoWgLYt/Vh15Id93QWusIa0Uno6rbCmtLLpElc8o6I4L8NO82ixVT91G+yk9IOLZXZ/YraIFbrK+7m+v597Dwxw78FB7nWGuQ+FXpV7bqS09WDoXZrjiqZVZ1i0VQxm8nwVsJoI16FMZedRzFOTRCcSRPodosZxoqow3z3waeOu6wvlbkg+A4ZxgDoRt0rAqqGfCd8U8pBz7C7R8XtEh8eIAHqfBeaIDHSq6xnRlSdEfryEL5eFPm/YCQAXgDoAOIKzEnG7BUjTrSBycYaoe87Kq79NBIaPGGT6QVsHbR2+Dsl63RLJAFoLa/5H8l5IbocSHbl+iQGwFpiWt7YYEXt2DrdjsH83pWXqceGmgI1NmkuaNTI21OLP2KS0zdiSv8amMiSUPb3cgTl0NI0Kh3dcOOpHhAO5CqtFspw7zCJ8wSRYDWKA5AAxNlqH9C/P+0ssydxwD4t32Ix5yDZxmijVK+Qa+TclmVs9dU22y0GsXnySmL35Jk0b80SdT4luvCAKoKnX0ByAzhQsh/xBZIe7GP7yrtfulTIGux6s20dIftNySyzAX4DsFBj2/AKvDLZJ3axaqwAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Untitled 01fd088f eff8 48b6 9a55 7b54ec6193b1&quot;
        title=&quot;Untitled 01fd088f eff8 48b6 9a55 7b54ec6193b1&quot;
        src=&quot;/daily-study/static/093b2be1290529c1d3a129064c7df6c2/86d36/Untitled-01fd088f-eff8-48b6-9a55-7b54ec6193b1.png&quot;
        srcset=&quot;/daily-study/static/093b2be1290529c1d3a129064c7df6c2/12f09/Untitled-01fd088f-eff8-48b6-9a55-7b54ec6193b1.png 148w,
/daily-study/static/093b2be1290529c1d3a129064c7df6c2/e4a3f/Untitled-01fd088f-eff8-48b6-9a55-7b54ec6193b1.png 295w,
/daily-study/static/093b2be1290529c1d3a129064c7df6c2/86d36/Untitled-01fd088f-eff8-48b6-9a55-7b54ec6193b1.png 334w&quot;
        sizes=&quot;(max-width: 334px) 100vw, 334px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;그러나 여기서 문제는, 중심이 되는 값(someRootIndex)를 갱신하는 작업이 button뿐만 아니라 기타 다른 엘리먼트와의 인터렉션을 통해 생기는 경우 코드의 엄청난 중복이 생겨버린다. (코드를 넣지 않아도 느껴질것이라 생각한다)&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/daily-study/static/0fe1244fffc3b14e06ad8c43dd7eb359/4e6ec/Untitled-ddb78692-a2da-4888-b351-b16f4c71fec6.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 27.7027027027027%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsSAAALEgHS3X78AAABfklEQVQY02Oo3fqR2bf1P2PL2XTmSbdc7OrPROlnrvh/um7v///pK/7sYACC////M8Qu/MOg1/abIWPFb6byzR+YJSL+M3RcSGSZeMvZsfFMAkjPxZo9QIUw0Hc1jLv/hrsdiJ27+rtW8brf5tmr/qjC5J0m/WZAB91XQnmBelzAetZ81yla99sMqPnP5qQl/zMn3dXT7L/hGdZwOlU4btHfxswVv9dEL/xTDFKctfIP2ADHSb85k5b8mZu58s+2qPn/U6c/1NQC6omuOZ4P0tOaufL3aoayDX82py37nznhjp7mBKCBNSeTRRKX/G0sXPt7TSzUwNINEAMte35zpiz7M7dg7Z9tkUgGVh7LEwbqaQW6cDXc+f3XEF5OWPJdK3bRb3OgZriX7Sfg9zJQjw5QjxnDhIMfmeP7/zO2nktnnnDTxa7tQpR+xvL/p6t2//8P9Co8UuIW/WGQqfkFCiKm1l0fmEXD/jN0XgRGyk1nx9ZzCfoZwEip2vX/PwDu9M8dp3WoAQAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Untitled ddb78692 a2da 4888 b351 b16f4c71fec6&quot;
        title=&quot;Untitled ddb78692 a2da 4888 b351 b16f4c71fec6&quot;
        src=&quot;/daily-study/static/0fe1244fffc3b14e06ad8c43dd7eb359/fcda8/Untitled-ddb78692-a2da-4888-b351-b16f4c71fec6.png&quot;
        srcset=&quot;/daily-study/static/0fe1244fffc3b14e06ad8c43dd7eb359/12f09/Untitled-ddb78692-a2da-4888-b351-b16f4c71fec6.png 148w,
/daily-study/static/0fe1244fffc3b14e06ad8c43dd7eb359/e4a3f/Untitled-ddb78692-a2da-4888-b351-b16f4c71fec6.png 295w,
/daily-study/static/0fe1244fffc3b14e06ad8c43dd7eb359/fcda8/Untitled-ddb78692-a2da-4888-b351-b16f4c71fec6.png 590w,
/daily-study/static/0fe1244fffc3b14e06ad8c43dd7eb359/4e6ec/Untitled-ddb78692-a2da-4888-b351-b16f4c71fec6.png 827w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;그러나 이러한 방식의 가장 큰 문제는 코드의 중복이 아닌 재사용성이 꽝이 된다는 점이다.&lt;/p&gt;
&lt;p&gt;이 상황에만 사용할 수 있도록 코드가 상황에 종속되고, coupling되어 함수 내부 값을 바꾸지 않는 이상 재사용이 너무 어려워 지며, 이는 이전 과제에서 느꼈던 부분이다.&lt;/p&gt;
&lt;h3&gt;다른 방법은 없을까? ⇒Event &amp;#x26; Pull!!&lt;/h3&gt;
&lt;p&gt;두번째로 든 생각은 Observer방식이나 Event를 사용하여 값의 갱신과 화면의 변화를 분리하고, 이를 React처럼 단방향으로 갱신이 가능하도록 하는 방법이 없을까 하다 떠올랐다.&lt;/p&gt;
&lt;p&gt;사실, JS나 Node를 쓰는 상황에서 너무나 당연한 접근 방법이였는데, 이벤트 기반 처리에 익숙치 않아 바로 떠오르지는 않았다.&lt;/p&gt;
&lt;p&gt;아래와 같은 방식으로 CustomEvent를 생성하여 관리하면 더욱 편리할 것으로 기대 된다. .&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/daily-study/static/b12f70a3c1316ffd676d90e96d0b7c8b/8c76f/Untitled-8e444d39-625b-4b65-98d4-570c8638c6ec.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 39.86486486486486%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsSAAALEgHS3X78AAACGElEQVQoz2N4vl39LhA/A+LHQPzm5Q614/MPhXkv3B2dO2F5o13myv9nS9b//pa35t//yPm/oxmAwKVsGyuQMmNiZnRk42K2ZGZldAXybYFYjOHlXsufbw/a/H+93/b/52P2/1/tN32we0qF9YHGjpwt1bM90lf97ytY83t17uo/m6MW/LYHG1h5kpmNk5kPyFQDYlUg1mRkYpAG0swMr/Y7/Hx/zOv/myOe/7+c9v3/5oDTg/mHA13n7YtMm7G60SFi/v8zhWt/f0le+udf6Nw/USAD8/e8ZgHRW/7HiE994BM47ZGvHQMMAL356vl21U8vt6m+eb5N7cfznSqXb2ZPlr4ZtNr1aOIGm6jFfxtL1v2Zmbrsz4LQub8twS6sWsMMpNjcO2W4s89qiyXsVhME8plY2IHufLHDQuz0vkDFZWd9ws7tDlJ8fUJD6GLiAj0G/EAeiJ35mXjttFhVHJVYZUEuNANifbiKnqeiNjD2+YQlahfjFyfeip3Hg27Shv//GbR4xMFe3h7cp3gsalbY0aiZzqDw42blYGGInvdNLnPFjykF65+sTln6Y1LyrA+yIMVX4hZpHExZaxOz+n95zorf09KX/5kTv/iPOUhuwf//jDjdHjLnt0Xptv//a3f//58DtB4Y8IZwyen/ObNX/vlQt+///7oj//8nLf2TDhJOWPAF7MI4LS+GiY6FDDUWiWDlIFsABBLpkq99U2wAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Untitled 8e444d39 625b 4b65 98d4 570c8638c6ec&quot;
        title=&quot;Untitled 8e444d39 625b 4b65 98d4 570c8638c6ec&quot;
        src=&quot;/daily-study/static/b12f70a3c1316ffd676d90e96d0b7c8b/fcda8/Untitled-8e444d39-625b-4b65-98d4-570c8638c6ec.png&quot;
        srcset=&quot;/daily-study/static/b12f70a3c1316ffd676d90e96d0b7c8b/12f09/Untitled-8e444d39-625b-4b65-98d4-570c8638c6ec.png 148w,
/daily-study/static/b12f70a3c1316ffd676d90e96d0b7c8b/e4a3f/Untitled-8e444d39-625b-4b65-98d4-570c8638c6ec.png 295w,
/daily-study/static/b12f70a3c1316ffd676d90e96d0b7c8b/fcda8/Untitled-8e444d39-625b-4b65-98d4-570c8638c6ec.png 590w,
/daily-study/static/b12f70a3c1316ffd676d90e96d0b7c8b/8c76f/Untitled-8e444d39-625b-4b65-98d4-570c8638c6ec.png 612w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;이렇게 구성하면, 위의 예시에서 &lt;code class=&quot;language-text&quot;&gt;someRootIndex&lt;/code&gt; 를 갱신하는 작업이 이루어지고, 이후에 Event를 Dispatch 함으로서 해당 Event에 등록된 모든 엘리먼트들이 동시 다발적으로 변화(우리의 예시에서는 배경색 바꾸는 작업)가 실행이 가능해진다.&lt;/p&gt;
&lt;p&gt;이 접근 방법의 핵심은, 중심값을 갱신하는 작업과, 화면의 갱신이라는 두개의 큰 작업을 논리적으로 분리할 수 있다. 또한 결합을 줄임으로서 추후에 추가적인 작업(예를 들어 새로운 엘리먼트의 갱신)이 필요할때 적용이 용이하다.&lt;/p&gt;
&lt;p&gt;아직 이 방법으로 코드를 작성하지 않아서 어떤 어려움이 있을진 모르겠다.&lt;/p&gt;
&lt;p&gt;이 생각으로 코드를 작성한 뒤, 기록을 남기도록 하겠다.&lt;/p&gt;
&lt;h2&gt;마스터 클래스 정리&lt;/h2&gt;
&lt;h3&gt;promise는 무엇을 반환하는가?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;팬딩중인 프로미스를 반환한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;then은 언제 실행되는가&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;then의 줄을 접하는 순간 실행된다.&lt;/li&gt;
&lt;li&gt;여기서 중요한 부분은, then이 promise가 resolve되기를 기다렸다가 실행되는게 아니라,&lt;/li&gt;
&lt;li&gt;먼저 실행 되고 나서 then에 넘긴 callback이 promise가 resolve되면 실행되는 형태이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;then을 연속적으로 사용가능한 이유가 무엇인가&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;then 의 반환값은 Promise이기 때문에 .then으로 체이닝이 가능하다&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;setTimeout에서 16.66ms의 의미는?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;VSync 즉 모니터의 화면 갱신은 보통 60Hz이며, 다시말해 1000초에 60번 갱신되서 그 interval은 16.66ms(1000/60)이다.&lt;/li&gt;
&lt;li&gt;이를 맞추어 스무스 하게 화면을 보여주기 위한 트릭이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;오늘 느낀것&lt;/h2&gt;
&lt;h3&gt;prototype과 &lt;strong&gt;proto&lt;/strong&gt;에 대해 다 까먹고 있었다…&lt;/h3&gt;
&lt;p&gt;다시 정리하고, 기록하자… 너무 중요한 내용을 너무 쉽게 잊어버렸다.&lt;/p&gt;
&lt;h3&gt;Iterm2는 강력하고 아름답다&lt;/h3&gt;
&lt;p&gt;오늘 iterm의 터미널 화면에 변화를 주었다.&lt;/p&gt;
&lt;p&gt;심심했던 나의 화면이 아름답게 변화를 하니 코드를 칠 맛이 나는 것 같다.&lt;/p&gt;
&lt;p&gt;지난번에 마스터 님께서 주기적으로 view를 바꾸시던데, 오래 작업하기 위해서 이런 소소한 변화를 주는것도 좋은 방법인것 같다.&lt;/p&gt;
&lt;p&gt;화면 예시&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/daily-study/static/fccbf3a29dd246d404348fef863cc859/c6720/Untitled-6f6f30e2-0762-482f-a4aa-3789150680d9.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 27.027027027027025%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsSAAALEgHS3X78AAABB0lEQVQY0zWQyXKDMBAF5Q2MbXaBNhDYlGPn4P//vM5AkkPXqEaqnjdSxeWMsXbDGoOV6uOCG+64EPFSbW9wpsH7iktyIDvtCU2J0zXedHhn8LYnPycoL5JlecrjsAl9GIiPN9Pji3FaCCKf4sQcHfNsqG8Zl9MBL0KvZYjpN9lKKeHU5xmYbUmiFErQ+YnXWFFnkmSn2EmvzTPKLKVIU3R54yopD9Lfq9/7fzZHV+fEaZL1xi3dKOfH+8NwfzHMT+LyLSsFBt8xxoZreiTdK25Sg+2IwRHHwDh41u9T0TtZKdI2DV3b0mlNbzzGuI1+RbeYrsL0xZZuFWbHHbouMG1N/0eeJfwAPFx6exuUw/MAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Untitled 6f6f30e2 0762 482f a4aa 3789150680d9&quot;
        title=&quot;Untitled 6f6f30e2 0762 482f a4aa 3789150680d9&quot;
        src=&quot;/daily-study/static/fccbf3a29dd246d404348fef863cc859/fcda8/Untitled-6f6f30e2-0762-482f-a4aa-3789150680d9.png&quot;
        srcset=&quot;/daily-study/static/fccbf3a29dd246d404348fef863cc859/12f09/Untitled-6f6f30e2-0762-482f-a4aa-3789150680d9.png 148w,
/daily-study/static/fccbf3a29dd246d404348fef863cc859/e4a3f/Untitled-6f6f30e2-0762-482f-a4aa-3789150680d9.png 295w,
/daily-study/static/fccbf3a29dd246d404348fef863cc859/fcda8/Untitled-6f6f30e2-0762-482f-a4aa-3789150680d9.png 590w,
/daily-study/static/fccbf3a29dd246d404348fef863cc859/efc66/Untitled-6f6f30e2-0762-482f-a4aa-3789150680d9.png 885w,
/daily-study/static/fccbf3a29dd246d404348fef863cc859/c83ae/Untitled-6f6f30e2-0762-482f-a4aa-3789150680d9.png 1180w,
/daily-study/static/fccbf3a29dd246d404348fef863cc859/c6720/Untitled-6f6f30e2-0762-482f-a4aa-3789150680d9.png 1922w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;적용 방법: &lt;a href=&quot;https://gist.github.com/kevin-smets/8568070&quot;&gt;https://gist.github.com/kevin-smets/8568070&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;오늘의 회고&lt;/h2&gt;
&lt;p&gt;요즘 계속 10분씩 늦는다…&lt;/p&gt;
&lt;p&gt;팀원분들께 늦어서 죄송하다, 먼저 시작하시라 하는게 입버릇이 되버리는것 같다.&lt;/p&gt;
&lt;p&gt;나의 나태해진 모습을 반성하고, 내일부터 30분 일찍 캠프를 가도록 하자.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 맴버쉽 8]]></title><description><![CDATA[오늘의 배움 Express에서 미들웨어를 테스트하는 방법 Node 진영에서 사용할 수 있는 많은 테스트 라이브러리 들이 존재한다. 그중에서 나는 FE와의 통일성을 위하여 Jest…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-membership/8/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-membership/8/</guid><pubDate>Mon, 02 Sep 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;오늘의 배움&lt;/h2&gt;
&lt;h3&gt;Express에서 미들웨어를 테스트하는 방법&lt;/h3&gt;
&lt;p&gt;Node 진영에서 사용할 수 있는 많은 테스트 라이브러리 들이 존재한다.&lt;/p&gt;
&lt;p&gt;그중에서 나는 FE와의 통일성을 위하여 Jest를 정하였고, 다행히 이 도구가 어느정도 범용적인 용도를 갖고 있어 서버에서도 무난하게 녹아들 수 있었다.&lt;/p&gt;
&lt;p&gt;그러나 Server쪽의 테스트를 처음 접해보고, 그 중에서도 Middleware에 대해 처음 접해보니 테스트 코드를 어떻게 작성해야 하는지에 대한 의문이 들었다.&lt;/p&gt;
&lt;p&gt;테스트 코드, 그 중에서도 유닛 테스트를 작성하려 하는데 함수와는 다른 접근을 취해야 할 것 같았다 .&lt;/p&gt;
&lt;p&gt;예를 들어, 다음과 같은 코드가 있다고 가정하자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;doesBodyExist&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;req&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; res&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; next&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;req&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;body &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;isEmpty&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;req&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;body&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; res&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;400&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;default&lt;/span&gt; doesBodyExist&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;사실 따지고 보면, 그냥 보통의 함수 이지만 req, res,next를 전달받아서 next를 호출하거나 res를 호출하는 형태의 미들웨어이다.&lt;/p&gt;
&lt;p&gt;next는 어찌보면 Callback이라 볼 수 있기 때문에 무언가 로직을 삽입할 수 있지만, res는 그 속의 객체, 그리고 그 속의 객체에 접근해야 한다.&lt;/p&gt;
&lt;p&gt;처음에는 기타 라이브러리를 통해 인자의 mock을 생성하는 방법을 고민하였다. 그러나, 간단한 유닛테스트에 아직까지 별도의 모듈 설치의 필요성을 느끼지 못하여 제외하였다.&lt;/p&gt;
&lt;p&gt;그 다음에 생각한 방법이 supertest를 활용하여 app을 테스트 하듯 하는 방식이였다.&lt;/p&gt;
&lt;p&gt;이 경우에 매 테스트마다 다음과 같이 app 전체를 불러와야 한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; request &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;supertest&quot;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; app &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;../app&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// our Node application&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//...&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;describe&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;api 테스트&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;GET: api가 열려있어야 한다&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;app&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;url&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;expect&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;//...&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이 방식의 가장 큰 단점은, 테스트가 너무 무거워 진다는 것이다.&lt;/p&gt;
&lt;p&gt;통합테스트를 위해서 이렇게 작성하는 것은 무방하나, 각각의 기능을 테스트 하기 위한 유닛테스트에서는 적절치 않아 보였다 .&lt;/p&gt;
&lt;p&gt;그래서 나는 결론적으로 Jest의 기본적인 기능을 활용하여 임의의 mock을 생성하여 테스트 코드를 작성하였다.&lt;/p&gt;
&lt;p&gt;이 경우 jest를 벗어나서 추가로 종속적인 모듈을 설치하지 않아서 좋고, 가벼워서 더욱 좋다.&lt;/p&gt;
&lt;p&gt;이 방식의 핵심은, middleware를 단순히 인자 3개를 받는 보통의 함수로 생각하는 것이다.&lt;/p&gt;
&lt;p&gt;그러니깐, 우리의 Middleware는 인자 3개를 받고, 상황에 따라 아래 두 가지중 하나의 행동을 하는 함수이다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;next(3번째 인자)로 전달된 함수를 실행한다 (별 이상이 없어서 다음 middleware로 넘어가는 상황)&lt;/li&gt;
&lt;li&gt;res 의 어떠한 method에 어떠한 값을 넣어 실행한다. (보통 200, 400 등의 http status code이다)&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; doesBodyExist &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;../middlewares/checkBody&quot;&lt;/span&gt;

&lt;span class=&quot;token function&quot;&gt;describe&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;Middleware: 테스팅&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;describe&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;req.body 확인용 테스트&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; res &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      status&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; jest&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        json&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; jest&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;token function&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;body가 있으면 next가 실행된다&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; req &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        body&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;hi&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; next &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; jest&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;doesBodyExist&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;req&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; res&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; next&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;token function&quot;&gt;expect&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;next&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;toBeCalled&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;//..&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;다른 더 좋은 방법이 있을지 모르지만, 지금으로서는 나에게는 위 방법이 최선인것 같다.&lt;/p&gt;
&lt;h2&gt;오늘의 고민들&lt;/h2&gt;
&lt;h3&gt;스크럼&lt;/h3&gt;
&lt;p&gt;기존에 작성하였던 유저 스토리와, 이에 대한 백로그를 수정하였다. 크게 정해진 규칙 없이, 내 입맛대로 변형을 주었다.&lt;/p&gt;
&lt;p&gt;기존의 유저스토리에서는 FE에 대한 고려만 하고, 서버측 고려는 하지 않았다. 보통 유저 스토리는 유저의 관점에서 작성되므로 FE에 대한 내용만이 언급된다.&lt;/p&gt;
&lt;p&gt;나는 Server쪽의 내용을 정리하기 위해 &lt;code class=&quot;language-text&quot;&gt;유저 스토리&lt;/code&gt; 와 &lt;code class=&quot;language-text&quot;&gt;비하인드 스토리&lt;/code&gt; 로 나누어 정리하였다.&lt;/p&gt;
&lt;p&gt;이렇게 되면 유저 스토리에서는 유저와 App간의 인터렉션에 대해 정의할 수 있고,&lt;/p&gt;
&lt;p&gt;비하인드 스토리에서 App과 App간의 인터렉션에 대해 정의할 수 있다.&lt;/p&gt;
&lt;p&gt;지금으로서는 기능명세서를 스프린트 백로그 속에 포함 시켰지만, 갈수록 유저 스토리가 비대해져 가는것을 느낀다. 추후에는 이 부분을 따로 관리하는 방법에 대해 고민하도록 해야겠다.&lt;/p&gt;
&lt;h3&gt;Server 측의 테스트에 대한 고민&lt;/h3&gt;
&lt;p&gt;오늘부터 TDD의 원칙에 맞춰 코드 작성을 시작하였다.&lt;/p&gt;
&lt;p&gt;선 코드 작성 후 테스트 작성이 아닌, 빨간불, 초록불, 리펙토링의 순서를 지키고자 노력하였다.&lt;/p&gt;
&lt;p&gt;어제 가장 작은 기능 단위 부터 큰 덩어리인 API로의 순서로 TDD를 하려 하였는데, 필요한 기능을 사전에 모두 정의내리기 어려워서 더 논리적이고 순차적으로 접근할 수 있도록 큰것(api단위의 테스트)에서 작은것(세부 기능, 미들웨어 테스트) 으로 테스트를 점점 세분화 하는 시도를 하였다.&lt;/p&gt;
&lt;p&gt;작성을 하며 떠오른 두가지 생각이 있었다.&lt;/p&gt;
&lt;p&gt;첫번째는, 이렇게 코드를 작성하다 보니 내가 TDD를 하는것인지 BDD를 하는것인지 햇갈리기 시작했다.&lt;/p&gt;
&lt;p&gt;이 부분에 대한 명확한 이해가 없어서 생기는 혼란이라 판단되어, 추후 다시 한번 BDD와 TDD를 비교 분석해야 겠다.&lt;/p&gt;
&lt;p&gt;둘쨰로 내가 작성하는 테스트 코드가 충분한 커버리지를 갖고 있는지에 대한 의문이였다.&lt;/p&gt;
&lt;p&gt;시간을 들여 열심히 코드를 작성하였는데, 너무 큰 틈들이 듬성듬성 있으면 그것은 사실상 무의미한 시도라 생각한다.&lt;/p&gt;
&lt;p&gt;이 부분에 대해 어떻게 하면 적당히 납득할만한 커버리지를 갖는 테스트를 작성할 수 있는지 고민이 필요하다.&lt;/p&gt;
&lt;h3&gt;함수나 미들웨어는 어느정도로 파편화하여야 할까&lt;/h3&gt;
&lt;p&gt;함수나 미들웨어를 아주 작은 단위로 세분화할 수 있다.&lt;/p&gt;
&lt;p&gt;오늘 내가 내린 결정은, 단위 테스트가 가능할 정도의 수준으로 코드를 나누는게 좋겠다는 결론을 내렸다.&lt;/p&gt;
&lt;p&gt;이러한 방법이 단위테스트에도 좋지만, 코드의 재 사용성에도 좋을 것이라는 판단 에서이다.&lt;/p&gt;
&lt;h3&gt;테스트를 한글로&lt;/h3&gt;
&lt;p&gt;지난번에 어디선가 테스트 코드에 대한 문장을 한글로 작성하는 것에 대해 들은적이 있다.&lt;/p&gt;
&lt;p&gt;외국인들과 협업을 해야할 때나, 많은 이들이 참고해야 하는 Commit message의 경우 최대한 영어를 사용함이 좋지만,&lt;/p&gt;
&lt;p&gt;버그가 발생하였을 때, 문제에 대한 빠른 판단이 필요한 경우에는 모국어를 사용하는게 좋다는 생각이 든다.&lt;/p&gt;
&lt;p&gt;다수의 인원이 모국어가 영어가 아닌 상태에서, 실질적인 문제에 대한 원인과 힌트를 어색한 번역투의 영어로 작성하여 혼선을 주기보다는 명확한 해석이 가능하도록 모국어로 작성하는게 좋겠다.&lt;/p&gt;
&lt;h2&gt;오늘의 회고&lt;/h2&gt;
&lt;p&gt;전반적으로 만족스러운 하루였다.&lt;/p&gt;
&lt;p&gt;너무 느러지지도 않고, 너무 조급하지 않게 코드를 작성할 수 있었다.&lt;/p&gt;
&lt;p&gt;지난날들 처럼 거대한 산에 가로막혀 아무것도 못하는 상황이 되지 않도록, 최대한 잘게 잘게 세분화하여 점진적으로 코드를 작성하려 노력했다.&lt;/p&gt;
&lt;p&gt;그 결과 코드의 작성 과정에서 오는 스트레스가 많이 줄어든것 같아 만족스럽다.&lt;/p&gt;
&lt;p&gt;물론 아직 납기일에 코드를 완성해야 하는 부담감이 있어 무작정 코드 작성을 시작해야 하는게 아닌가 하는 ㄴ걱정은 있지만, 나를 믿고 최대한 많은 내용을 배워가기 위해 도전하고 있다.&lt;/p&gt;
&lt;p&gt;물론 결과가 중요하지만, 그 과정 또한 중요하다.&lt;/p&gt;
&lt;p&gt;항상 매 순간 최선을 다하자.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 맴버쉽 7]]></title><description><![CDATA[오늘의 배움 Node & Express를 사용하면서, DB연결에 대한 고민을 하였다. 우리의 경우에는 lowDB를 선택적으로 사용할 수 있었는데, 이에 대한 설정을 하는 부분에서 많이 배웠다. 1. Express…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-membership/7/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-membership/7/</guid><pubDate>Sun, 01 Sep 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;오늘의 배움&lt;/h2&gt;
&lt;p&gt;Node &amp;#x26; Express를 사용하면서, DB연결에 대한 고민을 하였다.&lt;/p&gt;
&lt;p&gt;우리의 경우에는 lowDB를 선택적으로 사용할 수 있었는데, 이에 대한 설정을 하는 부분에서 많이 배웠다.&lt;/p&gt;
&lt;h3&gt;1. Express의 흐름에서 비동기적으로 무언가를 어떻게 기다릴까?&lt;/h3&gt;
&lt;p&gt;물론, Async/Await 이나 then 등을 사용하면 된다.&lt;/p&gt;
&lt;p&gt;하지만, 동기적으로 보이는 로직에서 비동기 로직을 어떻게 포함할지 고민이였다.&lt;/p&gt;
&lt;p&gt;이에 대한 해결법은, Middleware를 활용함으로서 해결할 수 있음을 알게 되었다.&lt;/p&gt;
&lt;h3&gt;예시 코드&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; app &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;express&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; adapter &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;FileAsync&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;db.json&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// 비동기적으로 수행하는 Middleware&lt;/span&gt;
app&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;use&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;req&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; res&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; next&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; db &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;low&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;adapter&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;//...&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2. app등에서 설정한 객체등을 어떻게 전역적으로 활용할 수 있을까?&lt;/h3&gt;
&lt;p&gt;처음에는 scope와 closure를 활용하여, 변수를 선언하면 해결될줄 알았다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token function&quot;&gt;someAsync&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;innerVal&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;
  app&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;use&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;someMethod&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;innerVal&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;물론, 이렇게도 작동은 하지만 require나 import로 불러온 경우 then안에 포함되어 있어도 &lt;code class=&quot;language-text&quot;&gt;innerVal&lt;/code&gt; 이라는 지역 변수를 모듈등이 공유하지 않는것같다&lt;/p&gt;
&lt;p&gt;방법을 찾던 중 req 에 녹여 전달하는 방법이 생각났다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 비동기적으로 수행하는 Middleware&lt;/span&gt;
app&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;use&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;req&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; res&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; next&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; db &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;low&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;adapter&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;
  req&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;db &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; db
  &lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이렇게 작성하면, 이후에 나오는 모든 middleware등에서 &lt;code class=&quot;language-text&quot;&gt;req.db&lt;/code&gt;로 접근이 가능해진다.&lt;/p&gt;
&lt;p&gt;하지만, 이렇게 전체적인 App과 밀접한 관계를 갖는 정보의 경우 &lt;code class=&quot;language-text&quot;&gt;app.set&lt;/code&gt; &amp;#x26; &lt;code class=&quot;language-text&quot;&gt;app.get&lt;/code&gt; 을 활용함이 더 좋을것 같아서 다음과 같이 최종적으로 정리 하였다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 비동기적으로 수행하는 Middleware&lt;/span&gt;
app&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;use&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;req&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; res&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; next&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; db &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;low&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;adapter&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;
  app&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;db&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; db&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위와 같이 설정한다면, 이후에 나온 모든 middleware에서 &lt;code class=&quot;language-text&quot;&gt;app.get&lt;/code&gt; 으로 접근이 가능하다.&lt;/p&gt;
&lt;p&gt;또한 app이 선언되지 않았더라도 app은 기본적으로 &lt;code class=&quot;language-text&quot;&gt;req&lt;/code&gt; 에 포함되어 있으므로, &lt;code class=&quot;language-text&quot;&gt;req.app.get&lt;/code&gt; 접근이 가능하다.&lt;/p&gt;
&lt;h2&gt;오늘의 고민들&lt;/h2&gt;
&lt;h3&gt;Server 측의 테스트에 대한 고민&lt;/h3&gt;
&lt;p&gt;이전에 기능단위의 테스트를 작성하는 것은 익숙해 졌다.&lt;/p&gt;
&lt;p&gt;하지만, 서버측에서는 이러한 기능단위의 유닛 테스트를 포함하여 통합테스트 등을 더 고민해야 하고,&lt;/p&gt;
&lt;p&gt;그 순서가 명확하게 보이지 않아서 고민을 많이 하고 있다.&lt;/p&gt;
&lt;p&gt;FE에서 테스트를 작성하지 못하여 반성 했던 만큼, 이번에는 꼭 테스트를 통한 TDD로 접근을 할것이다.&lt;/p&gt;
&lt;h3&gt;앞으로의 테스트에 대한 고민&lt;/h3&gt;
&lt;p&gt;테스트는 한글로 작성해보자 .&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;어차피 빠른 체크가 목적이므로!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;큰거에서 작은걸로 가는게 좋을까? 작은거에서 큰것으로 가는게 좋을까?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;예를 들어, API를 테스트하는 코드를 작성한 뒤 개별적인 세부 기능에 대해 좁혀가는게 좋을까&lt;/li&gt;
&lt;li&gt;아니면 반대가 좋을까&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;기능 명세서와 TDD의 관계는 어떻게 될까&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;스크럼에서 작성하게 될 유저 스토리와 세부 스프린트 작업 사이의 관계는 어떻게 될까&lt;/li&gt;
&lt;li&gt;지금까지의 느낌으로는, 스크럼을 통해 거시적인 (기술적으로는 조금은 두루뭉실한) 명세를 작성하고,&lt;/li&gt;
&lt;li&gt;이를 개별 기능 명세서를 통해 구체화 하는 방향으로 고민중이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;추가로 학습해야 할 키워드&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;json RPC&lt;/li&gt;
&lt;li&gt;1차원 데이터 ( B-tree), 2차원 데이터 ( R-tree &amp;#x26; R*tree)&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;eventEmitter 에서 on 도 있지만, once 도 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;once 의 경우에 한번 event를 받으면, 리스너가 자동으로 제거된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;winston 모듈, 로그를 남기고 &amp;#x26; 모으는 방법에 대해 알아보자&lt;/li&gt;
&lt;li&gt;SuperTest를 이용한 API Testing&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 맴버쉽 6]]></title><description><![CDATA[마스터 클래스 정리 TCP소켓과 웹소켓의 차이, 브라우저에서 왜 필요한지 생각해보자 브라우저 없이 TCP/IP…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-membership/6/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-membership/6/</guid><pubDate>Sat, 31 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;마스터 클래스 정리&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;TCP소켓과 웹소켓의 차이, 브라우저에서 왜 필요한지 생각해보자&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;브라우저 없이 TCP/IP 소켓에 직접 연결한다면, 연결 자체(반환된 객체값)가 고유 식별자가 될 수 있다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;그러므로 통신에서 별도의 인증에 관련한 정보를 녹일 필요가 없다&lt;/li&gt;
&lt;li&gt;그러나, 브라우저의 경우 웹소켓 등과 같은 방법으로 연결을 유지해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;쿠키의 유지 주체는 클라이언트, 생성 요청은 서버가 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;쿠키는 key-value 형태의 데이터 이다&lt;/li&gt;
&lt;li&gt;쿠키는 key 같은 키값을 통해 value를 업데이트 할 수 있다.&lt;/li&gt;
&lt;li&gt;삭제는 클라이언트에서 만료시간에 따라 진행한다.&lt;/li&gt;
&lt;li&gt;만료시간은 서버가 설정한다.&lt;/li&gt;
&lt;li&gt;세션은 유저 정보가 아닌 고유의 세션 ID 를 생성하여 제공한다&lt;/li&gt;
&lt;li&gt;이 또한 hash map으로 ID를 키값으로 제공한다.&lt;/li&gt;
&lt;li&gt;세션 ID는 무작위 탈취가 어렵도록 uuid와 같은 복잡한 값을 사용한다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;세션 DB에 유저 정보가 너무 안들어가면, UserDB를 계속 조회해야 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;그래서 세션 DB에 최소한의 필요한 요소를 기본적으로 넣어야 한다.&lt;/li&gt;
&lt;li&gt;최대한 다른 DB를 적게 조회 하도록 하자.&lt;/li&gt;
&lt;li&gt;쿠키가 메모리에 들어가 있음에도, 껏다 켯을때 살아 있는 이유는 파일로 저장되기 때문이다!!&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;console.log 하지 말고 breakpoint사용하자! 강제적으로&lt;/li&gt;
&lt;li&gt;테스트 자동화 도구를 사용해보자 (아이디, 패스워드 100번식 누르지 말자)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;현재 공부하고 있는 부분&lt;/h2&gt;
&lt;h3&gt;1. git commit message convention&lt;/h3&gt;
&lt;p&gt;팀별로 다양한 convention이 있는듯 하지만, 그럼에도 잘 다듬어진 사례들을 정리함이 중요하다.&lt;/p&gt;
&lt;p&gt;그 중에서도 &lt;a href=&quot;https://github.com/angular/angular/blob/22b96b9/CONTRIBUTING.md#-commit-message-guidelines&quot;&gt;Angular의 commit message guideline&lt;/a&gt;을 많이 활용하는 것 같다.&lt;/p&gt;
&lt;p&gt;나 또한 이 가이드라인을 바탕으로 내 커밋 메세지의 규칙을 만드는 과정에 있다.&lt;/p&gt;
&lt;p&gt;이러한 스타일링을 강제하는 도구들도 있고, 도움을 주는 도구들도 있는듯 하니 잘 찾아보는것이 좋겠다.&lt;/p&gt;
&lt;p&gt;이와 더불어 Git flow등에 대한 학습을 다시 시작해야 한다.&lt;/p&gt;
&lt;h3&gt;2. OAuth 2.0 specification&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6749&quot;&gt;공식 명세 링크&lt;/a&gt; :&lt;/strong&gt; 오늘부터 이 글을 천천히 읽고 있다.&lt;/p&gt;
&lt;p&gt;모던 웹 환경에서 OAuth2.0에 대한 이해는 필수적이다. 특히, 어떤 규칙과 관계를 갖고 있는지 파악하는게 중요하다 생각해 공부를 시작했다.&lt;/p&gt;
&lt;p&gt;그 전에는, 다양한 블로그나 동영상으로 관련 내용을 알아봤는데… 다 각각 용어나 내용에 차이가 있었다.&lt;/p&gt;
&lt;p&gt;아무래도, 공식자료를 기반으로 개개인의 해석이 섞여 들어 용어등의 정의나 사용에 난해함이 생겼다.&lt;/p&gt;
&lt;p&gt;그러다가 우연히 위 문서를 읽어보게 되었고, 명확하고 간결한 내용에 쉽게 이해를 할 수 있었다.&lt;/p&gt;
&lt;p&gt;항상 공부하며, client는 무엇인지, role은 무엇인지, grant types은 무엇들이 있는지, 그리고 이것들이 어떻게 조화를 이루는지 이해하기 어려웠는데, 8쪽까지만 읽은 현 상황에서 대충 감이 올 정도록 내용이 간결하다.&lt;/p&gt;
&lt;p&gt;70여쪽의 짧은 문서이므로 빠른 시간내에 내용을 모두 읽어보고 정리하도록 하겠다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 맴버쉽 5]]></title><description><![CDATA[프로젝트 회고 오늘로서 1주일차 FE…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-membership/5/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-membership/5/</guid><pubDate>Fri, 30 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;프로젝트 회고&lt;/h2&gt;
&lt;p&gt;오늘로서 1주일차 FE개발이 완료되었다.&lt;/p&gt;
&lt;p&gt;만족하는 부분도 있지만, 아쉬움이 많이 남는 프로젝트이다.&lt;/p&gt;
&lt;p&gt;첫주차에 텐션이 너무 떨어져 있어서 개발에 집중을 하지 못했고, 컨디션도 좋지 않았다.&lt;/p&gt;
&lt;p&gt;지난 회고에서 언급하였듯이 이는 그저 불필요한 변명일 뿐이고, 실수를 반복하지 않도록 하는 고민이 필요하다.&lt;/p&gt;
&lt;h3&gt;아쉬웠던 부분들…&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;시간 분배를 잘 하지 못했다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;처음에 시간을 잘 산정하고, 이를 주기적으로 수정하는 작업이 필요했다.&lt;/p&gt;
&lt;p&gt;아직 기능 단위별로 시간을 분배하는 작업이 익숙치 않았고, 이에 따른 점검도 쉽지 않았다.&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;테스트를 전혀 작성하지 못했다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;크게 아쉬웠던 부분중 하나인데 코드 작성에 급급하여 테스트를 전혀 작성하지 못했다.&lt;/p&gt;
&lt;p&gt;TDD로 할까, BDD로 할까 고민하다가 그냥 코드 작성부터 했다.&lt;/p&gt;
&lt;p&gt;잘 모르는 방식(여기서는 vanila JS를 비롯한 web API)일수록 테스트를 굳건히 작성해야 더 효과적인데,&lt;/p&gt;
&lt;p&gt;이를 간과하고 있었다.&lt;/p&gt;
&lt;p&gt;테스트는 선택이 아닌 필수임을 명심하자.&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;기능 구현을 완료하지 못했다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;엔지니어나 개발자에게 시간 약속은 아주 중요하다.&lt;/p&gt;
&lt;p&gt;상황이 어찌 되었든, 정해진 시간에 약속한 퀄리티의 제품을 만들지 못하였던 부분에 반성해야 한다.&lt;/p&gt;
&lt;p&gt;잘못된 부분이나, 실수한 부분을 바로잡고 다음 작업에서 개선하자.&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;데일리 회고를 빼먹었다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;노트에 적긴 하였지만, 이에 대한 내용을 기록하지 않았다.&lt;/p&gt;
&lt;p&gt;해야 함을 알지만, 스트레스가 많이 쌓여서 무엇을 하고싶지 않았던것 같다.&lt;/p&gt;
&lt;p&gt;이제 컨디션이 돌아왔으니, 이 컨디션을 최대한 유지하도록 하자.&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;Observer 패턴을 사용하지 못했다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이해가 부족하여 활용을 하지 못했다. 이 부분에 대한 추가 학습이 필요하다.&lt;/p&gt;
&lt;h3&gt;잘했던 부분&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;구조에 대한 고민을 많이 하였다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;처음 과제를 접하였을 때 부터 마음 먹은 부분은, 이 과제를 통하여 새로운 기술과 구조에 대한 사고를 강화하는 것이였다.&lt;/p&gt;
&lt;p&gt;어떻게 보면 흔하고, 뻔한 과제처럼 보이지만 그 속에서 내가 원하는 것을 얻기 위해 한 선택이였고, 많은것을 얻을 수 있었다.&lt;/p&gt;
&lt;p&gt;자주 사용하는 ReactJS와 router등을 굉장히 low level의 api를 사용하여 모방할 수 있었고, 이는 전반적인 흐름을 이해하는데 큰 도움이 되었다.&lt;/p&gt;
&lt;p&gt;또, Component로 재사용이 가능한 Template을 만들고자 하였던 노력을 통해 새로운 기술들을 많이 접할 수 있었다. (Template tag, tagged template literal, 다양한 event관련 함수들)&lt;/p&gt;
&lt;p&gt;언젠간 이런 말을 마스터님께 들었던것 같다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;개구리를 이해하려거든 해부가 아닌 창조를 해봐라..?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;새로운것을 많이 접하고, 편법이 아닌 언어와 API가 설계된 방향으로 구현하고자 노력했다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이번 기회를 통해 web API의 다양한 API들에 대해 이해할 수 있었다.&lt;/p&gt;
&lt;p&gt;예를 들어, HTML Element에 직접적으로 &lt;code class=&quot;language-text&quot;&gt;onclick&lt;/code&gt; 이나 &lt;code class=&quot;language-text&quot;&gt;onfocusout&lt;/code&gt; 등이 어떨때 쓰이고 못쓰이는지,&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;button&lt;/code&gt; 엘리먼트에는 어떤 속성들(reset, button, submit 등)이 있고, 어떤 기능을 하며 어떻게 활용하는지 등등.&lt;/p&gt;
&lt;p&gt;최대한 HTML Element와 WEB API가 제공하는 기능만을 사용하며, 이를 내 임의대로 우회하지 않으려 노력했다. (이번 과제 자체가 워낙 많이 쓰이는 예시이기에 이 기능들이 구현되어 있지 않을 수 없다는 판단하에)&lt;/p&gt;
&lt;h3&gt;발전된 모습을 위해 실천할 구체적인 액션&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;테스트 코드부터 작성한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;일단 BDD등을 생각하지 말자. 무조건 TDD로 작성하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;요구 사항 분석에 소요 시간을 필히 명시한다.&lt;/li&gt;
&lt;li&gt;요구 사항 분석을 Github이슈에 넣고, 이를 Commit message로 관리한다.&lt;/li&gt;
&lt;li&gt;통일된 규격의 Commit message를 사용한다.&lt;/li&gt;
&lt;li&gt;가장 작은 단위의 유의미한 함수가 생성될때마다 commit을 남긴다.&lt;/li&gt;
&lt;li&gt;주어진 시간 최선을 다한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;마스터 클래스 정리&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;코드의 불필요한 변경이 쓰이기 때문에 console.log보다는 breeakpoint와 같은 디버깅 도구를 사용하자&lt;/li&gt;
&lt;li&gt;문자열을 별도의 파일로 분리하여 관리하자&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;회고에 속도를 포함하자&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;원래 어떻게 하려 했는데, 어떻게 되었는지&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;동사 + 명사 순서로 네이밍하&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;if가 중첩되면 스텝마다 기억해야할 정보가 많아짐&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;상위 if에서 사전에 returen하자&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;함수를 극단적으로 분리하자&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;모든뷰를 반응형으로 하려면 힘듬.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;모바일/데스크톱, 그리고 세부적으로 반응형으로 전략&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;객체를 중첩하여 변수명을 줄여보자&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/// 이렇게 적을수도 있지만...&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;validateEmailNow&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// 이렇게 접근할 수도 있다.&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  validate&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    id&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    email&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token function-variable function&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;이벤트 위임에 대해 공부하자&lt;/li&gt;
&lt;li&gt;switch case 구조 제거하는 방법 (mapping 만들기)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 이렇게 switch-case로 접근할 수 있지만,&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;a&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;break&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// 이렇게 mapping을 만들고,&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// key값으로 접근함으로서 switch/case를 제거할 수 있다.&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; tmp &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function-variable function&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token function-variable function&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;a&quot;&lt;/span&gt;
tmp&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;name&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 맴버쉽 4]]></title><description><![CDATA[…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-membership/4/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-membership/4/</guid><pubDate>Thu, 29 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;오늘의 학습&lt;/h2&gt;
&lt;h3&gt;전반적으로…&lt;/h3&gt;
&lt;p&gt;이번주 내내 컨디션이 좋지 않다.
오늘은 감기까지 걸린듯 하여, 과제에 집중을 하질 못했다.&lt;/p&gt;
&lt;p&gt;컨디션을 회복하기 위해서 너무 성급하고 부담되는 페이스로 개발하기 보다는, 느슨하고 여유롭게 개발하였다.&lt;/p&gt;
&lt;p&gt;오늘 한 작업들도 어제의 작업의 연장선으로서 폴더와 파일의 구조를 짜는데 시간을 사용하였다.&lt;/p&gt;
&lt;p&gt;웹팩을 사용하여 여러 JS 파일(모듈화 된)들과 CSS, 그리고 HTML 파일들을 번들링 하고, 이를 라이브 리로딩 가능하게 구성하였다.&lt;/p&gt;
&lt;p&gt;그 후에는 react의 느낌이 나게 HOC를 이용하여 무언가 재사용이 가능한 컴포넌트를 만들어 보려 노력하였다.&lt;/p&gt;
&lt;p&gt;대충 구현은 되었지만, 더 많은 고민이 필요할듯 하다.&lt;/p&gt;
&lt;p&gt;개발 외에도 스크럼과 칸반을 이해하려 노력하였다.
스크럼에서의 epic과 user story를 작성하는 방법, 그리고 이 스토리에서 어떻게 세부 테스크를 나누는지 찾아봤다.&lt;/p&gt;
&lt;p&gt;오늘까지만 여유를 부리고, 컨디션을 회복하여 내일 더 열정적으로 개발을 해야 겠다. (이번주 내에 회복되면 좋겠다.)&lt;/p&gt;
&lt;h2&gt;오늘의 배움&lt;/h2&gt;
&lt;p&gt;아직도 스크럼에 대한 명확한 실행 방안을 모르겠다.&lt;/p&gt;
&lt;p&gt;특히 오늘 내가 가장 궁금했던 부분은&lt;/p&gt;
&lt;p&gt;유저 스토리로 구성된 덩어리(에픽에서 잘려 나왔지만, 그래도 여전히 큰 덩어리이다.)를 바탕으로 어떻게 개발자의 기능 명세서가 작성되는 지 였다.&lt;/p&gt;
&lt;p&gt;개발자의 기능 명세서를 유저 스토리에 포함해야 하는지,&lt;/p&gt;
&lt;p&gt;아니면 개발자가 명세서를 작성하여 BDD, TDD등을 활용하여 지지고 볶으며 개발하는 건지…&lt;/p&gt;
&lt;p&gt;그런데, 계속 찾아볼수록 획일화된 규칙이 존재하지 않는 방법론이라는 느낌이 강하게 든다.&lt;/p&gt;
&lt;p&gt;지금까지 받은 느낌으로 스크럼은, 그 정신과 철학을 바탕으로 각각의 팀이 상황에 맞게 조절해 가며 사용하는 프레임워크인듯 하다.&lt;/p&gt;
&lt;p&gt;즉, 전반적인 방향(에픽, 유저스토리, 스토리보드, 스크럼 마스터, PO등등)은 유지하되, 그 안에서 어떻게 작업을 나누고 소요시간을 계산하는지 등등은 각각의 팀의 결론에 맡기는것 같다.&lt;/p&gt;
&lt;p&gt;위에서 고민한 &lt;code class=&quot;language-text&quot;&gt;user story&lt;/code&gt;-&gt; &lt;code class=&quot;language-text&quot;&gt;개발자의 기능 명세서&lt;/code&gt;(체크박스) 로의 전환은 결국 팀의 선택에 맡기는 문제인것 같다.&lt;/p&gt;
&lt;p&gt;그래서 나는 하나의 큰(사실 에픽이 큰거고, 이건 중간 사이즈)의 User story 내부에 스프린트 백로그 라는것을 넣어서 세부적으로 기능 명세서를 포함하는 형태로 가져갔다.&lt;/p&gt;
&lt;p&gt;그리고, 작업현황을 체크박스로 두어 Github의 Project에 반영되도록 하였다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/daily-study/static/b3d126a8f1d3df255b3de8dafb30d7a3/68638/1.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 125.67567567567568%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAZCAYAAAAxFw7TAAAACXBIWXMAABYlAAAWJQFJUiTwAAAC7klEQVQ4y5VV23baMBDk//sRfekn9B96eto0fSmQBEzCzQZ8t+W7Pd1ZcAMJbqnOWa8kW+PRanY1Sk0GNwgR7rfYWWPEzhJxHOPg+dgdXIRRDM8P4OwOiOIEQRjBF6Pf7V0kqcHe9eDKN/x2VBU1ClMgLyqYvESa5UiNQZKkyPICTdOirhtUVX3sN42O6cuqQtO2+q6q+b7B6Nv4Hl/Hd3iczWBZC4wnU/waTzCZPuDg+ui6Dq0sot3SRp+2n/HB+oh16MAkRlhlyLIMRljS+n4s222FgTb5iTzemL7AaC6sDn6IJCsRpZn4AomEgOM0rxAzHGWDou7E2pO/tLxq9dtK+qMv339ivt5j60ZY7UPYXiqWqN8FRn1gaiQlEBfdO0vEwqzRb00pgCTaCuPVeqPxGmp8N2T9ltuOgBr0Dq7nwbYdOM5OZfMvkGtGnCND6exFc8vlSpkGYXgG+HoO/wXYNz8IlClPl80TgS8WzwiC8K+s/2xZJ2RAlW+2NtZi9GS62x9UxMwmCrdf+DbWF4A9w6woBWSLmfWMl9UGq40tbCPJhkazpyirC8BBhuw0AlhLWjE/yWwrB+MIO4KQYSE/q8TfzJCAXMDcJbOlMHW9QOZaBTUyX1b17Qy5ZSZ2JcmuKScHwsTvFzOPzxcOtQvAJykOdz/ukabpzYIekI2wk0LiJTXiJFF5UIe+76vY61NBuAmwOwFKqDBdGyldD5g+0B4xn1u6/XOw4bS82LIciJCY2Tken6QmLhaafs0As9dSNRjD45ZjVhSp0qmUdFbgt/LozhYxVm13xfrUy0UWi+VaMyOMIr0nCE7PMdOPP6L1lbsbiKsCUrirrSMl30MkAMZkav3dwmqtfVEA41qKNimrczldBWTF4WLqsLcszxWINx7BqQIy5Vxd1+/irIBlWcJ6WcGWwwgl/foF9JQQ5RQrU16pr9u/dnAj5iz/zuKQnraaS/9ohbDMNSWPlitrznPMw9MrldesGK/Z3/hamu/jDqiAAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;1&quot;
        title=&quot;1&quot;
        src=&quot;/daily-study/static/b3d126a8f1d3df255b3de8dafb30d7a3/fcda8/1.png&quot;
        srcset=&quot;/daily-study/static/b3d126a8f1d3df255b3de8dafb30d7a3/12f09/1.png 148w,
/daily-study/static/b3d126a8f1d3df255b3de8dafb30d7a3/e4a3f/1.png 295w,
/daily-study/static/b3d126a8f1d3df255b3de8dafb30d7a3/fcda8/1.png 590w,
/daily-study/static/b3d126a8f1d3df255b3de8dafb30d7a3/efc66/1.png 885w,
/daily-study/static/b3d126a8f1d3df255b3de8dafb30d7a3/c83ae/1.png 1180w,
/daily-study/static/b3d126a8f1d3df255b3de8dafb30d7a3/68638/1.png 1510w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;구조 예시&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;회고&lt;/h2&gt;
&lt;p&gt;컨디션이 좋지 않다.&lt;/p&gt;
&lt;p&gt;하지만, 컨디션을 조절하고 유지하는것 또한 실력인듯하다.&lt;/p&gt;
&lt;p&gt;지금 내가 하고자 하는 일이 단거리 전력질주가 아닌, 장거리 마라톤임을 기억하고 체력 분배를 잘 하도록 하자.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 맴버쉽 3]]></title><description><![CDATA[…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-membership/3/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-membership/3/</guid><pubDate>Wed, 28 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;오늘의 학습&lt;/h2&gt;
&lt;h3&gt;전반적으로…&lt;/h3&gt;
&lt;p&gt;오전에는 팀원들끼리 모여 미션에 대한 얘기를 나눴다.
나는, 팀원들끼리 역할을 분담하여 각자의 파트를 개개인이 수행하는것이라 오해하고 있었는데, 다행이 초반에 팀원분께서 이 오해를 바로잡아 주셨다.&lt;/p&gt;
&lt;p&gt;오전 시간에는 스크럼의 형태로 진행하고자 하였는데, 잘 이뤄진것 같지는 않다.&lt;/p&gt;
&lt;p&gt;기능의 소요 시간과 중요도를 파악하고, 분류하는 작업이 체계적으로 이루어 지지 못했고,&lt;/p&gt;
&lt;p&gt;아이디어를 공유하였지만, 이에 대한 구체적인 스토리 분류와 포인트를 지정하지 못했다.&lt;/p&gt;
&lt;p&gt;스크럼은 불과 두달전에 읽었던 책의 핵심 내용인데, 그 방법들을 대부분 잊고 있었다는 생각이 들어 반성하게 되었다.&lt;/p&gt;
&lt;p&gt;오후시간에는 강의와 과정이 느슨한 템포로 진행 되었다.&lt;/p&gt;
&lt;p&gt;단방향적인 강의와 짧은 미션 보다는, 생각을 오래 하고 설계할 수 있는 미션을 좋아하는데 오늘 그러한 미션이 주어져 앞으로의 활동이 기대된다.&lt;/p&gt;
&lt;p&gt;미션과 더불어 HTML, CSS, JS에 대한 내용이 간단하게 언급되었다.
대부분 이미 알고 있는 내용이기에 크게 깨닳음을 얻지는 못한것 같지만, React를 활용하며 잊고 있던 내용들을 다시 한번 정리하는데 도움이 되었다.&lt;/p&gt;
&lt;h2&gt;오늘의 배움&lt;/h2&gt;
&lt;p&gt;책을 단순히 읽기만 해서 얻어지는건 크게 없다.&lt;/p&gt;
&lt;p&gt;두달전에 스크럼에 대한 책을 한권 읽었지만, 막상 스크럼 회의를 하고, 스크럼에 맞춰 백로그등을 작성하려하니 떠오르는게 없었다.&lt;/p&gt;
&lt;p&gt;방법적인 부분에 대해서 다시한번 찾아보고 숙지할 필요가 있다.&lt;/p&gt;
&lt;p&gt;책을 한권 읽었다고 그 내용이 머릿속에 들어가는게 아님을 항상 기억하자.&lt;/p&gt;
&lt;p&gt;오늘 미션이 끝나고, 남은 시간에 opensource project에 contribution 을 해보는 시도를 하였다.&lt;/p&gt;
&lt;p&gt;이 과정속에서도 짧은 시간이지만 많은 생각이 들었고, 이 내용은 부스트 캠프와는 직접적인 연관이 없으므로 따로 정리하도록 하겠다.&lt;/p&gt;
&lt;h2&gt;영감을 준 말들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HTML은 문서일 뿐이다.&lt;/li&gt;
&lt;li&gt;CSS를 잘하고 싶다면 레이아웃을 공부해보길 추천한다.&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 맴버쉽 2]]></title><description><![CDATA[…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-membership/2/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-membership/2/</guid><pubDate>Tue, 27 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;오늘의 학습&lt;/h2&gt;
&lt;h3&gt;전반적으로…&lt;/h3&gt;
&lt;p&gt;어제와 비슷하게 두명의 마스터님들이 오셔서 강의형식으로 진행되었다.&lt;/p&gt;
&lt;p&gt;멤버쉽 과정을 시작하기 앞서 몸풀기 단계의 템포로 진행되었으며, 오늘은 주로 멤버쉽동안 어떻게 프로젝트를 진행하게 될지에 초점이 맞춰졌다.&lt;/p&gt;
&lt;p&gt;이와 더불어, 실제 프로젝트 중에 해야할 코드리뷰, 스크럼 등의 방법들이 주제로 다뤄졌다.&lt;/p&gt;
&lt;p&gt;강의 중간 중간에 짧은 시간동안 코드리뷰와 회고등을 진행할 시간이 있었다.&lt;/p&gt;
&lt;p&gt;하지만 이 시간이 맛보기 형식으로 진행되어 그 의미를 느끼기에는 부족하였던것 같다.
프로젝트를 진행하며 그 의미와 필요를 찾아가야겠다.&lt;/p&gt;
&lt;p&gt;한정된 시간속에서 애자일과 스크럼, 그리고 코드리뷰의 가치등을 훑기에는 부족한 시간이였을 것이다.&lt;/p&gt;
&lt;p&gt;그러나, 하나하나 중요한 주제 이므로, 이번 강의는 길을 밝혀주는 정도로 생각하고 자세한 부분은 스스로 찾아보도록 해야겠다.&lt;/p&gt;
&lt;h2&gt;오늘의 배움&lt;/h2&gt;
&lt;p&gt;스크럼에 대해 다루면서 체크리스트에 대한 내용이 나왔다.&lt;/p&gt;
&lt;p&gt;중요함을 알고있었지만, 지금 내가 하고 있는 코드에 적용을 하고 있지 않은 나의 상황이 문득 떠올랐다.&lt;/p&gt;
&lt;p&gt;출석 관리 서비스를 개발하며 모든 내용이 혼자만의 머릿속에 있으니, 규칙없이 옛날처럼 마구자비로 개발을 하고 있엇다.
또 한정된 시간안에 개발해야 한다는 압박감에 코드의 품질에 타협을 봤던것 같다.&lt;/p&gt;
&lt;p&gt;이에 반성하고, 강의 시간이 끝난 뒤 나의 세부 프로젝트 별로 간단하게 기능과 체크리스트를 작성하였다.&lt;/p&gt;
&lt;p&gt;너무 복잡하지 않고 린하게 가기 위해 모든 체크 포인트는 GITHUB의 issue와 PR그리고 Project를 사용하기로 결정하였다. (처음엔 지라를 사용할까 하였지만… 배보다 배꼽이 커지는 상황이 오므로 린하게 가기로 마음먹었다.)&lt;/p&gt;
&lt;p&gt;항상 느끼는 것 이지만, 내가 아는 내용일지라도 그 속에서 께닳음을 얻을 수 있는것 같다.&lt;/p&gt;
&lt;p&gt;좋은 사람, 좋은 주제의 이야기들은 아무리 알고 있더라도 흘려 듣지 말고 깊이 생각해보면 크게 도움이 될것이다.&lt;/p&gt;
&lt;h2&gt;영감을 준 말들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;회고를 회고하는 작업도 있을 수 있다.&lt;/li&gt;
&lt;li&gt;회사의 코드 공개 범위가 궁금하면, 기업들의 기술 블로그를 분석해 보아라.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;첨부&lt;/h2&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/daily-study/static/f7eb2d5e67229966858b403eb96766df/09096/1.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 68.24324324324324%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAACGUlEQVQ4y31Ty27bMBDU//9Fv6Bf0GOBFEXTQ049BJEt2U4dvfmmKE1nqagJAiOERqTI5e7szqrQNuDSe5xbk1E1HqcuQGmLOKebaLoeTdvDOo+XtoO2Ds0wwjiHwocZg7Jo/j6jf7limCyu3YRJmQylDZwP+ZI2Nq+7fsQwKvTjlPfSvAB8BIXznodjNpyUhrUWIcYNYcM0KXieD2ShaJNSgox9vvoWXw5f8b25RxEiGU76lYGDYxqJaXk6Evb2lZ2kZzgrMpIzISBzpE1jBnyr7vCnf0KRlgVN36M6nXFtWlSszYkBDC+EmHIQgdTUWI+RZZAA3TDl7yanr4EolJnyuq7QzuBY17hcnvFQ1bivKrgQsDCYnH82JEPDMuUS0L4Q+1FPeCpLHI4VfpQHPFwumOc512h3+hHLsgWSkohwMpbd4aQVysMRJzL8RaePbZtF+czhzlwyEaX/O5wpQK8UDvUZdXVCWV9wR+dl01HZyN4KZBFvwlGQkbXt2UKyFhELoT6oCY9PJX7S0W/WUBmTFUxpyXVJtHkPuTPzTGYRaGBbLavspU0UqZfWGiOpC4KkwW/Hzpd1zD35NktP7j0oaUpgGeKruCkdDwxZWkIcGwaR7w027yWS+HApvwuJ5Pm3RBoE/kI+buCDeXkzFyb7YHvCxTXbC1zc5pjWzaH8XiKObPhZsGSI0a6o2O1rCbg5Wbc779b/AMGgP9G370H6AAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;1&quot;
        title=&quot;1&quot;
        src=&quot;/daily-study/static/f7eb2d5e67229966858b403eb96766df/fcda8/1.png&quot;
        srcset=&quot;/daily-study/static/f7eb2d5e67229966858b403eb96766df/12f09/1.png 148w,
/daily-study/static/f7eb2d5e67229966858b403eb96766df/e4a3f/1.png 295w,
/daily-study/static/f7eb2d5e67229966858b403eb96766df/fcda8/1.png 590w,
/daily-study/static/f7eb2d5e67229966858b403eb96766df/efc66/1.png 885w,
/daily-study/static/f7eb2d5e67229966858b403eb96766df/c83ae/1.png 1180w,
/daily-study/static/f7eb2d5e67229966858b403eb96766df/09096/1.png 2104w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;체크리스트를 추가한 Github Issue 페이지&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/daily-study/static/ed221a252c9d9f4da88a2b0632b2986b/fb458/2.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAABqElEQVQ4y6VUa2+cMBDk//+2qpGab/2Sa3LkcmCMsQ02x2M6a4cLeSiqekgjm7V3djysKbp+xIvJKHXEqY1wfkAMAeM4YrxM/45pRmGZrLsexg0JMrfWoT2XCM5gCBG+H65jPwQ4jhOTL58woaiVglI1YoxYlplYMtaVQB632A4r43tM84zIExVtZ1GprEQqiwrreh67R3k6o6qb9N45D9O5NJeYNh1jb3HDU80sVPRU9vtZwXrPSgvkmShdyFXboSG0sVcIiYzNLiYQ0kQYKPP+VOFAleKLBEWdJMqmdgdJtFwTNR/jnfW0Ys2ED+cWR+X5lbLCmX74PqSNnwhZaJt/JBQviyGOuDu+oGwNVhLNc1Zo6M1Xid8RLomQCg8VF31IFW5ReCX8+fSMQ62xzG8e/rdC8fCoPbSPWFN/3aqQHv74U+Khat4rtDcofGwcahvSDcgeLleFG74i3MfNRhjHC36VJY5Ng4kXXHrR0r90A6zfKc1qNvX7XsyFXgnlz1IpnZpYyAMtUF3kRwloubFk08vahcUMfW4d19J11ekUkuOHnCNd8hdREIQm5VLDoAAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;2&quot;
        title=&quot;2&quot;
        src=&quot;/daily-study/static/ed221a252c9d9f4da88a2b0632b2986b/fcda8/2.png&quot;
        srcset=&quot;/daily-study/static/ed221a252c9d9f4da88a2b0632b2986b/12f09/2.png 148w,
/daily-study/static/ed221a252c9d9f4da88a2b0632b2986b/e4a3f/2.png 295w,
/daily-study/static/ed221a252c9d9f4da88a2b0632b2986b/fcda8/2.png 590w,
/daily-study/static/ed221a252c9d9f4da88a2b0632b2986b/efc66/2.png 885w,
/daily-study/static/ed221a252c9d9f4da88a2b0632b2986b/c83ae/2.png 1180w,
/daily-study/static/ed221a252c9d9f4da88a2b0632b2986b/fb458/2.png 2362w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Issue 를 기반으로 관리 가능한 Todo 리스트(Github Project)&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 맴버쉽 나의 다짐]]></title><description><![CDATA[절대 지각하지 않는다. 9 to 9 모든 코드에 Test…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-membership/0/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-membership/0/</guid><pubDate>Mon, 26 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;ol&gt;
&lt;li&gt;절대 지각하지 않는다. &lt;strong&gt;9 to 9&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;모든 코드에 Test를 적용한다.&lt;/li&gt;
&lt;li&gt;새로운 것들을 적용해 본다.&lt;/li&gt;
&lt;li&gt;커밋 규칙을 준수한다.&lt;/li&gt;
&lt;li&gt;매일 배운 내용은 그날 정리한다.&lt;/li&gt;
&lt;li&gt;협업을 두려워하지 말자.&lt;/li&gt;
&lt;li&gt;다른이들의 열정을 자극할 수 있도록 노력하자.&lt;/li&gt;
&lt;li&gt;시작을 하였으면, &lt;strong&gt;끝을 보자&lt;/strong&gt;. (용두사미에 그치지 않도록 노력 하자.)&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 맴버쉽 1]]></title><description><![CDATA[…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-membership/1/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-membership/1/</guid><pubDate>Mon, 26 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;오늘의 학습&lt;/h2&gt;
&lt;h3&gt;전반적으로…&lt;/h3&gt;
&lt;p&gt;오늘은 오랜 시간 고민을 통한 코드작성이 아닌, 다시 부스트 캠프의 리듬에 맞추기 위한 몸풀기 단계였다.&lt;/p&gt;
&lt;p&gt;오전시간에는 전반적인 프로그램 운영 규칙등에 대한 안내가 있었고, 오후 시간에는 마스터님의 강연이 있었다.&lt;/p&gt;
&lt;p&gt;본격적인 내용 전달에 앞서, 우리의 지난 첼린지 과정의 교육의 방향과 그 속에 숨은 내용들에 대한 뜻풀이(?) 시간이 있었는데, 들어보니 우리가 해온 과정이 정교하게 설계 된 프로그램이였다는 사실에 다시 한번 놀라며 감사함을 느낄 수 있었다.&lt;/p&gt;
&lt;p&gt;강연의 내용은 너무 중요하고 좋은 내용들 이였지만, 관련 경험과 학습이 부족한 나로서는 따라가기가 버거웠다.&lt;/p&gt;
&lt;p&gt;이 내용들을 사전에 간단하게라도 가이드를 주어서 쉬는 텀에 예습을 할 수 있었다면, 더 많은 내용을 배울 수 있었을 텐데… 아는 만큼 보인다고, 아쉽게도 나는 깊은 울림을 얻지는 못했다.&lt;/p&gt;
&lt;p&gt;그럼에도, 이번 강의 자료를 토대로 또 배워가야 할 브랜치를 알게되어 큰 도움이 되었다.&lt;/p&gt;
&lt;p&gt;언급하신 &lt;code class=&quot;language-text&quot;&gt;성장을 위한 추천도서&lt;/code&gt; 들을 한번 읽어봐야 할것이다 .&lt;/p&gt;
&lt;h3&gt;짝 프로그래밍&lt;/h3&gt;
&lt;p&gt;짝 프로그램은 좋은 경험이였다.&lt;/p&gt;
&lt;p&gt;꼭 해보고 싶었던 부분이였고, 이를 간접적으로 경험해볼 수 있는 기회였다.&lt;/p&gt;
&lt;p&gt;주제는 우리가 다뤄봤던 문제 위주로 나와서 주제 파악과 설계에는 많은 시간이 들진 않았지만,&lt;/p&gt;
&lt;p&gt;페어프로그램에 익숙치 않아 오히려 구현에는 시간이 많이 소요 되었다.&lt;/p&gt;
&lt;p&gt;오늘 나와 나의 짝(팀원)님은 네비게이터와 드라이버의 역할을 나눔에 있어서 네비게이터가 전반적으로 모든 가이드를 제공하였다.&lt;/p&gt;
&lt;p&gt;코드의 시작과 설계를 네비게이터가 안내하고, 드라이버는 이를 코드로 구현하는 식이였다.&lt;/p&gt;
&lt;p&gt;아직 어떤게 좋은 방법인지는 모르겠으나, 네비게이터의 느낌보다는 옵저버의 느낌으로 진행했으면 더 배우는게 많았을 것 같다.&lt;/p&gt;
&lt;p&gt;지난번에 챌린지 과정중 릴레이 프로젝트때 페어프로그래밍을 모방하여 진행한 경험이 있는데, 이 때는 내가 네비게이터가 되어 드라이버가 작성하는 코드에 대해 의문을 던지는 역할을 하였다.&lt;/p&gt;
&lt;p&gt;네비게이터→드라이버 에게 일방적으로 아이디어와 설계를 전달하기 보다는,&lt;/p&gt;
&lt;p&gt;컴퓨터를 잡은 드라이버가 일단 자신의 설계와 아이디어 (혹은 사전에 상의한, 그러나 우리는 상의할 시간이 없었으므로 패스) 를 바탕으로 코드를 작성하고,&lt;/p&gt;
&lt;p&gt;네비게이터는 그 코드의 흐름과 사고의 흐름을 보고 느끼며 자신의 생각을 소스처럼(부가적으로) 더하는 방식으로 진행하였는데, 이 때 코드를 작성함에 있어 더 스무스 하고, 생각을 서로 많이 하게 되는 경험이였다.&lt;/p&gt;
&lt;p&gt;결과적으로,&lt;/p&gt;
&lt;p&gt;자동차를 운전할 때 길을 알려주는 네비게이션에 따라 생각없이 운전대만 잡고 달리는 게 아니라,&lt;/p&gt;
&lt;p&gt;하늘에 달린 인공위성이 제공하는 다양한 길의 옵션에 따라 운전자가 선택하여 자동차를 모는 방식이 과정속에서 더 많이 배우는 것 같다.&lt;/p&gt;
&lt;h2&gt;오늘의 배움&lt;/h2&gt;
&lt;p&gt;아주 많은 내용들이 압축되어 단시간에 다뤄졌다.&lt;/p&gt;
&lt;p&gt;도움이 많이 되고, 한번 더 생각해봐야 할 좋은 주제들이 있었다.&lt;/p&gt;
&lt;p&gt;그 중에서도 다음 두 주제가 좋았다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;무엇을 테스트 해야 하는가&lt;/li&gt;
&lt;li&gt;클린코드 &amp;#x26; 클린 아키텍쳐&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;자세한 내용은 발표자료에 포함되어 있어, 그대로 공유가 어렵기에 추후에 다른 서적을 읽어본 뒤 나의 글로 정리하여 남기도록 하겠다.&lt;/p&gt;
&lt;h2&gt;영감을 준 말들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;실수할 수 있음을 인정하자. 실수에 대해 꾸짖음만 주어진다면, 실수를 숨기게 된다.&lt;/li&gt;
&lt;li&gt;소프트웨어 유지보수란 지금처럼만 잘 동작하도록 만드는 것이 아니고 변화하는 세상에서 계속 유용하도록 만드는 것이다&lt;/li&gt;
&lt;li&gt;설계의 악취&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[Github Markdown에서 이미지 크기 조절하는 방법]]></title><description><![CDATA[깃헙 README.md에 사진을 올리면 기본적으로 전체 사이즈로 올라가게 된다.
문제는, width가 화면에 꽉차게 맞춰져서 스마트폰등에서 찍은 세로로 긴 사진을 올리면 보기 싫어지게 된다… 사진을 MD…]]></description><link>https://sukjae.github.io/daily-study/daily/2019-08-20/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/daily/2019-08-20/</guid><pubDate>Tue, 20 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;깃헙 README.md에 사진을 올리면 기본적으로 전체 사이즈로 올라가게 된다.
문제는, width가 화면에 꽉차게 맞춰져서 스마트폰등에서 찍은 세로로 긴 사진을 올리면 보기 싫어지게 된다…&lt;/p&gt;
&lt;h2&gt;사진을 MD에 그냥 넣었을떄&lt;/h2&gt;
&lt;h3&gt;코드&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;![](https://picsum.photos/1000/1800)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;결과&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://picsum.photos/1000/1800&quot;&gt;&lt;/p&gt;
&lt;h2&gt;나는 이게 싫어서 table속에 image를 두개씩 넣곤했다.&lt;/h2&gt;
&lt;h3&gt;코드&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;| line 1 | line 2 |
|--------|--------|
|![](https://picsum.photos/1000/1800)|![](https://picsum.photos/1000/1800)|&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;결과&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;line 1&lt;/th&gt;
&lt;th&gt;line 2&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;img src=&quot;https://picsum.photos/1000/1800&quot;&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://picsum.photos/1000/1800&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;그러나 다른 방법을 찾던 중, Github의 Markdown에서 Html의 Image tag를 사용할 수 있음을 알게 되었다.&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Github의 MD에서는 적용되나, MD 엔진에 따라 다르게 나올것 같다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;코드&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;img src=&amp;quot;https://picsum.photos/1000/1800&amp;quot; width=&amp;quot;300&amp;quot;&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/a/26138535&quot;&gt;출처&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;결과&lt;/h3&gt;
&lt;img src=&quot;https://picsum.photos/1000/1800&quot; width=&quot;300&quot;&gt;
&lt;h2&gt;참고로 &lt;code class=&quot;language-text&quot;&gt;%&lt;/code&gt; 도 적용된다&lt;/h2&gt;
&lt;h3&gt;코드&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;img src=&amp;quot;https://picsum.photos/1000/1800&amp;quot; width=&amp;quot;50%&amp;quot;&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;결과&lt;/h3&gt;
&lt;img src=&quot;https://picsum.photos/1000/1800&quot; width=&quot;50%&quot;&gt;</content:encoded></item><item><title><![CDATA[Netlify & Netlify CMS]]></title><description><![CDATA[개요 Netlify와 같은곳에서 만들지만 살짝 다른 서비스 Netlify는 static site를 Host하는 도구 그러나… 어차피 Netlify CMS를 사용하려 하여도 Authentication을 위해서 서버가 필요하다… github…]]></description><link>https://sukjae.github.io/daily-study/daily/2019-08-15/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/daily/2019-08-15/</guid><pubDate>Thu, 15 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;개요&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Netlify와 같은곳에서 만들지만 살짝 다른 서비스&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Netlify는 static site를 Host하는 도구&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;그러나… 어차피 Netlify CMS를 사용하려 하여도 Authentication을 위해서 서버가 필요하다…&lt;/li&gt;
&lt;li&gt;github은 이러한 서버 역할이 될 수 없다. 따라서 다른 서버가 필요한데&lt;/li&gt;
&lt;li&gt;스스로 authentication server를 만들거나&lt;/li&gt;
&lt;li&gt;Netlify 를 통하여 authentication 작업을 처리하거나&lt;/li&gt;
&lt;li&gt;근데 전자가 너무 귀찮아 지므로 후자인 Netlify를 사용해야 하는데…&lt;/li&gt;
&lt;li&gt;Netlify에서 Authentication 작업을 처리하기 휘애서 hosting를 진행해야 하고…&lt;/li&gt;
&lt;li&gt;그러므로 어차피 Netlify사이트에 종속적이게 되버린다.&lt;/li&gt;
&lt;li&gt;정리하자면. (아래 추가 설명)&lt;/li&gt;
&lt;li&gt;웹페이지 호스팅 (Github) + CMS (Netlify-CMS)+ CMS authentication(Netlify)&lt;/li&gt;
&lt;li&gt;웹페이지 호스팅 + CMS authentication(Netlify) + CMS (Netlify-CMS)&lt;/li&gt;
&lt;li&gt;웹페이지 호스팅 (Github) + CMS (Netlify-CMS)+ CMS authentication(개인 서버)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Netlify CMS는 CDN으로 view를 포함한 관리를 모두 진행한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;body&amp;gt;
  &amp;lt;!-- Include the script that builds the page and powers Netlify CMS --&amp;gt;
  &amp;lt;script src=&amp;quot;https://unpkg.com/netlify-cms@^2.0.0/dist/netlify-cms.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;markdown, JSON, YAML, or TOML 들로 작성된 컨텐츠 모두 관리가 가능하다.&lt;/li&gt;
&lt;li&gt;GitHub, GitLab, Bitbucket or Netlify등 다양한 호스팅에서 사용이 가능하다&lt;/li&gt;
&lt;li&gt;Jekyll, GitBook, Hugo, Gatsby, Nuxt, Gridsome, Hexo, Middleman, Jigsaw, Spike, Wyam, Pelican, VuePress 등의 정적 사이트 생성기(static site generator)와 같이 사용될 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;At its core, Netlify CMS is an open-source React app that acts as a wrapper for the Git workflow, using the GitHub, GitLab, or Bitbucket API. This provides many advantages, including:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Fast, web-based UI:&lt;/strong&gt; With rich-text editing, real-time preview, and drag-and-drop media uploads.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Platform agnostic:&lt;/strong&gt; Works with most static site generators.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Easy installation:&lt;/strong&gt; Add two files to your site and hook up the backend by including those files in your build process or linking to our Content Delivery Network (CDN).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Modern authentication:&lt;/strong&gt; Using GitHub, GitLab, or Bitbucket and JSON web tokens.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Flexible content types:&lt;/strong&gt; Specify an unlimited number of content types with custom fields.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fully extensible:&lt;/strong&gt; Create custom-styled previews, UI widgets, and editor plugins.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;&lt;strong&gt;Netlify CMS vs. Netlify&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.netlify.com/&quot;&gt;Netlify.com&lt;/a&gt;&lt;/strong&gt; is a platform you can use to automatically build, deploy, serve, and manage your frontend sites and web apps.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Netlify.com은 웹 앱과 프런트앤드 사이트들을 자동으로 빌드, 배포, 서빙 그리고 관리 할 수 있게 해주는 플랫폼 입니다 .&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;It also provides a variety of other features like form processing, serverless functions, and split testing.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;또한 폼 처리, 서버리스 함수, 그리고 분산 테스팅과 같은 다양한 기능들을 제공합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Not all Netlify sites use Netlify CMS, and not all sites using Netlify CMS are on Netlify.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;모든 Netlify 사이트들이 Netlify CMS를 사용하는 것은 아닙니다.
모든 Netlify CMS를 사용하는 사이트들이 Netlify에 있는것도 아닙니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The folks at Netlify created Netlify CMS to fill a gap in the static site generation pipeline.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Netlify를 만든 사람들은 정적 사이트 생성 파이프라인 사이에 존재하는 갭을 매꾸기 위해 Netlify CMS를 만들었습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;There were some great proprietary headless CMS options, but no real contenders that were open source and extensible—that could turn into a community-built ecosystem like WordPress or Drupal.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;기존에도 아주 좋은 &lt;strong&gt;headless CMS*&lt;/strong&gt; 옵션들이 존재하였습니다. 하지만 WordPress 나 Drupal과 같이 커뮤니티 기반의 생태계로 변화될 수 있는 오픈 소스화 되고 확장 가능한 옵션은 없었습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;For that reason, Netlify CMS is &lt;em&gt;made&lt;/em&gt; to be community-driven, and has never been locked to the Netlify platform (despite the name).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;이러한 이유로, Netlify CMS는 Netlify 플랫폼에 종속되지 않는 커뮤니티 기반의 프로젝트로 제작 되었습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;With this in mind, you can:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Use Netlify CMS without Netlify and deploy your site where you always have, hooking up your own CI, site hosting, CDN, etc.&lt;/li&gt;
&lt;li&gt;Use Netlify without Netlify CMS and edit your static site in your code editor.&lt;/li&gt;
&lt;li&gt;Or, use them together and have a fully-working CMS-enabled site with &lt;strong&gt;&lt;a href=&quot;https://www.netlifycms.org/docs/start-with-a-template/&quot;&gt;one click&lt;/a&gt;&lt;/strong&gt;!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이를 바탕으로 다음과 같은 작업들을 할 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Netlify CMS를 Netlify없이 사용하세요. 그리고 그 사이트를 원래 사용하던 곳에 배포하세요. 당신의 CI, 사이트 호스팅, CDN등과 연결 하세요.&lt;/li&gt;
&lt;li&gt;Netlify를 Netlify CMS없이 사용하세요. 그리고 당신의 정적 사이트를 코드 에디터에서 관리하세요.&lt;/li&gt;
&lt;li&gt;아니면, 완전히 작동하는 CMS를 탑재한 사이트를 클릭 한번으로 사용하세요. 위 두가지를 모두 사용 가능합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you hook up Netlify CMS to your website, you’re basically adding a tool for content editors to make commits to your site repository without touching code or learning Git.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Netlify CMS를 당신의 웹 사이트에 연결(Hook)함으로서 당신은 Git을 학습하거나 실제 코드를 다루지 않더라도 커밋을 만들 수 있는 컨텐츠 에디터 도구를 추가 하는 것 입니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;*Headless CMS : head(프런트앤드, 웹사이트)를 body(백앤드, 컨텐츠 저장소)로 분리하는 컨셉&lt;/p&gt;
&lt;p&gt;[ &lt;a href=&quot;https://en.wikipedia.org/wiki/Headless_content_management_system&quot;&gt;https://en.wikipedia.org/wiki/Headless&lt;em&gt;content&lt;/em&gt;management_system&lt;/a&gt; ]&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Authentication &amp;#x26; Backends&lt;/h2&gt;
&lt;p&gt;가능한 옵션들&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Git Gateway with Netlify Identity&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Git Gateway는 Netlify의 오픈소스 프로젝트&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Git Gateway without Netlify&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;사용자가 Git Gateway server를 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GitHub Backend (GitHub에서 호스팅 하는 경우)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GitHub는 authentication 작업을 위해 별도의 서버가 필요함&lt;/li&gt;
&lt;li&gt;Netlify를 통해 인증해야 함.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GitLab Backend&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Web Application Flow&lt;/li&gt;
&lt;li&gt;Netlify를 통해 인증&lt;/li&gt;
&lt;li&gt;Implicit Grant&lt;/li&gt;
&lt;li&gt;클라이언트로 부터 직접 GitLab에 연결하여 인증&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bitbucket Backend&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Netlify를 통해 인증해야 함.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;External OAuth Clients&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;스스로 인증을 관리하는 방법&lt;/li&gt;
&lt;li&gt;Netlify의 service 나 implicit grant를 사용하지 않고 싶을때 사용&lt;/li&gt;
&lt;li&gt;직접 auth server를 구축&lt;/li&gt;
&lt;li&gt;사용자가 직접 auth server를 구축할 코드를 공개해놓음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[간단한 리펙토링, filter대신 map으로!]]></title><description><![CDATA[정말 단순한 깨달음… 중첩된 객체에서 요소를 바꾸기 위해 filter를 굳이 사용 하지 않아도 되었었다…ㅎ 부스트 캠프 1…]]></description><link>https://sukjae.github.io/daily-study/daily/2019-08-13/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/daily/2019-08-13/</guid><pubDate>Tue, 13 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;정말 단순한 깨달음…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;중첩된 객체에서 요소를 바꾸기 위해 filter를 굳이 사용 하지 않아도 되었었다…ㅎ&lt;/h2&gt;
&lt;p&gt;부스트 캠프 13일차에서 작성한 코드를 다시 살펴보니, 다음과 같은 코드가 있었다.
&lt;a href=&quot;https://github.com/sukjae/daily-study/blob/master/boost-camp/day-13.md#immutable&quot;&gt;후기 링크&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;state &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;state&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;folder_name &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; folder_name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;copiedFolder&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    files&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
      &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;copiedFolder&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;files&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;file_name &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; file_name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;copiedFile&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        status&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이 코드가 나오기 전에, &lt;code class=&quot;language-text&quot;&gt;copiedFolder&lt;/code&gt; 와 &lt;code class=&quot;language-text&quot;&gt;copiedFile&lt;/code&gt;를 생성하기 위한 추가적인 로직들이 존재한다…&lt;/p&gt;
&lt;p&gt;결국 이 코드로 원했던 것은, 객체와 배열이 중첩된 구조에서, 내부 배열의 일 부분을 바꾸고자 하였다.&lt;/p&gt;
&lt;p&gt;근데 오늘 가만히 생각해보니… 그냥 map으로 훨씬 간단하게 구현이 되더라.
이 방법으로 접근하면, 따로 &lt;code class=&quot;language-text&quot;&gt;copiedFolder&lt;/code&gt; 와 &lt;code class=&quot;language-text&quot;&gt;copiedFile&lt;/code&gt;를 저장하기 위한 변수를 지정하지 않아도 된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;state&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt;
  x&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;folder_name &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; folder_name
    &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; x
    &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;x&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        files&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;files&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt;
          x&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;file_name &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; file_name
            &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; y
            &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;y&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
                status&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
              &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;첫 접근 방법은, filter를 두번 사용해서 포함하지 않는것, 또 한번은 포함하고 있는것으로 분리한 뒤 합치는 과정이였다면,&lt;/p&gt;
&lt;p&gt;두번째 접근법은, map을 통하여 이 두 로직을 한번에 해버린다.&lt;/p&gt;
&lt;p&gt;기록을 하는게 이래서 좋은것 같다.
시간이 지나도, 중요한 부분을 다시 복기할 수 있고, 이를 통하여 한단계 더 발전이 가능하다.&lt;/p&gt;
&lt;p&gt;만얀, 이 부분에 대한 글을 작성하지 않았다면, 또 위의 방법처럼 코드를 작성했을 것이다.&lt;/p&gt;
&lt;p&gt;오늘은 두번째 방법을 알게된 것 이상으로 글을 쓰는 것에 대한 중요성을 느끼게 되었다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Redux-Thunk에 대한 생각 정리]]></title><description><![CDATA[역시 하나를 알려면 제대로 알아야 한다. 막상 Redux에서 Thunk를 활용할 고민을 하니, 어떻게 활용할지 잘 감이 안왔다. 이 Thunk 덕분에 바로 dispatch…]]></description><link>https://sukjae.github.io/daily-study/daily/2019-08-12/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/daily/2019-08-12/</guid><pubDate>Mon, 12 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;역시 하나를 알려면 제대로 알아야 한다.&lt;/p&gt;
&lt;p&gt;막상 Redux에서 Thunk를 활용할 고민을 하니, 어떻게 활용할지 잘 감이 안왔다.&lt;/p&gt;
&lt;p&gt;이 Thunk 덕분에 바로 dispatch를 안하고, 비동기적으로 실행될 수 있다고 하는데, 어떻게 사용될지 잘 이해가 안갔다.&lt;/p&gt;
&lt;p&gt;기계적으로 사용할 수 있지만, 부스트캠프에서 느꼈듯이, 이해를 바탕으로 설계를 어느정도 해야 배우는것도 많고 시행착오도 많이 줄일 수 있다.&lt;/p&gt;
&lt;p&gt;그래서 오늘은 Redux-Thunk에 대해 조금 더 알아보고자 찾아봤다.&lt;/p&gt;
&lt;h2&gt;Thunk가 뭐야?&lt;/h2&gt;
&lt;p&gt;네이버 사전을 검색하면 다음과 같이 나온다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;thunk : 푹, 탁 ((둔탁한 소리)) &lt;del&gt;???&lt;/del&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;전혀 이해가 안 간다.&lt;/p&gt;
&lt;p&gt;위키 피디아를 찾아봤다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In computer programming, a thunk is a subroutine used to inject an additional calculation into another subroutine.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;아하!!&lt;/p&gt;
&lt;p&gt;사실상, 위의 문장에 Redux-thunk의 사용 방법이 모두 명시 되어있다.&lt;/p&gt;
&lt;p&gt;리덕스는 다른 서브루틴에 &lt;strong&gt;추가적인 연산을 주입(inject)하기&lt;/strong&gt; 위한 서브루틴이다.&lt;/p&gt;
&lt;p&gt;주입이라는 부분이 키워드 인것 같다.&lt;/p&gt;
&lt;p&gt;위에 내가 갖고 있던 비동기 는 집어치워 버리고, 이 부분만 생각하자.&lt;/p&gt;
&lt;p&gt;(항상 생각하지만, 결과만 알아서는 하나도 쓸모 없다. 존재 이유와 함께 사용 방법을 알아야 한다. )&lt;/p&gt;
&lt;p&gt;또 다음줄에서는 다음과 같이 표현한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Thunks are primarily used to delay a calculation until its result is needed, or to insert operations at the beginning or end of the other subroutine.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이 부분에는 Thunk의 존재 이유(용도)에 대해 명시되어 있다.&lt;/p&gt;
&lt;p&gt;위의 연산의 주입을 통하여 이루고자 하는것은 두가지 이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;하나의 연산의 결과를 원할때 까지 연산을 미룬다. (그냥 필요할 때 실행 하겠다는 뜻)&lt;/li&gt;
&lt;li&gt;서브 루틴의 첫 부분이나 끝 부분에 또다른 연산을 추가한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;그냥 쉽게 생각해서 다음과 같은 코드를 생각하면 될듯 하다 .&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// &apos;hypot&apos; is a binary function&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;hypot&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;x&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; y&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; Math&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;sqrt&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; y &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; y&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// &apos;thunk&apos; is a function that takes no arguments and, when invoked, performs a potentially expensive&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// operation (computing a square root, in this example) and/or causes some side-effect to occur&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;thunk&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;hypot&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// the thunk can then be passed around...&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;doSomethingWithThunk&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;thunk&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// ...or evaluated&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;thunk&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// === 5&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;아니면 더 쉽게&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// calculation of 1 + 2 is immediate&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// x === 3&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// calculation of 1 + 2 is delayed&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// foo can be called later to perform the calculation&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// foo is a thunk!&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그렇다!&lt;/p&gt;
&lt;p&gt;실행 시에 비싼 연산을 지불해야 하는 기능을 선언과 동시에 실행하는게 아니라, 필요할때만 실행할 수 있도록 감싸는 패턴이다.&lt;/p&gt;
&lt;p&gt;자 이제 Thunk가 무엇을 의미하는지 알았다.&lt;/p&gt;
&lt;p&gt;Redux의 thunk도 사실상 같은 의미를 갖고 구현된 기능이다(middleware)&lt;/p&gt;
&lt;h2&gt;Redux Thunk&lt;/h2&gt;
&lt;p&gt;일단 Thunk의 핵심 코드를 보자&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;thunk&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;store&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;action&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;typeof&lt;/span&gt; action &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;function&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;store&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;dispatch&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;action&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;간단하다.&lt;/p&gt;
&lt;p&gt;하지만 아직 이 쓰임새를 잘 모르겠다.&lt;/p&gt;
&lt;p&gt;이해는 잘 안 가지만, 일단 위 코드의 내용을 한번 짚고 가자.&lt;/p&gt;
&lt;p&gt;일단 위 thunk 함수는 계속하여 함수를 반환값으로 갖는다.&lt;/p&gt;
&lt;p&gt;그러면서 이전 매개변수는 내부 변수(클로져를 통하여) 로 보관된다.&lt;/p&gt;
&lt;p&gt;굳이 표현하자면, 이렇게 쓰이겠다. (물론 이렇게는 아니다. 그냥 이해를 돕기 위함이다)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; thunkWithStore &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;thunk&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;SOME_STORE&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; thunkWithStoreAndNext &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;thunkWithStore&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;SOME_NEXT&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그리고 코드의 내용을 보면 알겠지만, action의 타입이 가장 중요한 역할을 함을 볼 수 있다.&lt;/p&gt;
&lt;p&gt;즉, 우리가 어떤 방식으로 action을 인자로 받는데, 그 action이 함수라면, 그 함수를 실행하라는 뜻이다.&lt;/p&gt;
&lt;p&gt;여기서 이런 패턴이 익숙치 않으면 이렇게 생각할 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;action이 함수인데, store.dispatch를 받아서 action을 실행한다라… 굳이 왜?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;왜냐면, 이 thunkWrapper는 action으로 함수를 받게 되고,&lt;/p&gt;
&lt;p&gt;그 함수에는 하나 이상의 함수를 실행하는, 마치 트리거의 역할을 하는 것이다.&lt;/p&gt;
&lt;p&gt;그냥 쉽게 생각해서, 여러개의 함수를 감싸서 한번에 실행하기 위한 wrapper정도로 볼수 있겠다.&lt;/p&gt;
&lt;p&gt;(그래서 나는 함수의 이름이 thunk가 아니라 thunkWrapper가 되야 하지 않나 싶다)&lt;/p&gt;
&lt;h2&gt;redux-thunk의 용도&lt;/h2&gt;
&lt;p&gt;그 전에 짚고 넘어가자&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Redux의 action은 action creator를 통해 나오는 것이다. (action-creator가 함수라면, action은 이에 대한 결과물이다)&lt;/li&gt;
&lt;li&gt;action은 dispatch를 통해 store에 반영된다.&lt;/li&gt;
&lt;li&gt;기본적인 action creator와 dispatch를 사용하여 비동기 작업을 하는건 전혀 문제가 없다.&lt;/li&gt;
&lt;li&gt;그냥 비동기를 요청하면 된다. 단지, 결과로서 하나의 action을 반환하도록 설계 되어 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;겉보기엔 아무 문제 없어 보인다.&lt;/p&gt;
&lt;p&gt;그러나, 일련의 과정이 하나의 행동이라 생각해보자.&lt;/p&gt;
&lt;p&gt;예를들어,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;요청이 시작되었다는 것&lt;/li&gt;
&lt;li&gt;요청이 완료 되었다는 것&lt;/li&gt;
&lt;li&gt;요청을 진행하는 것&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 세가지의 행동을 하나의 action creator에 명시할 방법이 없다.&lt;/p&gt;
&lt;p&gt;그래서 할 수 있는 방법은 다음과 같다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;//... 어떤 컴포넌트&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;fetchData&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// mapdispatchToProps되어 있다 가정.&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 따라서 fetchTodos외 requestTodos 는 dispatch임&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;filter&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; fetchTodos&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; requestTodos&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;props
&lt;span class=&quot;token function&quot;&gt;requestTodos&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;filter&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 요청이 시작되었음을 알리는 디스패처. 보통 spinner같은걸 돌려서 로딩 시작&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;fetchTodos&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;filter&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 실제 요청 시작을 위한 디스패처.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;뭔가 어색함이 느껴질 것이다.&lt;/p&gt;
&lt;p&gt;보통의 경우 requestTodos와 fetchTodos는 하나의 행동 같은데, 이 것을 사용 시마다 개발자가 명시해야한다.&lt;/p&gt;
&lt;p&gt;fetchTodos를 하기 위해서는 requestTodos 가 필요함이 분명한데도 말이다!&lt;/p&gt;
&lt;p&gt;여기서 thunk가 튀어 나온다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;fetchTodos&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;dispatch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;dispatch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;requestTodo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;filter&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; api&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;fetchTodos&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;filter&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;dispatch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;receiveTodos&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;filter&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; res&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;우리의 Action Creator에(action이 아니다!!!) 함수를 넣어줬다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;dispatch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;dispatch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;requestTodo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;filter&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; api&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;fetchTodos&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;filter&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;dispatch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;receiveTodos&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;filter&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; res&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이 자리는 원래 action(보통 어떤 한 객체)가 왔어야 했는데, 함수가 왔다.&lt;/p&gt;
&lt;p&gt;그래서, 위의 thunk의 구현에 따라 dispatch 자리에 들어오는 인자를 함수로 갖고(여기선 store.dispatch)&lt;/p&gt;
&lt;p&gt;이하 내용을 실행하게 된다.&lt;/p&gt;
&lt;p&gt;위 코드를 조금 더 보기 편하게 정리하면 다음과 같다. (물론, arrow function와는 다른 특성이 있지만 그냥 보기 편하게!!)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;someActionFunc&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;dispatch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;dispatch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;requestTodo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;filter&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; api&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;fetchTodos&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;filter&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;dispatch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;receiveTodos&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;filter&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; res&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그럼 아래 부분에서 action에 이 someActionFunc가 들어간 것이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;thunk&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;store&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;action&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;typeof&lt;/span&gt; action &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;function&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;store&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;dispatch&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;action&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;따라서, someActionFunc는 thunk가 선언될 시점에서 아직 무엇인지 모르지만, 함수임을 알고 이를 실행하겠다는 뜻이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 미래의 someActionFunc&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;someActionFunc&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;store&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;dispatch&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;여기서, store에 있는 dispatch를 넘겨줌으로서, someActionFunc의 함수 내부에서 dispatch를 사용할 수 있는 것이다.&lt;/p&gt;
&lt;p&gt;thunk는 이러한 용도이다.&lt;/p&gt;
&lt;h2&gt;정리&lt;/h2&gt;
&lt;p&gt;그래서 redux-thunk가 뭐야?&lt;/p&gt;
&lt;p&gt;redux-thunk는 redux에서 필요한 사이드 이펙트 로직들을 구현하는데 도움이 되는 middleware이다.&lt;/p&gt;
&lt;p&gt;(이 side effect중에는 우리가 쉽게 접하는 async 처리가 있다. )&lt;/p&gt;
&lt;p&gt;redux에서는 무엇이(action) 어떻게(reducer) 변해야 할지 전달과(dispatch) 동시에 바로 store에 반영 되어야 하며, 이 작업은 sync하게 움직여야 한다.&lt;/p&gt;
&lt;p&gt;문제는, 우리가 sync하지 않은 작업이나, 작업을 하며 다른 부가적인 외부 작업을 동반하는 기능들을 plain redux의 구조로는 처리하기 어색(복잡?)하다 . 이를 보안하기 위해 만들어 졌다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;thunk사용시 필요에 따라 action creator의 반환값으로 action 대신 dispatch 함수를 넣어준다!!!&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[Normalizr, 객체(JSON) 분해하기]]></title><description><![CDATA[Normalizr는 redux를 만든 Dan씨가 만든 라이브러리이다. Redux와 궁합이 잘 맞고, 복잡한 nested object에 대해 사용이 편리한 객체로 변환을 용이하게 해준다. Motivation Many APIs, public or not…]]></description><link>https://sukjae.github.io/daily-study/daily/2019-08-11/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/daily/2019-08-11/</guid><pubDate>Sun, 11 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Normalizr는 redux를 만든 Dan씨가 만든 라이브러리이다.&lt;/p&gt;
&lt;p&gt;Redux와 궁합이 잘 맞고, 복잡한 nested object에 대해 사용이 편리한 객체로 변환을 용이하게 해준다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Motivation&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Many APIs, public or not, return JSON data that has deeply nested objects. Using data in this kind of structure is often very difficult for JavaScript applications, especially those using Flux or Redux.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;출처: &lt;a href=&quot;https://github.com/paularmstrong/normalizr#motivation&quot;&gt;Normalizr Docs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;위의 Motivation에서 언급하는 문제는 사실 매우 흔하게 접하는 이슈이며, 중요한 이슈이다.&lt;/p&gt;
&lt;p&gt;Nosql를 사용하는 DB들(ex, mongodb)을 사용하며 깊이 중첩된 객체를 자주 마주치게 된는데, 2 중첨된 데이터만 만나도 데이터 처리 로직이 굉장히 복잡해진다.&lt;/p&gt;
&lt;p&gt;특히, JSON의 형태로 많은 데이터가 한번에 넘어오는데, 이런 중첩된 객체들은 FrontEnd에서 사용시 처리가 어렵다는 것이다.&lt;/p&gt;
&lt;p&gt;물론 비단 FE 에서 만의 문제는 아니겠지만, FE에서는 데이터를 받아서 보여만 주는게 아니라 이를 갖고 놀아야 하기 때문에 변형을 위한 복잡한 로직이 동반되게 된다.&lt;/p&gt;
&lt;p&gt;예를 들어, User안에 Post안에 Comment가 있다고 가정해 보자.&lt;/p&gt;
&lt;p&gt;그렇다면, Redux의 흐름에서 이 Comment에 어떻게 접근(도달)할 것이고 수정시에는 또 어떻게 걸러줘야 할것인가. (Immutable을 염두에 둔 상태로)&lt;/p&gt;
&lt;p&gt;아주 Naive 한 생각으로는, 내가 이전에 짠 코드처럼 매우 더러운 코드를 작성할 수 있다.&lt;/p&gt;
&lt;p&gt;기타 Immutable 라이브러리의 도움 없이는 이런식이 될것이다. (일반적인 복제는 Shallow copy이므로…)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; store &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;store&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;some_name &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; some_name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;copiedOutter&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    files&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
      &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;copiedOutter&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;files&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;token parameter&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;some_other_name &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; cf&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;some_other_name
      &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;cf&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        status&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;in progress&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        modified_at&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이렇듯 deeply nested object는 Redux에서, 나아가 함수형 패러다임에서 굉장히 불편한 요소로 존재한다.&lt;/p&gt;
&lt;p&gt;Normalizr는 이러한 짐을 덜어준다.&lt;/p&gt;
&lt;p&gt;이 라이브러리는 data를 destructuring하는 역할이다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/paularmstrong/normalizr/blob/master/docs/quickstart.md&quot;&gt;공식 문서&lt;/a&gt;에 다음과 같은 예시가 있는데, 이 예시만 보더라도 Normalizr의 파워를 느낄 수 있다.&lt;/p&gt;
&lt;h4&gt;샘플 데이터&lt;/h4&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token string&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;123&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token string&quot;&gt;&quot;author&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Paul&quot;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token string&quot;&gt;&quot;title&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;My awesome blog post&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token string&quot;&gt;&quot;comments&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token string&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;324&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token string&quot;&gt;&quot;commenter&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token string&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;2&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;token string&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Nicole&quot;&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;변형 로직&lt;/h4&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; normalize&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; schema &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;normalizr&quot;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// Define a users schema&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; user &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;schema&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Entity&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;users&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// Define your comments schema&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; comment &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;schema&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Entity&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;comments&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  commenter&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; user&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// Define your article&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; article &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;schema&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Entity&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;articles&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  author&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; user&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  comments&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;comment&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; normalizedData &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;normalize&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;originalData&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; article&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;결과&lt;/h4&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  result&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;123&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  entities&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&quot;articles&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token string&quot;&gt;&quot;123&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        id&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;123&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        author&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        title&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;My awesome blog post&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        comments&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;324&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&quot;users&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token string&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Paul&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token string&quot;&gt;&quot;2&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;2&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Nicole&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&quot;comments&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token string&quot;&gt;&quot;324&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; id&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;324&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;commenter&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;2&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이렇게 변형된다.&lt;/p&gt;
&lt;p&gt;JS를 자주 사용하지 않은 입장에서 보면 뭐가 나아졌을까 싶지만,&lt;/p&gt;
&lt;p&gt;각각의 Key값을 주목해보자.&lt;/p&gt;
&lt;p&gt;예를 들어, users[1]로 접근을 할 수 있게 되는것이다.&lt;/p&gt;
&lt;p&gt;user중에 id가 1인 item을 찾기위해 더이상 filter같은것을 할 필요 없이, 직접 접근이 가능해져 버린다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;굉장하다!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;위에서 언급 하였듯이, Normalizr를 통하여 중첩된 객체들이 원하는 형태로 변형되며, 이 과정에서 관계를 내포하게 된다. (이 뜻은, 실제 데이터에서 데이터간의 연결고리가 명확해야 함을 뜻한다. 이 부분에 대한 책인은 Normalizr의 역할이 아니다. )&lt;/p&gt;
&lt;p&gt;또 주목할 점은 관계를 쌓아가는 부분이다.&lt;/p&gt;
&lt;p&gt;아래와 같이 기본적인 유저에 대한 엔티티를 만들고&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; user &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;schema&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Entity&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;users&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이 유저에 대한 정보를 포함하는 comment를 만든 뒤&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// Define your comments schema&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; comment &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;schema&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Entity&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;comments&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  commenter&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; user&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 두가지 정보를 포함하는 아티클을 만든다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// Define your article&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; article &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;schema&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Entity&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;articles&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  author&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; user&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  comments&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;comment&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(이 모든것은 데이터 안에 서로간의 관계가 포함되어 있기 떄문에 가능하다)&lt;/p&gt;
&lt;p&gt;위 과정을 지나가며 Entitiy 의 첫번째 인자로 내가 원하는 새로운 Key를 할당하여 객체를 변형할 수 있다는 점이 또 흥미롭다.&lt;/p&gt;
&lt;p&gt;조금 더 생각해보고 Redux에 활용해 보도록 하겠다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Lambda에서 API-Gateway로 넘겨받은 post의 body읽기]]></title><description><![CDATA[오늘의 trial & error 오늘 이 부분에 안되서 한참을 고민을 하였다. 물론, 빠르게 구현하려고 docs를 제대로 안 본 나의 쟐못도 있지만, 이 문제를 해결하는데 힘들었다. Lambda…]]></description><link>https://sukjae.github.io/daily-study/daily/2019-08-10/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/daily/2019-08-10/</guid><pubDate>Sat, 10 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;오늘의 trial &amp;#x26; error&lt;/h2&gt;
&lt;p&gt;오늘 이 부분에 안되서 한참을 고민을 하였다.&lt;/p&gt;
&lt;p&gt;물론, 빠르게 구현하려고 docs를 제대로 안 본 나의 쟐못도 있지만, 이 문제를 해결하는데 힘들었다.&lt;/p&gt;
&lt;p&gt;Lambda를 사용할때, 다음 코드에서 이상한 점을 느낄 수 있을까??&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;module&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;exports&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;event&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; context&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; callback&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; text&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; style &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; event&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;body
  &lt;span class=&quot;token comment&quot;&gt;//...&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;뭐.. 지극히 그럴싸하고, 딱히 문제가 될게 없어 보이는 코드이다.&lt;/p&gt;
&lt;p&gt;event안에 body라는 프로퍼티가 있는게 확실하고,&lt;/p&gt;
&lt;p&gt;그 안에 우리가 원하는 정보가 있다는것이 확실한데,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;위 코드에 문제가 있을것이라 생각하지 힘들다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;strong&gt;하지만, 위 코드는 정상적으로 작동하지 않는다.&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;그 이유는, 우리가 편의상 사용하는 lambda-proxy때문이다.&lt;/p&gt;
&lt;p&gt;이미 잘 알려진 문제이고, 특성을 이해하면 납득이 가지만,&lt;/p&gt;
&lt;p&gt;문제는 저 위의 구문이 상식선에서는 뭐가 잘못됬는지 모른다는 것이다.&lt;/p&gt;
&lt;p&gt;이 부분을 이해하기 위해서는 Lambda와 Api-gateway의 관계를 이해 해야 한다.&lt;/p&gt;
&lt;p&gt;이 둘은 서로 조화롭게 사용되지만, 엄연히 서로 다른 제품이다.&lt;/p&gt;
&lt;p&gt;둘간의 통합이 너무 잘 이루어져 있기 때문에, 그냥 api-gateway를 병목처럼 통로 중간에 서있는 놈으로 바라볼 수 있지만,&lt;/p&gt;
&lt;p&gt;이 API-Gateway에서 처리할 수 있는것은 너무나도 많다. (Auth관련, 등등)&lt;/p&gt;
&lt;p&gt;http 요청을 보낼 때 따지고 보면, 우리는 Lambda를 향하지만, 사실상 api gateway의 url로 보내게 된다.&lt;/p&gt;
&lt;p&gt;그리고, api-gateway는 그 요청을 해석하여 경우에 따라 lambda로 전달하는데,&lt;/p&gt;
&lt;p&gt;여기서 우리는 두가지 방식으로 api-gateway가 전달받은 정보를 lambda에서도 참조할 수 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;lambda proxy&lt;/li&gt;
&lt;li&gt;lambda integration&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이 둘간의 비교는 다음 글에서 너무나도 잘 정리 되어 있기 때문에 생략한다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.com/@lakshmanLD/lambda-proxy-vs-lambda-integration-in-aws-api-gateway-3a9397af0e6d&quot;&gt;[Lambda-Proxy vs Lambda Integration in AWS API Gateway, Lakshman Diwaakar]&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;결론을 말하자면, api gateway가 전달 받은 정보를 커스텀하게 받으려면 lambda integration을 사용하면 되고,&lt;/p&gt;
&lt;p&gt;말그대로 proxy처럼 api gateway를 그냥 중간 다리 정도로 사용하려면 lambda proxy를 사용하면 된다.&lt;/p&gt;
&lt;p&gt;대부분의 경우에는 lambda proxy만으로도 충분하고, 이를 사용시에는 api gateway가 요청 받은 대부분의 정보를 그대로 Lambda로 넘긴다.&lt;/p&gt;
&lt;p&gt;문제는, 여기서 api gateway는 lambda로 받은 정보를 보내는건 맞지만,&lt;/p&gt;
&lt;p&gt;형식을 그대로 (혹은 사용하기 편하게) 보내는것은 아니다. (어쩌면 이게 진짜 ‘그대로’ 일수도… 좀더 공부해 보겠다.)&lt;/p&gt;
&lt;p&gt;api gateway는 사용자에게 받은 post의 body부분을 escaped string으로 보낸다.&lt;/p&gt;
&lt;p&gt;위의 구문이 작동하지 않았던 이유는, &lt;code class=&quot;language-text&quot;&gt;event.data&lt;/code&gt; 가 다음과 같이 그냥 쌩 문자열이기 때문이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token string&quot;&gt;&quot;body&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;{\&quot;foo\&quot;:\&quot;bar\&quot;}&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이를 우리는 JSON으로 바꿔줘야 JS에서 내부적으로 객체로서 활용이 가능하다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; body &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;JSON&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;parse&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;event&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;body&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;사실, 이 부분은 &lt;a href=&quot;https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-create-api-as-simple-proxy-for-lambda.html&quot;&gt;AWS 공식 문서&lt;/a&gt;에도 포함되어 있는 내용이다..ㅎㅎ&lt;/p&gt;
&lt;p&gt;위의 사용법이 더 혼란이 온 이유에는 get 에서 query parameter를 읽어들이는 부분은 다음처럼 위의 사용방법과 유사한것도 한몫 했다.&lt;/p&gt;
&lt;p&gt;다음 코드는 정상적으로 작동한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;module&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;exports&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;event&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; context&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; callback&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;data&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; event&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;queryStringParameters&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;언제나 그렇지만 …&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;시간이 허락한다면 꼭 공식 문서를 읽쟈&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 챌린지 20일차]]></title><description><![CDATA[피어 세션 중 생각 정리 테스트 코드 테스트 코드를 효율적으로 관리하기 위해 Jest 라이브러리를 사용하여 구현하였다. 모든 모듈별로 테스트를 독립적으로 구성하여, 유지보수를 용이하게 하였다. Node의 URL Node의 URL…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-challenge/day-20/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-challenge/day-20/</guid><pubDate>Fri, 09 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;피어 세션 중 생각 정리&lt;/h2&gt;
&lt;h3&gt;[테스트 코드]&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;테스트 코드를 효율적으로 관리하기 위해 Jest 라이브러리를 사용하여 구현하였다.&lt;/li&gt;
&lt;li&gt;모든 모듈별로 테스트를 독립적으로 구성하여, 유지보수를 용이하게 하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;[Node의 URL]&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Node의 URL클래스를 모방하여 작성하였다.&lt;/li&gt;
&lt;li&gt;Node의 URL클래스가 표현하는 표기법을 따르려 노력하였고(key값), &lt;code class=&quot;language-text&quot;&gt;_URLSearchParams&lt;/code&gt;와 같은 부가적인 기능을 추가 함으로서 Node의 URL을 이해하고자 하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;[isEqual]&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;isEqual&lt;/code&gt;메소드에서는 단순히 같고 다르고를 비교하는것을 넘어서서&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;[identical,different,similar]&lt;/code&gt; 로 구분하였다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;similar&lt;/code&gt;의 경우에는, URL의 구성요소중 어떤 부분이 같은지(&lt;code class=&quot;language-text&quot;&gt;true&lt;/code&gt;), 다른지(&lt;code class=&quot;language-text&quot;&gt;false&lt;/code&gt;), 혹은 존재하지 않는지(&lt;code class=&quot;language-text&quot;&gt;undefined&lt;/code&gt;)에 대한 정보를 객체로서 추가 제공한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;금요일 프로젝트 중 느낀것&lt;/h2&gt;
&lt;p&gt;오늘도 프로젝트가 쉽지는 않았다.&lt;/p&gt;
&lt;p&gt;일단 몇가지 어려웟던 점을 요약하면&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2주차에서 진행한 서버구성 &amp;#x26; 화면 인식 기능과 3주차에서 진행한 프런트엔드 &amp;#x26; 출석체크 기능사이에 연결고리가 전혀 없었다.&lt;/li&gt;
&lt;li&gt;두 주차의 과제는 서로 연결을 위해 만들어지지 않았기 떄문에, 이를 연결하는데 크게 어려움을 겪었다.&lt;/li&gt;
&lt;li&gt;이 두개를 합치는 작업과, 새로운 기능을 추가하는 작업을 해야하는데, 사공이 많아서 그런지… 자꾸 배가 산으로 갔다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이러한 어려움으로 인해서 팀을 나누고 싶어도 나누기 어려웠고,&lt;/p&gt;
&lt;p&gt;새로운 기능을 추가하기도 어려웠다.&lt;/p&gt;
&lt;p&gt;내 머리속에는 이를 구성할 방법들이 떠오르는데… 이 부분을 나만 알것이 분명하고, 내가 혼자 하면 그건 팀플이 아니게 되기 때문에 말하기 조심스러웠다.&lt;/p&gt;
&lt;p&gt;결국, 타협을 보고 최소한의 기능만 유지한체 시간안에 구현할 수 있는 방향으로 갔다.&lt;/p&gt;
&lt;p&gt;또, 안타까웠던 부분은 소통이 어려웠다는 점이다.&lt;/p&gt;
&lt;p&gt;한번 얘기를 할때, 다같이 모여서 딱 끝내고 과제를 나눠 진행 해야하는데,&lt;/p&gt;
&lt;p&gt;이게 잘 안되고 소수만 계속 모이니 주제가 한 방향이 아니라 여러 방향으로 나눠지곤 했다.&lt;/p&gt;
&lt;p&gt;또, 이번 팀에서는 주도를 하고자 하시는 분들이 많아 보여서 내가 주도의 역할을 내려 놨었는데, 이 또한 잘 되지 않았다.&lt;/p&gt;
&lt;p&gt;역할이 잘 분배가 되지 않으니, 쉬는 사람들이 계속 생기게 되었다.&lt;/p&gt;
&lt;p&gt;할거는 많은데, 자원을 효율적으로 활용하지 못했던것 같다.&lt;/p&gt;
&lt;p&gt;그럼에도 불구하고, 후반에 모두가 힘을 합쳐 잘 마무리 지을 수 있었다.&lt;/p&gt;
&lt;p&gt;특히, 팀원 분들중에 말을 잘 하시는 분들도 많이 있으셨고,&lt;/p&gt;
&lt;p&gt;맡은 일을 다 끝내신 분들 덕분에 마감 시간에 무언가 제품은 나올 수 있었던것 같다.&lt;/p&gt;
&lt;h3&gt;내가 혼자 (혹은 기술스택이 비슷한 사람) 했다면 어떻게 진행 했을까?&lt;/h3&gt;
&lt;p&gt;일단, 사람을 인식하는 로직과 같이 이미 만들어진 기능들은 최대한 활용하는 식으로 갔을 것 같다.&lt;/p&gt;
&lt;p&gt;저장소로는 S3를 사용하여 주기적으로 사람들의 사진을 저장하고,&lt;/p&gt;
&lt;p&gt;그 사진에 대한 정보(링크)와 간단한 출석 관련 정보는 DynamoDB에 저장을 했을 것 이다.&lt;/p&gt;
&lt;p&gt;프런트는 내가 익숙한 ReactJS로 후딱 짤 수 있을것이다. (화면이 굉장히 간단하다. )&lt;/p&gt;
&lt;p&gt;이를 모두 빠르게 작업하기 위해서 Amplify를 사용하여 연결하였을 것이다.&lt;/p&gt;
&lt;p&gt;시간이 조금 남거나 팀원이 있었다면, 얼굴 인식 서비스(구글, AWS 등)을 이용하여 간단하게 얼굴과 이름을 매핑했을 것이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;결국 있는 기술을 잘 활용 하는게 관건이므로!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;회고&lt;/h2&gt;
&lt;p&gt;오늘로서 부스트캠프 챌린지 과정이 종료 되었다.&lt;/p&gt;
&lt;p&gt;오늘도 정신없이 오전부터 오후까지의 작업을 하니, 끝나는게 실감이 잘 안간다.&lt;/p&gt;
&lt;p&gt;당장 다음주 월요일부터 다시 성수로 갈거 같은 느낌이다.&lt;/p&gt;
&lt;p&gt;오늘은 또한 나의 성장을 느낄 수 있는 하루였다.&lt;/p&gt;
&lt;p&gt;과거의 나 같았으면, 팀 프로젝트 중에 원하는데로 잘 안되면 답답하다고 혼자 따로 했었을 것이다. (실제로도 몇번 그랬었다. )&lt;/p&gt;
&lt;p&gt;하지만, 팀 프로젝트의 진정한 의미와 가치를 아는 지금, 그런 짓을 하지는 않는다.&lt;/p&gt;
&lt;p&gt;최대한 팀원에게 설명하고, 같이 하려 한다. 그래야 배우는게 있는 과정이므로.&lt;/p&gt;
&lt;p&gt;그럼 점에서 나에게 뿌듯 하였다.&lt;/p&gt;
&lt;p&gt;(물론, 직장 같은 곳에 가면 성과와 시간이 중요하므로, 어떻게든 혼자 캐리하기 위해 뛰겠지만…)&lt;/p&gt;
&lt;p&gt;오늘도 배울수 있어 감사한 하루다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 챌린지 19일차]]></title><description><![CDATA[…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-challenge/day-19/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-challenge/day-19/</guid><pubDate>Thu, 08 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;피어 세션 중 생각 정리&lt;/h2&gt;
&lt;h3&gt;[세부 작업의 종료를 아는 주체는 누구일까]&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;미션에서는 고객의 모든 주문 처리시, 매니저가 받아서 대쉬보드를 갱신하는 방식으로 제시 하였다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;나의 경우는 실제 카페를 생각하여 구현하였다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;실제 카페에서는, 바리스타가 매 조리 완료시 마다 매니저한테 일일이 보고하고, 매니저가 일의 종료를 파악하여 대시보드를 갱신하는 시스템일까?&lt;/li&gt;
&lt;li&gt;아니면, 바리스타가 매 조리 완료시 마다 대시보드를 갱신하고, 대시보드가 종료를 판단할까?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;이에 대한 나의 답은 적지 않겠다. 무엇이든 답이 될 수 있으니, 판단은 글을 읽는 사람에게 맡기겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;[재 사용 되는 요소들은 따로 클래스로]&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;지난 과정동안 클래스는 최대한 사용하지 않으려 하였다. 대부분 함수로도 가능하였고, 함수형으로 작성하고자 하였다&lt;/li&gt;
&lt;li&gt;이번 미션에서는 따로 별도의 DB가 존재하지 않았고, 하나의 객체를 데이터 저장소로서 활용해야 했기 떄문에 순수 함수로는 힘들다여겨 클래스를 사용하였다.&lt;/li&gt;
&lt;li&gt;특히, 서로다른 queue가 7개 생성되는데, 비슷한 기능을 제공하는 큐가 반복되었으면, 코드가 굉장히 복잡해졌을 것이다.&lt;/li&gt;
&lt;li&gt;각각의 큐를 queueManagement에서 생성, 관리 하여 사용하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;챌린지 중 느낀것&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;[URL의 구성 요소에 대한 이해]&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;통신에 대한 과제가 주어졌고, URL에 대한 이해가 필요해서 자료를 조사하였다.&lt;/p&gt;
&lt;p&gt;시간이 한정적이기 때문에 많은 내용을 이해하지는 못했지만, 몇가지 흥미로운 부분들이 보였다.&lt;/p&gt;
&lt;p&gt;첫째로, 우리가 자주 사용하는 URL의 구조와 달리 실제 구조에는 몇가지 구성요소가 더 있다.&lt;/p&gt;
&lt;p&gt;예를 들어, 나는 다음 표에서 protocol + host + path 정도만 사용하고 알고 있었다 .&lt;/p&gt;
&lt;p&gt;그런데 오늘 다음 자료를 보며 이와 더불어 auth와 hash가 있음을 알게 되었다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://nodejs.org/api/url.html&quot;&gt;[NodeJS URL]&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://url.spec.whatwg.org/&quot;&gt;[whatwg]&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;항상 url을 브라우저에 입력함에도 불구하고 이것이 어떻게 파싱 되는지에 대한 구체적인 고민이 없었는데, 오늘 이를 한번 돌아보게 하는 경험이였다.&lt;/p&gt;
&lt;h3&gt;[시간 분배의 실패]&lt;/h3&gt;
&lt;p&gt;오늘은 TDD로 처음부터 끝까지 진행하고자 하였다. 어제와 같이 주요 기능별로(URL, HTTP, NET, DNS) 모듈화를 하고 각각의 테스트를 작성하고자 하였다.&lt;/p&gt;
&lt;p&gt;원하는데로 각각의 구성요소에 대한 테스트를 잘 작성 하였는데, 문제는 이것이 시간이 너무 오래 걸렸다는 점이다.&lt;/p&gt;
&lt;p&gt;TDD의 방식대로, 실패하는 코드를 짜고 그린 라이트를 만들어 가며 URL구조를 만들며 이해를 하였는데, 생각보다 시간이 너무 걸려서 6시 정도 에 URL기능 하나가 완성되었다.&lt;/p&gt;
&lt;p&gt;또, 중간에 하나의 체크리스트에서 막혔는데, 그 부분이 계속 막히면 잠시 중단하고 다음 부분을 구현한 뒤에 다시 돌아 왔어야 했는데, 미련하게 그 한 부분만 2시간을 더 잡아 먹은 것 같다.&lt;/p&gt;
&lt;p&gt;나머지 1시간동안 열심히 코딩을 하였지만, 나머지 체크리스트를 모두 채우기에는 역부족이였고, 오늘은 나의 완벽한 패배였다.&lt;/p&gt;
&lt;h3&gt;[아무리 급해도 돌아갔어야…]&lt;/h3&gt;
&lt;p&gt;오늘 위에서 2시간 동안 헤맨 문제는 사실 단순한 문제였다.&lt;/p&gt;
&lt;p&gt;HTTP Request를 보내는데, 끝에 개행이 들어가야 한다.&lt;/p&gt;
&lt;p&gt;나는 이 부분에 대해 자각하지 않고, 어떨때는 넣었다가, 또 어떨때는 안 넣어서 프로그램의 결과가 계속 변했다.&lt;/p&gt;
&lt;p&gt;여기서 나는 나의 Request를 작성하는 부분에서 문제가 있을거란 생각을 못하고 계속해서 Node관련한 문서만 훑었다.&lt;/p&gt;
&lt;p&gt;내가 어디선가 예제를 잘못 복사한건 아닌지, 잘못된 메소드를 사용하는건 아닌지 한참 해맸던것 같다.&lt;/p&gt;
&lt;p&gt;물론, 내가 Node에 대해 많이 이해하지 못하고 있었기 때문일수도 있다.&lt;/p&gt;
&lt;p&gt;하지만, Http request header에 대한 규칙을 꼼꼼히 읽어 봤어도, 이 문제는 쉽게 캐치할 수 있었는데 아쉽다.&lt;/p&gt;
&lt;p&gt;오늘은 너무 구현에만 마음이 앞서다가, 아무것도 하지 못하였다.&lt;/p&gt;
&lt;h3&gt;[URL 모듈을 만드는데 크게 도움이 된 두가지 그림]&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;┌────────────────────────────────────────────────────────────────────────────────────────────────┐
│                                              href                                              │
├──────────┬──┬─────────────────────┬────────────────────────┬───────────────────────────┬───────┤
│ protocol │  │        auth         │          host          │           path            │ hash  │
│          │  │                     ├─────────────────┬──────┼──────────┬────────────────┤       │
│          │  │                     │    hostname     │ port │ pathname │     search     │       │
│          │  │                     │                 │      │          ├─┬──────────────┤       │
│          │  │                     │                 │      │          │ │    query     │       │
&amp;quot;  https:   //    user   :   pass   @ sub.example.com : 8080   /p/a/t/h  ?  query=string   #hash &amp;quot;
│          │  │          │          │    hostname     │ port │          │                │       │
│          │  │          │          ├─────────────────┴──────┤          │                │       │
│ protocol │  │ username │ password │          host          │          │                │       │
├──────────┴──┼──────────┴──────────┼────────────────────────┤          │                │       │
│   origin    │                     │         origin         │ pathname │     search     │ hash  │
├─────────────┴─────────────────────┴────────────────────────┴──────────┴────────────────┴───────┤
│                                              href                                              │
└────────────────────────────────────────────────────────────────────────────────────────────────┘
(all spaces in the &amp;quot;&amp;quot; line should be ignored — they are purely for formatting)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;출처: &lt;a href=&quot;https://nodejs.org/api/url.html&quot;&gt;https://nodejs.org/api/url.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/daily-study/static/45eabe002de28754207173aae37a97fa/d53ff/Untitled-799d1d3c-6948-4774-8f29-1fffcaf072cd.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 9.45945945945946%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAAAsSAAALEgHS3X78AAAAoUlEQVQI12M4v9Fm6aGlpr4Hl5ra7phrZMQABHxsDKxAivnkztKAVXPitRkggGlah4/MuX01E1f2aWqd2Zbgf3RblX9bHr/M4ZUubhcO1GdtWJBgyQADFzdbq+1ZYGhw9Whb56ltaZ07Ziq5n97XaXtgVZD52c3eqSd3VjdkRQhwgNSeW60ifnZ7os/pPfXuhxZI8Z/a4G5/YX996pHN+foAyoZAKDnLBQ0AAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Untitled 799d1d3c 6948 4774 8f29 1fffcaf072cd&quot;
        title=&quot;Untitled 799d1d3c 6948 4774 8f29 1fffcaf072cd&quot;
        src=&quot;/daily-study/static/45eabe002de28754207173aae37a97fa/fcda8/Untitled-799d1d3c-6948-4774-8f29-1fffcaf072cd.png&quot;
        srcset=&quot;/daily-study/static/45eabe002de28754207173aae37a97fa/12f09/Untitled-799d1d3c-6948-4774-8f29-1fffcaf072cd.png 148w,
/daily-study/static/45eabe002de28754207173aae37a97fa/e4a3f/Untitled-799d1d3c-6948-4774-8f29-1fffcaf072cd.png 295w,
/daily-study/static/45eabe002de28754207173aae37a97fa/fcda8/Untitled-799d1d3c-6948-4774-8f29-1fffcaf072cd.png 590w,
/daily-study/static/45eabe002de28754207173aae37a97fa/efc66/Untitled-799d1d3c-6948-4774-8f29-1fffcaf072cd.png 885w,
/daily-study/static/45eabe002de28754207173aae37a97fa/d53ff/Untitled-799d1d3c-6948-4774-8f29-1fffcaf072cd.png 1068w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;출처:&lt;a href=&quot;https://en.wikipedia.org/wiki/URL&quot;&gt;https://en.wikipedia.org/wiki/URL&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;첫번째 표는, URL의 구성요소를 파악하는데 큰 도움이 되었다.&lt;/p&gt;
&lt;p&gt;두번째 그림은, 어떻게 URL을 쪼갤 수 있을지 그 순서에 대해 큰 영감을 주었다.&lt;/p&gt;
&lt;h2&gt;회고&lt;/h2&gt;
&lt;p&gt;만족스럽지 못한 하루였다.&lt;/p&gt;
&lt;p&gt;항상 끝이 중요한 것인데, 나는 오늘 마지막에 너무 느슨해 졌다.&lt;/p&gt;
&lt;p&gt;특히 오늘 지각을 하였는데, 팀원에게도 죄송하고, 내 자신에게도 너무 실망하였다.&lt;/p&gt;
&lt;p&gt;게다가 오늘 구현해야 하는 목표치를 달성하지 못한였고, 너무 아쉬웠다.&lt;/p&gt;
&lt;p&gt;오늘은 다시한번 반성을 하게되는 하루다.&lt;/p&gt;
&lt;p&gt;내일은 더 분발하고 두배로 노력하여 잘 마무리 짓도록 하겠다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 챌린지 18일차]]></title><description><![CDATA[피어 세션 중 생각 정리 setTimeout 내부 동작 방식 setTimeout의 동작 방식은 JS를 실행하는 엔진의 구현방식에 따라 상이합니다. 웹에서는 web API로 추상화된 기능을 사용할 수 있고, Node…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-challenge/day-18/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-challenge/day-18/</guid><pubDate>Wed, 07 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;피어 세션 중 생각 정리&lt;/h2&gt;
&lt;h3&gt;[setTimeout 내부 동작 방식]&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;setTimeout의 동작 방식은 JS를 실행하는 엔진의 구현방식에 따라 상이합니다.&lt;/li&gt;
&lt;li&gt;웹에서는 web API로 추상화된 기능을 사용할 수 있고, Node에서도 동일하게 사용 가능합니다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;노드에서의 setTimeout event Loop 속의 Timers에 의해 제공됩니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Event Loop의 Timer phase에서 콜백으로서 setTimeout과 setInterval이 스케쥴되면&lt;/li&gt;
&lt;li&gt;목표하는 시간에 다달으면 반환됩니다.&lt;/li&gt;
&lt;li&gt;이 작업은 메인 쓰레드가 아닌, 별도의 쓰레드 풀 혹은 OS에서 처리 되며&lt;/li&gt;
&lt;li&gt;목표하는 실행/종료 시간은 정확하게 지정된 시간을 목표로 하지 않습니다.&lt;/li&gt;
&lt;li&gt;다만, &lt;strong&gt;최소&lt;/strong&gt; 해당 시간을 지나는 것만 보장합니다.&lt;/li&gt;
&lt;li&gt;따라서, 이를 사용하여 strict하게 시간을 ms 단위로 조작하는것은 불가능 합니다.&lt;/li&gt;
&lt;li&gt;이러한 setTimeout과 setInterval 명시적으로 삭제하지 않으면 계속해서 살아있으므로 clear 해 줘야 합니다.&lt;/li&gt;
&lt;li&gt;브라우저에서의 setTimout은 브라우저가 사용하는 엔진에 따라 차이가 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;[Service Worker]&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;웹 어플리케이션, 브라우저 그리고 네트워크 사이에 존재하는 프록시 서버로서의 역할을 갖습니다.&lt;/li&gt;
&lt;li&gt;이는 효과적인 오프라인 경험을 제공하기 위해 설계 되었습니다.&lt;/li&gt;
&lt;li&gt;프록시 서버로서 중간의 네트워크 요청을 가로체고, 이를 바탕으로 네트워크 연결 상황에 따라 적절한 행동을 취합니다.&lt;/li&gt;
&lt;li&gt;이와 동시에 네트워크에서 캐싱을 하며 사용자의 오프라인 웹 경험을 원활하게 합니다.&lt;/li&gt;
&lt;li&gt;이와 더불어 웹에서의 푸시 알림(push notification)과 background sync api로의 접근을 가능케 합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;챌린지 중 느낀것&lt;/h2&gt;
&lt;h3&gt;[ 구조에 대한 고민 ]&lt;/h3&gt;
&lt;p&gt;오늘 코드를 작성하며 이벤트 방식의 처리를 최대한 활용하려 노력했다.&lt;/p&gt;
&lt;p&gt;이벤트 방식과 옵져버 패턴 등에 아직 부족함이 많지만, 내 생각대로 정리하여 구현하였다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;항상 꿈은 원대하다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;사실 처음에는 RX를 학습하여 적용해볼까 라는 고민이 있었다.&lt;/p&gt;
&lt;p&gt;지금 생각하면, 시간도 없는데 큰일 날 뻔했다. 학습을 하는데만 하루는 후딱 지나갔을 것이고, 과제는 해결하지 못했을 것이다.&lt;/p&gt;
&lt;p&gt;그러나 RX를 접목해보고자 했던 나의 생각은 어느정도 일리가 있었던것 같다.&lt;/p&gt;
&lt;p&gt;데이터가 시간에 따라 흐르고, 그 데이터 들을 처리하는 것은 이번 학습 과정과 어느정도 유사한듯 하였다 . 그러나 고민을 더 해보니, 시간의 흐름에 따라 주문이 계속 들어오면, 어느순간 사라지는 주문이 생겨버릴 수 있을거란 생각이 들었다.&lt;/p&gt;
&lt;p&gt;그래서 RX는 시도하지 않았고, 추후에 제대로 학습하여 도전 해보기로 하였다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Decoupling &amp;#x26; Modulization&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이 용어를 제대로 사용 하였는지는 잘 모르겠다.&lt;/p&gt;
&lt;p&gt;그러나 오늘 구현을 함에 있어서 이 두 단어를 계속 머릿속에 두며 코딩을 하는것 만으로도, 사고의 확장을 느낄 수 있었다.&lt;/p&gt;
&lt;p&gt;내가 항상 짜오던 코드는, 함수가 다른 함수를 꼬리 물듯 호출하며, 이를 통해 기능간의 종속이 생기곤 했다.&lt;/p&gt;
&lt;p&gt;이번 과제에서는 event 방식을 사용하여 두 기능 사이의 직접적인 연결을 끊으려 노력하였다.&lt;/p&gt;
&lt;p&gt;(DB와 같은 역할을 하는 작업 queue는 분리 할 수 없었고 공유해야 했다.)&lt;/p&gt;
&lt;p&gt;예를 들어, 일을 시키는 &lt;code class=&quot;language-text&quot;&gt;manager&lt;/code&gt; 와 일을 수행하는 &lt;code class=&quot;language-text&quot;&gt;worker&lt;/code&gt; 의 연결고리를 메세지로만 사용하여, 최대한 느슨한 연결고리를 만들고자 하였다.&lt;/p&gt;
&lt;p&gt;잘 되었는지는 모르겠다. 하지만, 이렇게 고민하는것 만으로도 큰 발전이 있었다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;woker&lt;/code&gt; 의 기능/데이터를 &lt;code class=&quot;language-text&quot;&gt;manager&lt;/code&gt;에서 최대한 접근하지 않으려 노력했다.&lt;/p&gt;
&lt;p&gt;예를 들어, 어제의 경우에는 manager에서 worker의 상태를 확인하기 위한 로직이 manager에 들어 있었다. 이 정보는 다른 기능들과 공유가 어려웠었다.&lt;/p&gt;
&lt;p&gt;오늘은, 하나의 array pool? 과 같은 형태로 별도의 모듈 형식으로 manager와 분리 시켰다.&lt;/p&gt;
&lt;h2&gt;회고&lt;/h2&gt;
&lt;p&gt;오늘도 과제를 하며 몇번 씩 펜을 던지고 싶은 마음이 들었다.&lt;/p&gt;
&lt;p&gt;8:58분까지 push를 하며 최선을 다해 구현 할 수 잇는데 까지 하고자 하였다.&lt;/p&gt;
&lt;p&gt;다행히 마지막 push에서 원하는 기능을 모두 추가할 수 있었다.&lt;/p&gt;
&lt;p&gt;항상 드는 생각이지만, 포기하지 않는게 가장 중요하다.&lt;/p&gt;
&lt;p&gt;부스트캠프 코딩테스트 때도 잘 풀리지 않아 몇번이나 포기하고자 하는 마음이 생겼었다.&lt;/p&gt;
&lt;p&gt;그러나 결국 어떻게든 끝까지 고민하여 데드라인 근처에서 구현할 수 있었다.&lt;/p&gt;
&lt;p&gt;.오늘도 8시까지도 4개정도의 기능이 구현되지 않았었고, 심지어 오류도 나기 시작했었다. 하지만 끝까지 컴퓨터흘 놓지 않았고, 해낼 수 있었다&lt;/p&gt;
&lt;p&gt;항상 그래 왔던것 같다.&lt;/p&gt;
&lt;p&gt;내가 남들보다 뛰어나지 않으니 남들보다 두 배로 뛰는수밖에 없다.&lt;/p&gt;
&lt;p&gt;더이상 과거의 나처럼 자만하고, 게을러지지 말자&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;끝까지 가면 내가 다 이겨&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 챌린지 17일차]]></title><description><![CDATA[피어 세션 중 생각 정리 코드 구성에 대한 고민 type array 를 제외한 모든 type은 child:[] 를 갖지 않는다. 이렇게 하는게 조금 더 자연스러운것 같다. array는 child를 갖을 수 있지만, 나머지 자료형은 child…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-challenge/day-17/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-challenge/day-17/</guid><pubDate>Tue, 06 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;피어 세션 중 생각 정리&lt;/h2&gt;
&lt;h3&gt;[코드 구성에 대한 고민]&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;type array 를 제외한 모든 type은 child:[] 를 갖지 않는다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이렇게 하는게 조금 더 자연스러운것 같다.&lt;/li&gt;
&lt;li&gt;array는 child를 갖을 수 있지만, 나머지 자료형은 child를 갖을 수 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;재귀를 사용하지 않는다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;가정에서 배열이 무한 중첩된 형태도 해석되야 하는데,&lt;/li&gt;
&lt;li&gt;재귀가 너무 많이 쌓이게 되면 메모리가 터질것 같았다.&lt;/li&gt;
&lt;li&gt;단순히 루프를 돈다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;현재 위치는 currentPosition 에 저장한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이전까지 접근한 위치는 positions 에 stack 형태로 저장 된다.&lt;/li&gt;
&lt;li&gt;이를 통하여, 이전 위치로 가고 싶다면 stack 최상단 요소를 pop() 하여 currentPosition을 대체하면 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;코드 구조에 대한 고민&lt;/h3&gt;
&lt;h3&gt;[무한 중첩된 구조]&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;무한한 중첩이 기대되는 상황에서는 반복문을 통한 처리가 적합하다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;재귀의 장점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;코드가 간결해지고, 변수사용이 줄어드는 장점이 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;재귀의 단점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JS엔진을 구현한 브라우저 별로 Max Call Stack size가 존재한다.&lt;/li&gt;
&lt;li&gt;재귀를 사용하여 무한으로 중첩된 구조를 처리한다면, max call stack size를 넘어 애플리케이션이 뻗을 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;[에러처리에 대한 흐름제어]&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;throw new Error()&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;try-catch&lt;/code&gt;를 활용하여 실제 사용자가 에러로 인해 프로그램 종료가 발생하는 상황을 방지 하였다.&lt;/li&gt;
&lt;li&gt;여기서 중요한 것은, 각각의 기능은 &lt;code class=&quot;language-text&quot;&gt;Error&lt;/code&gt;를 방출하지만, 실제 사용하는 주체가 &lt;code class=&quot;language-text&quot;&gt;try-catch&lt;/code&gt;를 처리해 줘야 한다는 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;컴파일러 구조와 나의 구현에 대한 고민&lt;/h2&gt;
&lt;h2&gt;챌린지 중 느낀것&lt;/h2&gt;
&lt;h3&gt;[과제 해결 과정]&lt;/h3&gt;
&lt;p&gt;오늘도 코드를 작성하기 이전에 이론에 대한 학습을 하였다.&lt;/p&gt;
&lt;p&gt;쓰레드와 프로세스 등 내가 잘 모르고 있던 부분에 대한 학습을 하고, 이를 어떻게 구현할지 전략을 세웠다.&lt;/p&gt;
&lt;p&gt;미션 수행과 학습에 대한 밸런스를 맞추기 위해 오늘도 4시쯤 과제를 시작하였다.&lt;/p&gt;
&lt;p&gt;오늘과 같은 복잡한 미션을 수행하기 앞서 그림을 그리고 생각의 흐름을 작성하는게 도움이 될듯 하여 다음과 같이 구조를 짜 봤다.&lt;/p&gt;
&lt;p&gt;그렇게 복잡한 구조는 아니지만, 이를 통하여 내가 나눠야 할 부분들이 명확하게 보였고, 기능의 분리를 할 수 있었다.&lt;/p&gt;
&lt;p&gt;기능이 분리되고 각각 맡은 바를 하니 구현도 용이했던것 같다.&lt;/p&gt;
&lt;h3&gt;[처음 알게 된 부분 정리]&lt;/h3&gt;
&lt;h4&gt;브라우저에서의 멀티 쓰레딩??&lt;/h4&gt;
&lt;p&gt;노드에서 쓰레드풀을 4개 생성하여 비동기와 관련된 다양한 로직을 처리하는 것은 알고 있었다.&lt;/p&gt;
&lt;p&gt;브라우저에서도 Web api를 통해 이와 비슷한 다중 쓰레드 기능이 제공될 것이라는 생각은 갖고 있었지만, 이 부분을 개발자가 작성할 수 있는지 몰랐다.&lt;/p&gt;
&lt;p&gt;웹에서 자바스크립트로 멀티쓰레딩을 구현할 수 있다는 사실에 놀랐고, 자주 보이던 service worker도 이러한 기술을 활용했음을 알 수 있었다.&lt;/p&gt;
&lt;p&gt;이렇게 멀티쓰레딩을 위하여 Web Workers API가 사용 되었는데, 메세지 기반으로 굉장히 손쉽게 사용할 수 있었다.&lt;/p&gt;
&lt;p&gt;메세지를 주고 받는 부분에 대해서만 생각하고, 이에 대한 쓰레드를 생성하는 과정이 모두 Web Workers API 에서 제공되니, 놀라울 따름이였다.&lt;/p&gt;
&lt;p&gt;오늘도 생각보다 일찍 과제가 끝나서 React로 이 부분을 어떻게 구현할 수 있을까에 대한 고민을 하였다.&lt;/p&gt;
&lt;p&gt;일단 처음에는 나이브하게 js파일을 읽어 들어 window의 webworker를 활용하려는 계획을 하였지만, 역시나 실패하였다.&lt;/p&gt;
&lt;p&gt;생각으로는 빌드 단계에서 JS파일이 합쳐지고, window에 대한 위치가 달라지기 때문이라 짐작 해봤다.&lt;/p&gt;
&lt;p&gt;이를 위해 &lt;code class=&quot;language-text&quot;&gt;worker-loader&lt;/code&gt; 모듈을 설치해 주었고, babel을 활용하여 처리해 주니 React에서 깔끔하게 사용이 가능했다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;$ npm install worker-loader --save-dev&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// webpack.config.js&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  module&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    rules&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        test&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token regex&quot;&gt;/\.worker\.js$/&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        use&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; loader&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;worker-loader&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// App.js&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; Worker &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;./file.worker.js&quot;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; worker &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Worker&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

worker&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;postMessage&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; a&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
worker&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;onmessage&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

worker&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;addEventListener&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;message&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;출처: &lt;a href=&quot;https://webpack.js.org/loaders/worker-loader/&quot;&gt;https://webpack.js.org/loaders/worker-loader/&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;setInterval에 대한 착각&lt;/h4&gt;
&lt;p&gt;오늘 잘못 알고 있던 개념을 나중에 부캠원 부캠원분과 얘기를 나누며 바로 잡을 수 있었다.&lt;/p&gt;
&lt;p&gt;내가 갖고 있던 막연한 생각은, &lt;code class=&quot;language-text&quot;&gt;setInterval&lt;/code&gt; 을 하는 동안 js가 실행되는 main thread를 점유할것이고, interval를 너무 짧게 치면 main thread를 너무 자주 점유해서 자원을 활용하기 어렵다고 착각하였는데, 생각해보니 이 부분은 어차피 Web API나 Node에서 비동기로 처리하기 때문에 문제 될게 없었다.&lt;/p&gt;
&lt;h2&gt;회고&lt;/h2&gt;
&lt;p&gt;역시, 고민을 조금 더 하고 개발을 하는게 바로 개발부터 하는것 보다 훨신 생산적이다.&lt;/p&gt;
&lt;p&gt;구현에 대한 고민과 코드 작성에 대한 밸런스를 잘 맞추고, 목표하는 종료 시간에 끝내는 연습을 자주 하도록 하자.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 챌린지 16일차]]></title><description><![CDATA[…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-challenge/day-16/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-challenge/day-16/</guid><pubDate>Mon, 05 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;주간 자기 회고 시간 중 느낀것&lt;/h2&gt;
&lt;p&gt;오늘 설문조사에 흥미로운 주제의 질문이 나왔고, 나름 열심히 고민하여 제출하였다.&lt;/p&gt;
&lt;p&gt;실제로도 내가 기업을 선택하는데 중요시 보는 요소들이다.&lt;/p&gt;
&lt;h2&gt;좋은 회사에 대한 기준&lt;/h2&gt;
&lt;p&gt;저는 다음과 같은 기준을 갖고 회사를 선택합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;우수한 개발자들의 모임&lt;/li&gt;
&lt;li&gt;공유의 가치를 아는 기업&lt;/li&gt;
&lt;li&gt;좋은 개발 문화를 갖은 기업 (코드리뷰, 다양한 스터디, 더 나은 코드를 위한 고민&lt;/li&gt;
&lt;li&gt;회사의 비전이 명확하고, 해결하고자 하는 문제가 명확한 기업&lt;/li&gt;
&lt;li&gt;기업의 사회적 책임을 이해하고 행하는 기업&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;각각의 요소들에 대해 자세히 설명하겠습니다.&lt;/p&gt;
&lt;h3&gt;우수한 개발자들의 모임&lt;/h3&gt;
&lt;p&gt;:: 신입부터 CTO까지 개발에 열정을 갖고 일하는, 월급 루팡 없이 1인분 이상의 가치를 만들어 내는 집답&lt;/p&gt;
&lt;h3&gt;공유의 가치를 아는 기업&lt;/h3&gt;
&lt;p&gt;:: 지식과 경험을 공유하는것의 중요성을 아는 회사.
:: 기술 블로그, 다양한 커뮤니티 활동, 다양한 발표 등&lt;/p&gt;
&lt;h3&gt;좋은 개발 문화를 갖은 기업&lt;/h3&gt;
&lt;p&gt;:: 코드리뷰, 다양한 스터디, 더 나은 코드를 위한 고민 을 당연시 하는 회사&lt;/p&gt;
&lt;p&gt;:: 개발 지식을 공유하는 문화가 갖춰진 회사&lt;/p&gt;
&lt;h3&gt;회사의 비전이 명확하고, 해결하고자 하는 문제가 명확한 기업&lt;/h3&gt;
&lt;p&gt;:: 큰 그림을 그리고 있는 기업.&lt;/p&gt;
&lt;p&gt;:: 그 그림이 회사가 궁극적으로 해결하려는 문제를 포함하고 있는 기업&lt;/p&gt;
&lt;h3&gt;기업의 사회적 책임을 이해하고 행하는 기업&lt;/h3&gt;
&lt;p&gt;:: CSR을 이해하고, 더 나은 세상을 만들기 위해 고민하는 기업&lt;/p&gt;
&lt;h2&gt;챌린지 중 느낀것&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;오늘은 코드를 작성하기 앞서 어떻게 구현할지 구성을 먼저 생각하고 시작했다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;결과는 만족스러웠다.&lt;/p&gt;
&lt;p&gt;충분히 설계에 대한 고민을 하고 들어가니, 무엇을 해야 할지 명확했고, 문제가 생겨도 체크 포인트로서 활용할 수 있었다.&lt;/p&gt;
&lt;p&gt;조건에서 중요한 부분들을 내 나름대로 1차 가공 하였다.&lt;/p&gt;
&lt;p&gt;그 후 어떻게 데이터가 흐르고 처리될지 고민을 하였다.&lt;/p&gt;
&lt;p&gt;물론 아래 방식도 처음부터 완벽할 순 없었고, 코드를 작성하며 수정을 계속하였다.&lt;/p&gt;
&lt;p&gt;그러나, 어느정도 큰 틀이 잡혀 있었고 TDD를 활용하여 매 기능구현 마다 테스트를 작성 하였기에 수정이 크게 어렵지 않았다.&lt;/p&gt;
&lt;h3&gt;구현 중 고민과 선택&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Test도구는 Jest를 사용하였다.&lt;/li&gt;
&lt;li&gt;사용한 이유는, 챌린지 기간동안 자주 사용하여 익숙하였기 때문.&lt;/li&gt;
&lt;li&gt;재귀를 사용하지 않는다.&lt;/li&gt;
&lt;li&gt;가정에서 배열이 무한 중첩된 형태도 해석되야 하는데,&lt;/li&gt;
&lt;li&gt;재귀가 너무 많이 쌓이게 되면 메모리가 터질것 같았다.&lt;/li&gt;
&lt;li&gt;단순히 루프를 돈다.&lt;/li&gt;
&lt;li&gt;루프를 돌며 &lt;code class=&quot;language-text&quot;&gt;result&lt;/code&gt; 객체의 현재 위치와 이전 위치를 저장하며 순회한다.&lt;/li&gt;
&lt;li&gt;현재 위치는 &lt;code class=&quot;language-text&quot;&gt;currentPosition&lt;/code&gt; 에 저장한다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이전까지 접근한 위치는 &lt;code class=&quot;language-text&quot;&gt;positions&lt;/code&gt; 에 &lt;code class=&quot;language-text&quot;&gt;stack&lt;/code&gt; 형태로 저장 된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이를 통하여, 이전 위치로 가고 싶다면 &lt;code class=&quot;language-text&quot;&gt;stack&lt;/code&gt; 최상단 요소를 &lt;code class=&quot;language-text&quot;&gt;pop()&lt;/code&gt; 하여 &lt;code class=&quot;language-text&quot;&gt;currentPosition&lt;/code&gt;을 대체하면 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;회고&lt;/h2&gt;
&lt;p&gt;오늘은 진짜 공부부터하고 들어갔다.&lt;/p&gt;
&lt;p&gt;지난주에 구현에만 급급하여 제대로된 공부를 하지 못했다는 반성을 반복하지 않기위해서,&lt;/p&gt;
&lt;p&gt;오늘은 아예 코드 구현은 뒤로 미루고 4시까지 개념만 공부하였다.&lt;/p&gt;
&lt;p&gt;특히, 컴파일러는 태어나서 처음 본 개념이였는데, 오래 걸렸지만 대략적인 구조를 파악하는덴 충분한 시간이였다.&lt;/p&gt;
&lt;p&gt;4시까지 코드를 한줄도 작성하지 않아 실제 코드를 작성하려 할때 굉장히 압박을 느꼈는데, 다 하지 못하더라도 최선을 다하자는 생각을 갖고 임하니 별 무리 없이 개발을 완료하였다.&lt;/p&gt;
&lt;p&gt;특히, 대략적인 구조를 파악하며 tokenizer, lexer, parser의 구분을 나름 명확히 하게 되니, 실제 코드를 작성할때도 관심사의 분리가 명확하여 수월하였다.&lt;/p&gt;
&lt;p&gt;오늘 test 코드는 과제중에 하나였는데, TDD로 하려 노력했고 어느정도 성공적이였다.&lt;/p&gt;
&lt;p&gt;신기하게도 4시부터 시작하였지만, 7시에 끝날 수 있었고 지난주 금요일에 우리팀이 마무리 짓지 못했던 릴레이 프로젝트를 손볼 시간이 있었다.&lt;/p&gt;
&lt;p&gt;이에 대한 후기는 다음에 올리도록 하겠다.&lt;/p&gt;
&lt;p&gt;오늘도 정말 많이 배우는 하루였다.&lt;/p&gt;
&lt;p&gt;내일도 많은 경험을 가져갈 수 있다면 좋겠다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;컴파일러에 대한 이해가 부족하여 방황을 하고 있을 때, 마음씨 좋은 부캠원 한분이 다가와서 친절하게 설명을 해주셨다. 본명을 밝히긴 그렇지만 항상 큰 도움이 되고 있다.&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[JS의 switch-case에서 block단위 처리 방법]]></title><description><![CDATA[JS에서  를 사용하면,
 이하 부분이 하나의 block일거라 가정하고 을 쓰면 항상 이미 정의되어있다는 에러가 나서 왜그런가 찾아보니,
 이하 부분이 하나의 block 이더라… 그래서, 별로 변수를 지정하여 사용하려면 다음처럼  뒤에 brackets…]]></description><link>https://sukjae.github.io/daily-study/daily/2019-08-04-1/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/daily/2019-08-04-1/</guid><pubDate>Sun, 04 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;JS에서 &lt;code class=&quot;language-text&quot;&gt;switch-case&lt;/code&gt; 를 사용하면,
&lt;code class=&quot;language-text&quot;&gt;case:&lt;/code&gt; 이하 부분이 하나의 block일거라 가정하고 &lt;code class=&quot;language-text&quot;&gt;let&lt;/code&gt;을 쓰면 항상 이미 정의되어있다는 에러가 나서 왜그런가 찾아보니,
&lt;code class=&quot;language-text&quot;&gt;switch&lt;/code&gt; 이하 부분이 하나의 block 이더라…&lt;/p&gt;
&lt;p&gt;그래서, &lt;code class=&quot;language-text&quot;&gt;case&lt;/code&gt;별로 변수를 지정하여 사용하려면 다음처럼 &lt;code class=&quot;language-text&quot;&gt;case&lt;/code&gt; 뒤에 brackets을 추가해야 한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;//say_hello의 message와 say_hi의 message는 같은 scope!&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;action&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;say_hello&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; message &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;hello&quot;&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;message&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;break&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;say_hi&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; message &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;hi&quot;&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;message&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;break&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 이렇게 case 뒤에 블록처리하면, (case: {}) 각각의 scope!&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;action&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;say_hello&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// added brackets&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; message &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;hello&quot;&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;message&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;break&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// added brackets&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;say_hi&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// added brackets&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; message &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;hi&quot;&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;message&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;break&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;참고링크: &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/switch#Block-scope_variables_within_switch_statements&quot;&gt;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/switch#Block-scope&lt;em&gt;variables&lt;/em&gt;within&lt;em&gt;switch&lt;/em&gt;statements&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Conditional rendering 에서 empty component는 어떻게 처리할까?]]></title><description><![CDATA[처음 든 생각은 Fragment를 이용하는 방법이였다. 반환값으로  를 제공하면, React스럽게 진행될것이라 예상하였다. 이전에 다른 분이 짜놓으신 코드에서는 상황별로 component가  를 반환하게끔 처리 되어있었는데, 이 부분이 ts-check…]]></description><link>https://sukjae.github.io/daily-study/daily/2019-08-04-2/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/daily/2019-08-04-2/</guid><pubDate>Sun, 04 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;처음 든 생각은 Fragment를 이용하는 방법이였다.&lt;/p&gt;
&lt;p&gt;반환값으로 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;&amp;gt;&amp;lt;/&amp;gt;&lt;/code&gt; 를 제공하면, React스럽게 진행될것이라 예상하였다.&lt;/p&gt;
&lt;p&gt;이전에 다른 분이 짜놓으신 코드에서는 상황별로 component가 &lt;code class=&quot;language-text&quot;&gt;false&lt;/code&gt; 를 반환하게끔 처리 되어있었는데, 이 부분이 ts-check에 걸려서 알아보던 중 위 방법을 생각하게 되었다 .&lt;/p&gt;
&lt;h4&gt;디테일한 정보&lt;/h4&gt;
&lt;h4&gt;Modify toggle hoc returning falsy valuse(&lt;code class=&quot;language-text&quot;&gt;false&lt;/code&gt;)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;changed return value from &lt;code class=&quot;language-text&quot;&gt;false&lt;/code&gt; to &lt;code class=&quot;language-text&quot;&gt;&amp;lt;&amp;gt;&amp;lt;/&amp;gt;&lt;/code&gt; (Fragments)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Detailed error Log&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;JSX element type ‘false | Element’ is not a constructor function for JSX elements.&lt;/li&gt;
&lt;li&gt;Type ‘false’ is not assignable to type ‘Element’.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;ts-check error 이미지&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8156543/62411589-22cc2380-b630-11e9-8409-0a6010dbe393.png&quot;&gt;&lt;/p&gt;
&lt;h4&gt;위 에러가 발생하는 부분&lt;/h4&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/// HOC로 wrapping하는 컴포넌트이다&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;toggle&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;WrappedComponent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;ToggleWrapped&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;props&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; props&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;show &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;WrappedComponent &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그러나, 감사하게도 다른 분이 &lt;code class=&quot;language-text&quot;&gt;Fragment&lt;/code&gt;보다 &lt;code class=&quot;language-text&quot;&gt;null&lt;/code&gt;을 사용하는 방법에 대한 의견을 주셨고,&lt;/p&gt;
&lt;p&gt;곧 이 방법이 더 좋은 방법임을 알게 되었다.&lt;/p&gt;
&lt;p&gt;이에 대한 나의 설명은 내가 올린 글로 대체한다.&lt;/p&gt;
&lt;h2&gt;질문자님의 의견 1 : &amp;#x3C;&gt;&amp;#x3C;/&gt; 와 달리 null을 쓰는게 좋지 않을까? 이유는 왜 그럴까?&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;제 생각에도 (Fragment보다 null이 ReactDOM의 입장에서 더 저렴해서) 라는 해석이 맞는것 같습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;이에 대해 다른 코드들은 어떻게 해결하나 찾아봤더니, 역시 &lt;code class=&quot;language-text&quot;&gt;null&lt;/code&gt; 을 통해서 conditional하게 component를 제공하는것 같습니다.&lt;/li&gt;
&lt;li&gt;아래 스샷 포함합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;예시 1, &lt;code class=&quot;language-text&quot;&gt;ReactJS&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;ReactJS&lt;/code&gt; source code중에서 &lt;code class=&quot;language-text&quot;&gt;ReactEmptyComponent-test.js&lt;/code&gt; 부분에서 다음과 같이 empty component를 체크하는 test 코드를 작성했음을 볼 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8156543/62420450-7e002380-b6cd-11e9-872c-3d92c933f4c2.png&quot;&gt;&lt;/p&gt;
&lt;h3&gt;예시 2, &lt;code class=&quot;language-text&quot;&gt;material-ui&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;비슷한 예시로 &lt;code class=&quot;language-text&quot;&gt;material-ui&lt;/code&gt; 에서 &lt;code class=&quot;language-text&quot;&gt;ListItemLink&lt;/code&gt; 을 분기하기 위해서 &lt;code class=&quot;language-text&quot;&gt;null&lt;/code&gt;을 활용하고 있습니다.&lt;/li&gt;
&lt;li&gt;우리의 경우에는, component로서 &lt;code class=&quot;language-text&quot;&gt;null&lt;/code&gt;을 반환하기에 약간의 차이가 있지만,&lt;/li&gt;
&lt;li&gt;그래도, empty component를 표현하기 위해서 &lt;code class=&quot;language-text&quot;&gt;null&lt;/code&gt;을 사용하고 있음을 알 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8156543/62420463-b56ed000-b6cd-11e9-8f5c-196d0d0aaa1b.png&quot;&gt;&lt;/p&gt;
&lt;h2&gt;질문자님의 의견 2 : In rare cases… 왜 드문 경우에일까?&lt;/h2&gt;
&lt;p&gt;질문자님의 질문 : &lt;a href=&quot;https://reactjs.org/docs/conditional-rendering.html#preventing-component-from-rendering&quot;&gt;docs의 내용을 보면&lt;/a&gt;, 다음과 같은 글을 확인할 수 있다. 여기서 conditional하게 rendering하는것은 흔한 패턴인데 왜 rare case라 표현했을까?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In rare cases you might want a component to hide itself even though it was rendered by another component. To do this return null instead of its render output.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;이 부분에 대해서는 위의 사용패턴에서 알아볼 수 있을것 같습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;제 생각에는, 결론적으로 component 자체가 자신이 empty가 될지, 혹은 무언가를 표출할지를 결정하기 보다&lt;/li&gt;
&lt;li&gt;component를 사용하는 주체가 이를 결정하는 상황이 훨씬 많고, 적합하기 때문인것 같습니다.&lt;/li&gt;
&lt;li&gt;우리는 HOC를 활용하여 살짝 상황이 다른것 같습니당&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;1. component 자신이 자신을 표현할지 말지 결정하는 사례&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;예를 들어 아래 예시는 &lt;a href=&quot;https://reactjs.org/docs/conditional-rendering.html#preventing-component-from-rendering&quot;&gt;언급하신 docs에&lt;/a&gt; 있는 예시 입니다.&lt;/li&gt;
&lt;li&gt;다음 &lt;code class=&quot;language-text&quot;&gt;WarningBanner&lt;/code&gt; 컴포넌트는, 자기자신이 자신을 숨기거나 보여지거나 하는 결정권을 들고 있습니다.&lt;/li&gt;
&lt;li&gt;이를 통하여 자신이 null혹은 jsx로 구성된 component를 반환하는 예시입니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;WarningBanner&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;props&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;warn&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
     &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
         &lt;span class=&quot;token comment&quot;&gt;// .. something&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2. component 사용하는 주체가 해당 component를 보여줄지 말지 결정하는 사례&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;반면, 일반적으로 conditional하게 보여주기 위해서는,&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;WarningBanner&lt;/code&gt;는 무조건 jsx 로 구선된 component를 반환하게 하고,&lt;/li&gt;
&lt;li&gt;이를 사용하는 주체가 보여줄지 말지 결정하는 방식이 많이 사용되고,&lt;/li&gt;
&lt;li&gt;그러한 예시를 활용하고 있는것이 제가 보여드린 &lt;code class=&quot;language-text&quot;&gt;ReactJS&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;Material-ui&lt;/code&gt;의 예시에서 사용하는 방법인듯 합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Outter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;props&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;show &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;WrappedComponent &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;p&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;some text&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;p&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
      &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;p&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;some text&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;p&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
      &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;p&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;some text&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;p&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;추가적으로…&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;사실 2번의 예시와 비슷하게 다음과 같은 방법도 있을것 같습니다.&lt;/li&gt;
&lt;li&gt;물론, 여기서도 &lt;code class=&quot;language-text&quot;&gt;props.show&lt;/code&gt; 가 &lt;code class=&quot;language-text&quot;&gt;null&lt;/code&gt;이면 &lt;code class=&quot;language-text&quot;&gt;null&lt;/code&gt;이고, &lt;code class=&quot;language-text&quot;&gt;false&lt;/code&gt;이면 &lt;code class=&quot;language-text&quot;&gt;false&lt;/code&gt; 를 방출하기 때문에 적절히 사용해야 할듯 합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Outter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;props&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;show &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;WrappedComponent &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[React에서 Redux사용시 local state를 사용하면 안되나?]]></title><description><![CDATA[다른 분이 질문하신 내용에 대한 나의 생각을 답변하였다. 그 내용을 기록한다. 질문 : 지난번 세션에서 리액트 컴포넌트에서는 상태를 최대한 배제하는 게 좋다고 하였다. 그렇다면 존의 리액트 전달 방식은 최대한 안쓰는게 좋은가? 그렇다면, state…]]></description><link>https://sukjae.github.io/daily-study/daily/2019-08-04-3/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/daily/2019-08-04-3/</guid><pubDate>Sun, 04 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;다른 분이 질문하신 내용에 대한 나의 생각을 답변하였다. 그 내용을 기록한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;질문 : 지난번 세션에서 리액트 컴포넌트에서는 상태를 최대한 배제하는 게 좋다고 하였다.&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;그렇다면 존의 리액트 전달 방식은 최대한 안쓰는게 좋은가?&lt;/li&gt;
&lt;li&gt;그렇다면, state가 필요할때마다 component에 connect로 연결하다 보니 모든 component에 덕지덕지 붙게 되더라&lt;/li&gt;
&lt;li&gt;상태를 최대한 배제한 상태에서 모든 component에 connect를 연결하는 방식이 나은건지&lt;/li&gt;
&lt;li&gt;평소에 쓰던 방식대로 &lt;code class=&quot;language-text&quot;&gt;props&lt;/code&gt;를 전달해도 되는건지 궁금하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;이에 대한 나의 답변&lt;/h2&gt;
&lt;h3&gt;[1] 일단 근본적으로 &lt;code class=&quot;language-text&quot;&gt;Redux&lt;/code&gt;가 필요한지, 필요하다면 왜 필요한지 고민을 해보셔야 할듯합니다.&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;모든 라이브러리 선택에는 tradeoff가 따름니다.&lt;/li&gt;
&lt;li&gt;Redux또한 예외는 아니며, 심지어 Redux는 사실 React에 종속된 라이브러리도 아닙니다.&lt;/li&gt;
&lt;li&gt;이에 대해서 제가 참 존경하는 개발자이신 Dan Abramov 씨는(redux, Create-react-app ~창시자?~ 개발자) 다음과 같은 글에서 Redux에 대한 생각을 전합니다.
&lt;a href=&quot;https://link.medium.com/l6XsMDx1SW&quot;&gt;[You Might Not Need Redux by @dan_abramov]&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;결국, React component에서 상태를 배제하는 고민을 하기전에 왜 배제해야하고 redux를 왜 사용해야 하는지 명확한 이해가 필요합니다.&lt;/p&gt;
&lt;h3&gt;[2] Redux가 내 애플리케이션에 필요함을 알게된 경우, 로컬 State 사용에 대한 글이 &lt;a href=&quot;https://redux.js.org/faq/organizing-state#do-i-have-to-put-all-my-state-into-redux-should-i-ever-use-reacts-setstate&quot;&gt;Redux F&amp;#x26;Q&lt;/a&gt;에 나와있습니다.&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Using local component state is fine&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Find a balance that works for you, and go with it.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;결국, Redux 를 사용하는 것도 &lt;code class=&quot;language-text&quot;&gt;선택&lt;/code&gt;중에 하나였으므로,
이를 어디까지 활용할지도 개발자의 &lt;code class=&quot;language-text&quot;&gt;선택&lt;/code&gt; 입니다.&lt;/p&gt;
&lt;p&gt;개발을 할수록 느끼는것은 best practice는 있어도 절대적인 방법은 없다는것 입니당&lt;/p&gt;
&lt;p&gt;결국, Redux의 존재이유(개발이유)에 따라 connect가 필요한 경우에는 사용하시면 되고,
필요없다면 사용하지 않으셔도 됩니다.&lt;/p&gt;
&lt;p&gt;이를 고민하기 위해 도움이 될 자료는 &lt;a href=&quot;https://redux.js.org/faq/organizing-state#do-i-have-to-put-all-my-state-into-redux-should-i-ever-use-reacts-setstate&quot;&gt;다음링크&lt;/a&gt;에 있습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Do other parts of the application care about this data?&lt;/li&gt;
&lt;li&gt;Do you need to be able to create further derived data based on this original data?&lt;/li&gt;
&lt;li&gt;Is the same data being used to drive multiple components?&lt;/li&gt;
&lt;li&gt;Is there value to you in being able to restore this state to a given point in time (ie, time travel debugging)?&lt;/li&gt;
&lt;li&gt;Do you want to cache the data (ie, use what’s in state if it’s already there instead of re-requesting it)?&lt;/li&gt;
&lt;li&gt;Do you want to keep this data consistent while hot-reloading UI components (which may lose their internal state when swapped)?&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[fork한 repo, 원본의 변화에 동기화 하기]]></title><description><![CDATA[TL;DR 요즘 프로젝트를 하며 Github을 통해 fork를 많이 한다. 문제는, 내 생각과는 다르게 원본(upstream repository) 에서의 수정 (ex, master 갱신 등) 이 forked된 나의 repo…]]></description><link>https://sukjae.github.io/daily-study/daily/2019-08-03/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/daily/2019-08-03/</guid><pubDate>Sat, 03 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;TL;DR&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// 맨날 겪던 일
원본repo(upstream) -&amp;gt; 내 계정에 fork -&amp;gt; fork된 repo를 local에 clone
-&amp;gt; 원본repo에 변화 가 일어남!!
-&amp;gt; 내 계정에 fork된 레포와 로컬 레포는 변경 반영 안됨!!
-&amp;gt; 어떻게 동기화하지!?!?!?&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// 해결 법
-&amp;gt; local repo에서 원본 repo remote 등록
-&amp;gt; local repo에서 원본 repo fetch
-&amp;gt; local repo에서 fetch 한 branch merge
-&amp;gt; 최종적으로 local에서 합쳐진 repo push 하기!!&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;요즘 프로젝트를 하며 Github을 통해 fork를 많이 한다.&lt;/p&gt;
&lt;p&gt;문제는, 내 생각과는 다르게 원본(upstream repository) 에서의 수정 (ex, master 갱신 등) 이 forked된 나의 repo에는 반영이 되지 않더라.&lt;/p&gt;
&lt;p&gt;항상 clone을 해서 학습을 하였고, 사람들과 함께 개발한 적이 없어 이런 부분에 대해 미숙함이 있었는데, 이번 기회에 해결법에 대해 찾고 정리하였다.&lt;/p&gt;
&lt;h4&gt;[팁: 우리가 사용하는 &lt;code class=&quot;language-text&quot;&gt;Fork&lt;/code&gt;는 사실 Github에 제공하는 기능일 뿐이다.]&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;Github도 Git이라는 기술위에 움직이고, 이 기술위에 더 편의적인 기능을 제공하기 위해 서버측에서 제공하는 Github의 부가적인 기능이다. &lt;br&gt;
사실 Git에는 Fork라는 기능은 없고, Github에서 제공하는 Fork는 Git의 Clone에 부가적인 기능을 제공하는 것 뿐이다. &lt;br&gt;
그래서 아래와 같이 귀찮은 로직이 필요한듯 하다. &lt;br&gt;
참고 링크: &lt;a href=&quot;https://stackoverflow.com/a/6286877&quot;&gt;Are Git forks actually Git clones?,stackoverflow&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;순서 1: 내 Fork 의 &lt;code class=&quot;language-text&quot;&gt;remote&lt;/code&gt; 수정하기.&lt;/h3&gt;
&lt;p&gt;내 &lt;code class=&quot;language-text&quot;&gt;remote&lt;/code&gt; 를 수정해야 한다.&lt;/p&gt;
&lt;p&gt;처음 fork를 떴을때, remote에는 &lt;code class=&quot;language-text&quot;&gt;origin&lt;/code&gt; 만 포함하고 있고, 이는 fork한 나의 레포의 위치이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;$ git remote -v
&amp;gt; origin  https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch)
&amp;gt; origin  https://github.com/YOUR_USERNAME/YOUR_FORK.git (push)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;여기서 알 수 있듯이, 나의 git은 내 원본 repo에 대해 전혀 알지 못한다.&lt;/p&gt;
&lt;p&gt;그렇다면, git에 fork한 나의 repo와 더불어 원본 repo에 대한 정보를 주기 위해선 어떻게 해야 할까?&lt;/p&gt;
&lt;p&gt;다음과 같이 &lt;code class=&quot;language-text&quot;&gt;remote&lt;/code&gt; 를 수정하면 된다. 여기에선 &lt;code class=&quot;language-text&quot;&gt;upstream&lt;/code&gt; 이라는 이름으로 등록하였다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;$ git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이제 나의 local git에서 remote에 대한 연결이 끝났다.&lt;/p&gt;
&lt;p&gt;이제 이 정보를 바탕으로 원본 repo(upstream)와 내 repo(fork)를 동기화하는 방법을 정리해 본다.&lt;/p&gt;
&lt;p&gt;자세한 내용을 &lt;a href=&quot;https://help.github.com/en/articles/configuring-a-remote-for-a-fork&quot;&gt;이 링크의&lt;/a&gt; 내용대로 하면 된다.&lt;/p&gt;
&lt;h3&gt;순서2: 내 Local Fork 동기화하고 remote에 반영하기&lt;/h3&gt;
&lt;p&gt;위에서 내 local repo에 remote에 대한 정보로 upstream을 추가 하였다 .&lt;/p&gt;
&lt;p&gt;이제 이 상태에서 upstream을 &lt;code class=&quot;language-text&quot;&gt;fetch&lt;/code&gt; 하면 local 브랜치인 &lt;code class=&quot;language-text&quot;&gt;upstream/master&lt;/code&gt; 에 원본의 변경사항이 저장된다. (이 경우는 master 브랜치에 변화를 주었다 가정하였다.)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;$ git fetch upstream
&amp;gt; remote: Counting objects: 75, done.
&amp;gt; remote: Compressing objects: 100% (53/53), done.
&amp;gt; remote: Total 62 (delta 27), reused 44 (delta 9)
&amp;gt; Unpacking objects: 100% (62/62), done.
&amp;gt; From https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY
&amp;gt;  * [new branch]      master     -&amp;gt; upstream/master&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;pull&lt;/code&gt; 은 &lt;code class=&quot;language-text&quot;&gt;fetch&lt;/code&gt; 하고 &lt;code class=&quot;language-text&quot;&gt;merge&lt;/code&gt; 하는 작업이다. 차이를 인지하자.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;그 다음 다시 &lt;code class=&quot;language-text&quot;&gt;master&lt;/code&gt; 브랜치로 &lt;code class=&quot;language-text&quot;&gt;checkout&lt;/code&gt; 해준다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;$ git checkout master
&amp;gt; Switched to branch &amp;#39;master&amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;여기까지 정리하면,&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;위에서 &lt;code class=&quot;language-text&quot;&gt;upstream/master&lt;/code&gt; 에 원본으로 부터 받은 정보를 저장하였고,&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;master&lt;/code&gt;로 체크아웃 하였다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이제 &lt;code class=&quot;language-text&quot;&gt;master&lt;/code&gt; 브랜치에 &lt;code class=&quot;language-text&quot;&gt;upstream/master&lt;/code&gt; 정보를 &lt;code class=&quot;language-text&quot;&gt;merge&lt;/code&gt; 한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;$ git merge upstream/master
&amp;gt; Updating a422352..5fdff0f
&amp;gt; Fast-forward
&amp;gt;  README                    |    9 -------
&amp;gt;  README.md                 |    7 ++++++
&amp;gt;  2 files changed, 7 insertions(+), 9 deletions(-)
&amp;gt;  delete mode 100644 README
&amp;gt;  create mode 100644 README.md&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이렇게 되면, 우리는 Local 환경에서 원격에 있던 원본(upstream)과 우리의 작업물을 동기화 할 수 있다.&lt;/p&gt;
&lt;p&gt;이제 이 취합된 데이터를 우리의 원격의 fork repo에 반영하려면, &lt;code class=&quot;language-text&quot;&gt;push&lt;/code&gt;하면 된다.&lt;/p&gt;
&lt;p&gt;자세한 내용은 &lt;a href=&quot;https://help.github.com/en/articles/syncing-a-fork&quot;&gt;이 링크의&lt;/a&gt; 내용대로 하면 된다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 챌린지 15일차]]></title><description><![CDATA[피어 세션 중 생각 정리 전날 구현한 코드에 대해 다시 한번 정리하는 시간을 갖습니다 WEB API 속의 Canvas API   는 HTML속의 DOM 엘리먼트를 뜻합니다. (로서 표현 됩니다.) ](https://developer.mozilla…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-challenge/day-15/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-challenge/day-15/</guid><pubDate>Fri, 02 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;피어 세션 중 생각 정리&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;전날 구현한 코드에 대해 다시 한번 정리하는 시간을 갖습니다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;[WEB API 속의 Canvas API ]&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;canvas Element&lt;/code&gt;&lt;/a&gt; 는 HTML속의 DOM 엘리먼트를 뜻합니다. (&lt;code class=&quot;language-text&quot;&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt;로서 표현 됩니다.)&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;[canvas API&lt;/code&gt;](&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API&lt;/a&gt;) 는 Web API로 제공되는, Javascript로 HTML엘리먼트인 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt;를 조작하기 위해 제공되는 기능입니다.&lt;/li&gt;
&lt;li&gt;이 &lt;code class=&quot;language-text&quot;&gt;canvas API&lt;/code&gt; 라는 기능은, HTML의&lt;code class=&quot;language-text&quot;&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; 엘리먼트와 JS를 이용하여 그래픽을 그리기 위한 수단을 제공합니다.&lt;/li&gt;
&lt;li&gt;이 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt;와&lt;code class=&quot;language-text&quot;&gt;canvas API&lt;/code&gt; 를 더욱 쉽게 사용하기 위해 많은 개발자들은 다양한 라이브러리를 제작하였고, 이에 대한 자세한 내용은 &lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/HTML/Canvas#%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC&quot;&gt;다음 자료&lt;/a&gt;&lt;/strong&gt;에서 확인할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;[node-canvas]&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;다수의 부스트캠프원들이 프로젝트를 진행하며 &lt;code class=&quot;language-text&quot;&gt;node-canvas&lt;/code&gt; 라는 API를 사용하였습니다.&lt;/li&gt;
&lt;li&gt;이 &lt;code class=&quot;language-text&quot;&gt;node-canvas&lt;/code&gt; 는 위의 Web API 기반의 &lt;code class=&quot;language-text&quot;&gt;canvas API&lt;/code&gt;와 이를 더욱 편리하게 사용하는 &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/HTML/Canvas#%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC&quot;&gt;다른 라이브러리&lt;/a&gt;와는 차이를 갖습니다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;node-canvas&lt;/code&gt;는 Web API 기반의 &lt;code class=&quot;language-text&quot;&gt;canvas API&lt;/code&gt;를 모방하여, NodeJS의 환경에서 동일한 결과를 주는것을 목표로 합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;아직, 완벽하게 1:1 대응으로 구현한것은 아니지만, 현재 대응 상황을 &lt;strong&gt;&lt;a href=&quot;https://github.com/Automattic/node-canvas/wiki/Compatibility-Status&quot;&gt;Compatibility Status&lt;/a&gt;&lt;/strong&gt;에서 확인할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;node-canvas&lt;/code&gt;가 &lt;code class=&quot;language-text&quot;&gt;canvas API&lt;/code&gt;와 다른점은, &lt;code class=&quot;language-text&quot;&gt;node-canvas&lt;/code&gt;는 HTML DOM Element인 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt;위에 구현되지 않고, 이를 단지 모방하기 때문에 저희가 브라우저(클라이언트)에서 사용하는 &lt;code class=&quot;language-text&quot;&gt;canvas API&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt;와는 사용 용도와 적용 방법이 다르다 생각합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;[node-canvas는 왜 생겼고, 왜 많이 사용될까?]&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;이 부분부터는 저의 추측에 기반합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;일단, 이에 대해 생각해보기 위해 몇가지 짚고 넘어가야 할 부분이 있습니다.&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;canvas API&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt;의 조합은 클라이언트상에서 &lt;code class=&quot;language-text&quot;&gt;WebGL API&lt;/code&gt;를 사용하고, 클라이언트의 리소스(그래픽을 처리하기 위한)사용합니다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;canvas API&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt;의 조합을 사용시, 연산이 복잡해질수록, 클라이언트에게 큰 Load 주고, 이는 좋지 않은 경험을 줄 수 있습니다.&lt;/li&gt;
&lt;li&gt;현재 모던한 웹 환경은, server-side와 front-side를 구분하고 있습니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;위 내용들을 바탕으로, 저의 생각의 흐름을 서술하겠습니다.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ReactJS, VueJS, Angular 등과 같은 Node기반 FE 도구들이 많이 사용되고 있습니다.&lt;/li&gt;
&lt;li&gt;위 도구들은 기본적으로 SPA의(single page application) 형태를 띄며 JS의 힘을 이용하여 화면을 랜더링 합니다.&lt;/li&gt;
&lt;li&gt;조금 더 구체적으로 들어가면, Virtual DOM을 생성하여 DOM을 모방하고, 이는 JS를 활용하여 클라이언트가 사용하는 RunTime에 DOM 트리와 view가 생성 됩니다.&lt;/li&gt;
&lt;li&gt;문제는, 사용자가 이 SPA를 직접 사용할때만 JS가 발동하며 DOM을 생성하기 때문에, 사용자에게 보여지는 HTML 컨텐츠의 내용과 외부에서 HTML을 직접 접근했을 떄 보여지는 내용이 다릅니다.&lt;/li&gt;
&lt;li&gt;이것이 문제가 되는 이유는, HTML의 존재 이유와 연관이 있습니다.&lt;/li&gt;
&lt;li&gt;HTML은 의미를 갖고 있는 문서로서, 다양한 연결점을 갖고 검색엔진등이 이를 취합하여 정보 제공을 하여야 하는데,&lt;/li&gt;
&lt;li&gt;겉으로만 보기엔 해당 웹 서비스에 아무런 정보가 없어 보이므로, 다른 사용자는 이 서비스의 컨텐츠에 접근이 어렵습니다. (검색엔진은 보통 HTML만 파싱해왔습니다. 현재는 다르지만.)&lt;/li&gt;
&lt;li&gt;이를 해결하기 위해 위 FE 도구를 활용하여 SPA를 구현시 Server Side Rendering(SSR)을 제공하고 클라이언트에서 JS가 발동하기 전에 HTML을 구성하는 기능을 제공합니다.&lt;/li&gt;
&lt;li&gt;문제는, &lt;code class=&quot;language-text&quot;&gt;canvas API&lt;/code&gt; 와 &lt;code class=&quot;language-text&quot;&gt;canvas&lt;/code&gt;를 이용한 구현시, 위에서 언급한대로 클라이언트 상에서 랜더링 된다는 단점이 있습니다.&lt;/li&gt;
&lt;li&gt;만약, &lt;code class=&quot;language-text&quot;&gt;canvas&lt;/code&gt; &amp;#x26; &lt;code class=&quot;language-text&quot;&gt;canvas API&lt;/code&gt;로 보여지는 정보들을(예를 들어 Image) 검색엔진등이 파싱하려 하면, 해당 정보는 아직 생성되지 않았기 때문에, 정보 제공이 어렵습니다.&lt;/li&gt;
&lt;li&gt;이 문제를 해결하기 위해 SSR을 통하여 저장할 HTML을 생성시, node 기반으로 &lt;code class=&quot;language-text&quot;&gt;node-canvas&lt;/code&gt;를 활용하여 미리 이미지를 생성하고 제공할 수 있습니다.&lt;/li&gt;
&lt;li&gt;또한, 이 모든 작업이 서버에서 처리 되므로 클라이언트에게 큰 부답 없이 정보를 제공할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;이런식으로 활용되는 예시는, spritejs,two.js등이 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;[그렇다면, &lt;code class=&quot;language-text&quot;&gt;canvas&lt;/code&gt;를 통해 정적인 이미지 생성이 아닌, 동적인 생성을 필요로 한다면 어떻게 해야하나]&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;위에서 언급 하였듯이, &lt;code class=&quot;language-text&quot;&gt;node-canvs&lt;/code&gt;를 통해 완성된 이미지를 생성할 수 있습니다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이렇게 서버측에서 완성된 이미지를 클라이언트에서 동적으로 사용하기 위해 두가지 방법이 있을듯 합니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;클라이언트 환경에서 별도로 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt;를 생성하고, 서버에서 &lt;code class=&quot;language-text&quot;&gt;node-canvas&lt;/code&gt;를 통해 생성된 이미지를 전달 받아 그 위에 작업 합니다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;node-canvas&lt;/code&gt;에서 지속적으로 새로운 이미지를 생성하고, 클라이언트로 전달합니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;동적으로 &lt;code class=&quot;language-text&quot;&gt;canvas&lt;/code&gt;를 활용하기위해 위 두가지 방법을 사용한다면, 특히 2번째 방법에서 많은 리소스를 사용할듯 합니다.&lt;/li&gt;
&lt;li&gt;서버와의 통신을 통한 &lt;code class=&quot;language-text&quot;&gt;canvas&lt;/code&gt;활용시 , &lt;code class=&quot;language-text&quot;&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; &amp;#x26; &lt;code class=&quot;language-text&quot;&gt;canvas API&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;websocket&lt;/code&gt;을 활용하여, 클라이언트에서 그려주는 방식이 적절할것 같습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;금요일 프로젝트 중 느낀것&lt;/h2&gt;
&lt;h3&gt;전반적인 프로젝트 흐름&lt;/h3&gt;
&lt;p&gt;오늘 우리는 &lt;code class=&quot;language-text&quot;&gt;code style check&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;best practice&lt;/code&gt;를 실시간으로 보여주는 프로젝트를 하였다. &lt;/p&gt;
&lt;p&gt;이번에도 프런트엔드 라이브러리를 활용하지 않고,  &lt;code class=&quot;language-text&quot;&gt;vanila JS&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;jQuery&lt;/code&gt; 조합으로 진행하였다. &lt;/p&gt;
&lt;p&gt;이번 미션에서는 서버가 필요하여 이를 구현하기 위해 &lt;code class=&quot;language-text&quot;&gt;express&lt;/code&gt;를 활용하였다.&lt;/p&gt;
&lt;p&gt;전반적인 미션 만족도는 나쁘지 않았다. 초반 30분간 구현에 대한 브레인 스토밍을 마쳤고, 여기서 나온 결과가 실행 가능한 방법인지 각자 조사를 하는 시간을 20분 가졌다. &lt;/p&gt;
&lt;p&gt;그 후 지난번과 마찬가지로 2인 1조로 페어 프로그래밍을 하려 하였다. &lt;/p&gt;
&lt;p&gt;안타깝게도, 이번엔 주어진 문제가 많아 2인 1조로 팀을 짜 구현을 하긴 하였지만, 서로 다른 작업을 하였다. &lt;/p&gt;
&lt;p&gt;나의 경우, &lt;code class=&quot;language-text&quot;&gt;form&lt;/code&gt;을 생성하고, 이를 &lt;code class=&quot;language-text&quot;&gt;jquery&lt;/code&gt; 를 통하여 &lt;code class=&quot;language-text&quot;&gt;http&lt;/code&gt; 요청을 보내는 부분을 제작하였다. &lt;/p&gt;
&lt;p&gt;오랜만에 &lt;code class=&quot;language-text&quot;&gt;jQuery&lt;/code&gt; 를 만져서 그런지 약간 생소하였지만, &lt;code class=&quot;language-text&quot;&gt;jQuery&lt;/code&gt; 의 쉬운 문법 덕분에 큰 어려움 없이 구현할 수 있었다. &lt;/p&gt;
&lt;p&gt;그 후로 시간이 조금 남아서 &lt;code class=&quot;language-text&quot;&gt;server&lt;/code&gt; 부분을 수정하여 &lt;code class=&quot;language-text&quot;&gt;/api&lt;/code&gt; 를 열어주어 테스트를 하였다. &lt;/p&gt;
&lt;p&gt;이 또한 &lt;code class=&quot;language-text&quot;&gt;node&lt;/code&gt; 도 오랜만이라 좀 버벅였지만, 튜토리얼을 잘 활용하였다. &lt;/p&gt;
&lt;p&gt;기본적인 내용이라 그리 큰 어려움이 없었다. &lt;/p&gt;
&lt;p&gt;그 후 다른 분들이 각자 일을 하시는 동안, code snippet을 클라이언트에서 보여주는 라이브러리를 찾아 봤다. &lt;/p&gt;
&lt;p&gt;그 중에서 &lt;a href=&quot;https://ace.c9.io&quot;&gt;ace 라이브러리&lt;/a&gt; 가 있었는데, 이게 너무 쉽고 잘 만들어져 있어 이를 그냥 활용하면 되었다. &lt;/p&gt;
&lt;p&gt;그러고, 시간이 조금 더 남아 이를 view에 맞추고, 넘겨 받은 수정 코드를 표시하는 작업도 하였다. &lt;/p&gt;
&lt;p&gt;그러나 안타깝게도, 서버측에서 구현한 &lt;code class=&quot;language-text&quot;&gt;linter&lt;/code&gt; 서버가 오류가 있었다. &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;code style&lt;/code&gt; 을 체킹하지 못하고, 기본적인 몇가지만 체크하고 있었다. &lt;/p&gt;
&lt;p&gt;우리가 구현했어야 하는 기술은, &lt;code class=&quot;language-text&quot;&gt;airbnb&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;facebook&lt;/code&gt; , &lt;code class=&quot;language-text&quot;&gt;google&lt;/code&gt; 의 &lt;code class=&quot;language-text&quot;&gt;code style&lt;/code&gt; 이였는데, 우리는 그런 구분이 안되고 있다는것을 나중에야 알았다 .&lt;/p&gt;
&lt;p&gt;이 부분은 좀 아쉬워서 끝나고 남아서 약간 수정하였고, 월요일까지 다시 개인적으로 수정할 예정이다. &lt;/p&gt;
&lt;h2&gt;회고&lt;/h2&gt;
&lt;p&gt;역시 금요일은 쉬엄쉬엄 할 수 있는 날이다. &lt;/p&gt;
&lt;p&gt;큰 스트레스 없이 프로젝트를 재밌게 구현해 볼 수 있었다.&lt;/p&gt;
&lt;p&gt;결과와 상관없이 최선을 다했다는  부분에서 만족한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 챌린지 14일차]]></title><description><![CDATA[피어 세션 중 생각 정리 전날 구현한 코드에 대해 다시 한번 정리하는 시간을 갖습니다 Utils 자주 쓰이는 함수들을 따로 Utils로 분리하여 관리 하였습니다.  를 구현하여 출력되는 log…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-challenge/day-14/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-challenge/day-14/</guid><pubDate>Thu, 01 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;피어 세션 중 생각 정리&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;전날 구현한 코드에 대해 다시 한번 정리하는 시간을 갖습니다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;[Utils]&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;자주 쓰이는 함수들을 따로 Utils로 분리하여 관리 하였습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;custom_log&lt;/code&gt; 를 구현하여 출력되는 log에 색을 입혔다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;custom_log&lt;/code&gt; 는 인자로 &lt;code class=&quot;language-text&quot;&gt;message&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;color&lt;/code&gt;를 받아 올바른 색의 log를 출력한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;예시) &lt;code class=&quot;language-text&quot;&gt;custom_log(&amp;#39;...some log&amp;#39;, GREEN);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;getFormatTime&lt;/code&gt;를 구현하여 &lt;code class=&quot;language-text&quot;&gt;hh:mm:ss&lt;/code&gt; 형태의 시간출력을 제공하였다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이를 통해 log에서 보기 편한 형식의 시간을 확인할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;예시) &lt;code class=&quot;language-text&quot;&gt;---3---10:32:32---&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;[자료구조]&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;다음과 같은 조합으로 Stack, Queue, LIFO 를 구현할 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Stack 구조 : &lt;code class=&quot;language-text&quot;&gt;push&lt;/code&gt; + &lt;code class=&quot;language-text&quot;&gt;pop&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Queue(FIFO) 구조 : &lt;code class=&quot;language-text&quot;&gt;push&lt;/code&gt; + &lt;code class=&quot;language-text&quot;&gt;shift&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;LIFO 구조 : &lt;code class=&quot;language-text&quot;&gt;pop&lt;/code&gt; + &lt;code class=&quot;language-text&quot;&gt;unshift&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;[클로져와 자유 변수]&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;executeCallStack구현시 시간과 콜스택 count를 지속적으로 참조하기 위해 클로져를 사용했습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;아래와 같은 형식의 코드를 통하여 &lt;code class=&quot;language-text&quot;&gt;outter&lt;/code&gt;로 실행되는 함수들이 같은 자유변수를 공유할 수 있습니다&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;outterFunc&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;time &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; count &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; callStack&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 자유변수&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; lastTime &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; time&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 자유변수&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; outter &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;outterFunc&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;outter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;챌린지 중 느낀것&lt;/h2&gt;
&lt;p&gt;오늘 챌린지 미션은 상대적으로 쉬운 과제가 주어졌다.&lt;/p&gt;
&lt;p&gt;기본적인 &lt;code class=&quot;language-text&quot;&gt;canvas&lt;/code&gt; 내용에 대한 학습 후 구현을 하여도 4시 정도에 대부분 마무리 되었던 것 같다.&lt;/p&gt;
&lt;p&gt;보통 같으면, 이 코드를 리펙토링 하기위해 나머지 시간을 모두 부어 개선 하였겠지만,&lt;/p&gt;
&lt;p&gt;이번 미션은 리펙토링을 하고 싶은 생각이 들지 않았다.&lt;/p&gt;
&lt;p&gt;지난 과제와 비교하면, 배움을 얻기 위한 과제 보다는 학습을 위한 과제였다고 생각한다.&lt;/p&gt;
&lt;p&gt;그래서 나는 구현을 마무리 짓고, 배움을 얻어보기 위해 스스로 과제를 내어 진행하였다.&lt;/p&gt;
&lt;p&gt;이에 대한 내용은 부스트캠프와 관련된 미션이 아니므로 &lt;a href=&quot;https://github.com/sukjae/daily-study/blob/master/2019-08-01.md&quot;&gt;&lt;strong&gt;[이곳]&lt;/strong&gt;&lt;/a&gt; 에 작성할 예정이다.&lt;/p&gt;
&lt;h2&gt;회고&lt;/h2&gt;
&lt;p&gt;어제 한 실수를 반복하지 않기 위해 여러번 확인하며 PR을 보냈다.&lt;/p&gt;
&lt;p&gt;오늘은 상대적으로 과제가 쉬워 여유를 부릴 수 있었다.&lt;/p&gt;
&lt;p&gt;부스트 캠프동안 자신감이 많이 생겨 이렇게 개인 프로젝트도 후딱 제작할 수 있게 된것 같다.&lt;/p&gt;
&lt;p&gt;원래는 무엇을 어떻게 만들지 생각만 하다 끝나곤 했는데, JS와 코드에 자신감이 생기니 도전이 어렵지 않았다.&lt;/p&gt;
&lt;p&gt;오늘도 좋은 경험을 하였고, 내일도 새로운 배움이 있다면 좋겠다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[ReactJS 와 HTML canvas 사용하여 사진 위에 그림 그리기]]></title><description><![CDATA[…]]></description><link>https://sukjae.github.io/daily-study/daily/2019-08-01/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/daily/2019-08-01/</guid><pubDate>Thu, 01 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;프로젝트 고민 과정&lt;/h2&gt;
&lt;p&gt;오늘의 챌린지 미션을 끝낸 후, &lt;code class=&quot;language-text&quot;&gt;canvas&lt;/code&gt; 를 더 활용 해 보고 싶었고, 조금 더 실제 개발에서 사용할만할 스킬들을 경험해보고 싶었다. &lt;/p&gt;
&lt;p&gt;그래서 &lt;code class=&quot;language-text&quot;&gt;ReactJS&lt;/code&gt; 와 &lt;code class=&quot;language-text&quot;&gt;Canvas&lt;/code&gt; 그리고 &lt;code class=&quot;language-text&quot;&gt;websocket&lt;/code&gt; 으로 무언가 만들어 보기로 결정하였다. &lt;/p&gt;
&lt;p&gt;무엇을 만들어볼까 고민하다 지난번에 AWS 오프라인 모임에서 다른 분이 위와 비슷한 스택으로 그림판 같은 기능을 구현하셨던 적이 있어서 그 것을 떠올리며 프로젝트를 생각해 보았다. &lt;/p&gt;
&lt;h3&gt;1. [&lt;code class=&quot;language-text&quot;&gt;React&lt;/code&gt; 에 &lt;code class=&quot;language-text&quot;&gt;canvas&lt;/code&gt; 띄우기]&lt;/h3&gt;
&lt;p&gt;개인적으로 React나 node package를 벗어나 다른 기술을 잘 사용해 본적이 없었기에, HTML에서 제공되는 canvas를 React에서 어떻게 활용될지 감이 잘 안왔다. &lt;/p&gt;
&lt;p&gt;그래서 다양한 블로그 글을 읽어보며, 어떻게 HTML DOM element를 리액트에서 접근할지 찾아 보았다. &lt;/p&gt;
&lt;p&gt;내가 잘 떠올리지 못했던 이유는, React는 자체적으로 Virtual DOM을 생성해서 view를 만드는데, 이 Virtual DOM과 실제 HTML DOM이 무언가 차이가 있지 않을까? 차이가 있다면 HTML을 보통의 Vanila JS가 파싱해오듯이 할 수 없는게 아닐까?&lt;/p&gt;
&lt;p&gt;결로은, 그냥 된다. 그냥 리액트로 DOM element를 &lt;a href=&quot;%5Bhttps://ko.reactjs.org/docs/refs-and-the-dom.html%5D(https://ko.reactjs.org/docs/refs-and-the-dom.html)&quot;&gt;Ref 통하여 접근&lt;/a&gt;하면 된다.&lt;/p&gt;
&lt;p&gt;튜토리얼에서 맨날 가능하면 쓰지 말라해서 나는 절대 쓸일이 없을거라 생각했지만, HTML과 DOM이 제공하는 API를 사용하기 위해서는 써야 한다. &lt;/p&gt;
&lt;p&gt;그리고 나는 위의 독스를 따르지 않고 &lt;code class=&quot;language-text&quot;&gt;useRef&lt;/code&gt; hooks를 사용하여 구현하였다. &lt;/p&gt;
&lt;p&gt;다음과 같이 선택하면 된다. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;App&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; canvas &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useRef&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
        &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;canvas
          ref&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;canvas&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
          width&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;800&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
          height&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;800&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
      &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이렇게 &lt;code class=&quot;language-text&quot;&gt;useRef&lt;/code&gt; 를 통해 선택한 dom element는 다양한 메소드와 프로퍼티를 끌고 온다. &lt;/p&gt;
&lt;p&gt;이를 다음과 같이 접근을하여 사용하는게 기본적인 사용법이다.&lt;/p&gt;
&lt;p&gt;위의 독스처럼 &lt;code class=&quot;language-text&quot;&gt;ref&lt;/code&gt; 를 사용하면 그냥 접근할 수 있지만, &lt;code class=&quot;language-text&quot;&gt;useRef&lt;/code&gt; 사용시엔 &lt;code class=&quot;language-text&quot;&gt;current&lt;/code&gt; 를 활용해야 한다. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;App&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; canvas &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useRef&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;ctx&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; setCts&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;undefined&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token function&quot;&gt;useEffect&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;// @ts-ignore&lt;/span&gt;
      &lt;span class=&quot;token function&quot;&gt;setCts&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;canvas&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getContext&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;2d&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//...&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2. [ &lt;code class=&quot;language-text&quot;&gt;React&lt;/code&gt; state를 사용하여  &lt;code class=&quot;language-text&quot;&gt;canvas&lt;/code&gt; 위에 점으로 그림그리기]&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;결국 React state도 그냥 값에 불가하다는 것을 꼭 기억하자. 그럼 세상 쉬워진다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;위에 작성한 코드에서 고민을 좀 해보자. &lt;/p&gt;
&lt;p&gt;캔버스 점을 찍을 수 있지만, 어떻게 점 &lt;code class=&quot;language-text&quot;&gt;들&lt;/code&gt; 을 찍을 수 있을까? 그것도 동적으로. &lt;/p&gt;
&lt;p&gt;느낌을 왔지만, 확실치 않아서 이런저런 시행착오 끝에 답을 찾았다. &lt;/p&gt;
&lt;p&gt;내가 처음 가정한것은 다음과 같앗다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;사용자의 마우스의 위치를 알 수 있는 방법이 Web API에서 제공될것이다.&lt;/li&gt;
&lt;li&gt;무언가 이벤트처럼 위의 위치를 js로, 나아가 react로 넘겨받을 방법이 있을것이다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;React에서는 항상 그러하듯, state로 해당 좌표를 받아야 겠다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;근데, 이 값들을 계속 저장해놔야 그려질까?&lt;/li&gt;
&lt;li&gt;아니면 그냥 값만 주어도 그려질까&lt;/li&gt;
&lt;li&gt;아니면 그냥 값도 저장할 필요가 없을까?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;첫번째, 두번째는 &lt;code class=&quot;language-text&quot;&gt;useRef&lt;/code&gt; 를 통해 접근한 element에 &lt;code class=&quot;language-text&quot;&gt;onMouseMove&lt;/code&gt; 와 같은 이벤트를 받으면 쉽게 해결이 되었다. &lt;/p&gt;
&lt;p&gt;이 이벤트를 &lt;code class=&quot;language-text&quot;&gt;onClick&lt;/code&gt; 이벤트 받듯이 넘기면 사용가능하다. &lt;/p&gt;
&lt;p&gt;3번째에서 나는 고민이 시작되었다. &lt;/p&gt;
&lt;p&gt;처음에는 &lt;code class=&quot;language-text&quot;&gt;cursor&lt;/code&gt; 의 현재 점을 기록하는 state를 생성하여 기록하였다.&lt;/p&gt;
&lt;p&gt;그러나, 이게 불필요 하다는 것을 알게 되었고, 나중에는 그냥 event에서 해당 포인트의 점을 찍게 되었다. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;handleMouseMove&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;ctx&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; rect &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; canvas&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getBoundingClientRect&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      ctx&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;fillStyle &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;black&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      ctx&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;fillRect&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;e&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;clientX &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; rect&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;left&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; e&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;clientY &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; rect&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;top&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;//...&lt;/span&gt;
&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;canvas
  ref&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;canvas&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  width&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;800&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  height&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;800&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  onMouseMove&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;handleMouseMove&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 코드에서 보이다 싶이 다음과 같이 계속 점을 찍어가면, canvas가 존재하는 이상 계속해서 점이 찍힌다. &lt;/p&gt;
&lt;p&gt;그런데 점을 찍는 좌표의 내용이 복잡한 이유는, 현재 나의 스타일에 따라서, 또 canvas의 위치에 따라서 커서의 절대 값이 달라지기 때문이다. &lt;/p&gt;
&lt;p&gt;우리는 항상 좌 상단을 0,0 기준점으로 잡고 생각해야 편하고, 위와 같이 하면 어느정도 커서와 점의 위치를 맞출 수 있다. (더 좋은 방법을 찾아보겠다.)&lt;/p&gt;
&lt;h3&gt;3. [ 초기화 기능 추가하기]&lt;/h3&gt;
&lt;p&gt;다음과 같이 간단하게 구현되었다. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;clrearRect&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt; 를 통하여 현재 캔버스가 덮어씌어 진다&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt; 

    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;handleReset&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    	&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;ctx &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; isStart&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    	  ctx&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;clearRect&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; canvas&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;width&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; canvas&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;height&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    	&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4. [ &lt;code class=&quot;language-text&quot;&gt;React&lt;/code&gt; state를 사용하여  &lt;code class=&quot;language-text&quot;&gt;canvas&lt;/code&gt; 위에 점으로 그림그리며 &lt;code class=&quot;language-text&quot;&gt;undo&lt;/code&gt; 기능 추가하기]&lt;/h3&gt;
&lt;p&gt;이 내용을 다른 부캠원분꼐 보여드리니, undo기능을 구현해보라는 조언을 얻었다. &lt;/p&gt;
&lt;p&gt;구현을 하기 위해선 현재 배열 정보와, 저장된 배열 정보가 필요했고, 나는 둘 모두 state로 관리하였다. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;tracking&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; setTracking&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;history&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; setHistory&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;tracking&lt;/code&gt; 은 현재 게임에서 커서의 위치의 모음이다. 초기화 될때 제거된다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;history&lt;/code&gt; 는 이전 게임에서 커서의 위치의 모음이다. 이 값은 게임이 시작되거나 초기화 될때 제거된다.&lt;/p&gt;
&lt;h3&gt;5. [ 마우스가 눌렸을 때만 커서의 움직임 그리기]&lt;/h3&gt;
&lt;p&gt;커서가 캔버스에 들어가기만 하면 계속해서 그림이 그려졌다. &lt;/p&gt;
&lt;p&gt;이 부분이 뭔가 직관적이지 않아서 클릭하였을때 커서를 움직이면 그림이 그려지도록 하였다. &lt;/p&gt;
&lt;p&gt;위에서 얻은 지식으로 이번에도 event를 사용하여 구현하였다. &lt;/p&gt;
&lt;p&gt;현재 마우스가 클릭되었는지 안되었는지 확인하기 위해 state를 통해 boolean값을 저장하였다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;isMouseDown&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; setIstMouseDown&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;//...&lt;/span&gt;
&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;canvas
    ref&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;canvas&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    width&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;800&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    height&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;800&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    onMouseMove&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;handleMouseMove&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    onMouseDown&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token function&quot;&gt;setIstMouseDown&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    onMouseUp&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token function&quot;&gt;setIstMouseDown&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이는 다시 &lt;code class=&quot;language-text&quot;&gt;handleMouseMove&lt;/code&gt; 에서 그림을 그려주기 전에 확인한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;handleMouseMove&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;ctx &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; isMouseDown &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;6. [ &lt;code class=&quot;language-text&quot;&gt;canvas&lt;/code&gt; 에 이미지 올리기 ]&lt;/h3&gt;
&lt;p&gt;js를 사용하여 web api에 접근할때, &lt;code class=&quot;language-text&quot;&gt;Image&lt;/code&gt; api를 통하여 인스턴스를 생성하고, 여기에 &lt;code class=&quot;language-text&quot;&gt;onload&lt;/code&gt; 에 함수를 이어 붙여 &lt;code class=&quot;language-text&quot;&gt;canvas&lt;/code&gt; 에 그림을 그린다. &lt;/p&gt;
&lt;p&gt;신기하게도, React에서 바로&lt;code class=&quot;language-text&quot;&gt;Image&lt;/code&gt; 를 사용하여도 web api와 동일하게 사용이 가능했다. (같은 web api인지 모방하는지 모르겟다.)&lt;/p&gt;
&lt;p&gt;이 사진을 넣는 작업은 게임 시작에 넣었다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;startGame&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; img &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Image&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    img&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;onload&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      ctx&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;drawImage&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;img&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; canvas&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;width&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; canvas&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;height&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    img&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;src &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;https://loremflickr.com/500/500/cat&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;7. [기타]&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;material-ui&lt;/code&gt;를 추가하여 손쉽게 UI를 꾸밈&lt;/li&gt;
&lt;li&gt;loading 을 보여주기 위해 &lt;code class=&quot;language-text&quot;&gt;LinearProgress&lt;/code&gt; 컴포넌트 사용&lt;/li&gt;
&lt;li&gt;게임 종료 아직 구현 안함&lt;/li&gt;
&lt;li&gt;웹소켓 아직 적용 안함&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://pic-drawing.s3-website.ap-northeast-2.amazonaws.com/&quot;&gt;작동하는 라이브 링크&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;회고&lt;/h2&gt;
&lt;p&gt;생각보다 짧은 시간안에 많은 것을 배웠다. &lt;/p&gt;
&lt;p&gt;역시 제일 좋은 학습 방법은 프로젝트 인가 보다. &lt;/p&gt;
&lt;p&gt;과거처럼 만들기만 하고 끝냈다면, 머릿속에 아무것도 없었겠지만, 이제는 정리를 하면서 한번 더 배우는것 같다. (강제 리펙토링)&lt;/p&gt;
&lt;p&gt;계속해서 발전하자.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 챌린지 13일차]]></title><description><![CDATA[피어 세션 중 생각 정리 전날 구현한 코드에 대해 다시 한번 정리하는 시간을 갖습니다 Model-Controller 기능 구현을 용이하게 하고, 구조화 하기 위해 Model/Controller/Util/Starte…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-challenge/day-13/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-challenge/day-13/</guid><pubDate>Wed, 31 Jul 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;피어 세션 중 생각 정리&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;전날 구현한 코드에 대해 다시 한번 정리하는 시간을 갖습니다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;[Model-Controller]&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;기능 구현을 용이하게 하고, 구조화 하기 위해 Model/Controller/Util/Starte 로 파일구조를 나눴다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Model&lt;/code&gt;은 데이터에 직접 접근하는 모든 작업을 수행한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Model&lt;/code&gt;에서 데이터는 로컬 변수를 사용했지만, DB와 같은 역할이 있을거라 가정하고 대부분의 에러를 호출한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Controller&lt;/code&gt;는 전반적인 명령 수행을 위한 로직이 swtich 문으로 분기 되어있다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Controller&lt;/code&gt;에서는 직접 데이터를 접근할 수 없고, 오직 &lt;code class=&quot;language-text&quot;&gt;Model&lt;/code&gt;을 통해서만 전달받아 사용할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Controller&lt;/code&gt;속에 &lt;code class=&quot;language-text&quot;&gt;View&lt;/code&gt;를 담당하는 부분이 존재하며, 이는 &lt;code class=&quot;language-text&quot;&gt;View&lt;/code&gt;로 변화를 시켜줘야 하지만, 시간상의 제약으로 처리하지 못했다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Error&lt;/code&gt;를 호출하는 쪽은 &lt;code class=&quot;language-text&quot;&gt;Model&lt;/code&gt;이므로, &lt;code class=&quot;language-text&quot;&gt;Controller&lt;/code&gt;에서는 필히 &lt;code class=&quot;language-text&quot;&gt;try-catch&lt;/code&gt;문으로 에러를 핸들링 해줘야 하는 입장이다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Error&lt;/code&gt;를 호출하는 입장과 사용하는 입장의 구분이 명확하니, 불필요한 &lt;code class=&quot;language-text&quot;&gt;Error&lt;/code&gt;의 중복이 발생되지 않았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;[Immutable]&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;모든 데이터를 처리하는 함수는 Immutable한 데이터의 흐름을 가져가도록 노력했다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;함수는 순수하게 작성하기 위해 노력했다.&lt;/li&gt;
&lt;li&gt;이를 위해 사이드 이펙트를 최소화 하려 노력했고, 그 수단으로 Immutable한 데이터 접근을 수행하였다.&lt;/li&gt;
&lt;li&gt;새로운 배열을 반환하는 &lt;code class=&quot;language-text&quot;&gt;reduce&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;filter&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;map&lt;/code&gt;등의 기능을 활용하였다.&lt;/li&gt;
&lt;li&gt;편의를 위해 Shallow Copy를 통한 새로운 배열/객체(데이터)의 반환을 사용하였다.&lt;/li&gt;
&lt;li&gt;그러나, 연산에 필요한 배열/객체(데이터)의 구조가 복잡해 질수록 이를 처리하기 위한 로직이 복잡해 졌다.&lt;/li&gt;
&lt;li&gt;spread-syntax를 최대한 활용하여 변수들의 사용을 최소화 하였지만, 여전히 코드를 읽기 난해하다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 부분을 해결하기 위해선&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;추후에 별도의 immutable 라이브러리를 사용하거나&lt;/li&gt;
&lt;li&gt;배열/객체 데이터의 중첩된 구조를 분리하여 관계형으로(&lt;code class=&quot;language-text&quot;&gt;key&lt;/code&gt; 사용) 만드는 방법 등이 있을것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;state &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;state&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;folder_name &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; folder_name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;copiedFolder&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    files&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
      &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;copiedFolder&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;files&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;file_name &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; file_name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;copiedFile&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        status&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;코드 예시: 해석이 난해하지만, 변수 사용을 줄여봤다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;[상수의 활용]&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;데이터를 처리하는데 있어 오타등의 이유로 인한 에러를 방지하기 위해 상수 사용&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;계속해서 사용되고, 접근하기 위한 &lt;code class=&quot;language-text&quot;&gt;key&lt;/code&gt;값으로 사용되는 &lt;code class=&quot;language-text&quot;&gt;String&lt;/code&gt;형태의 데이터를 따로 상수로 관리하였다.&lt;/li&gt;
&lt;li&gt;이와 같이 사용하면, &lt;code class=&quot;language-text&quot;&gt;local&lt;/code&gt;과 같이 의미는 같지만, 형태가 다른 문자열을 작성하는 실수를 방지할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;LOCAL&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;LOCAL&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;REMOTE&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;REMOTE&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;WORKING&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;WORKING&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;STAGING&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;STAGING&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;COMMITED&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;COMMITED&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;이와 더불어 위 상수들을 배열로 만들어, 옵션들의 선택의 폭을 줄였다.(enum과 같은 느낌?)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; locationOptions &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;LOCAL&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;REMOTE&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; statusOptions &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;WORKING&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;STAGING&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;COMMITED&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//...&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;statusOptions&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;includes&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;status&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;//...  some logic&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;챌린지 중 느낀것&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;오늘 작성한 내용중 [자바스크립트 비동기] 에 대한 정리는 추가로 수정하여 데일리 스터디에 넣도록 한다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;구현 전 학습&lt;/h3&gt;
&lt;p&gt;오늘은 JS에서 중요한 비동기에 대한 개념이 나왔다. &lt;/p&gt;
&lt;p&gt;일전에 학습한 내용이였지만, 어제처럼 섣불리 구현하고 싶진 않았다. &lt;/p&gt;
&lt;p&gt;어제는 기술에 대한 학습을 충분히 하지 않고,구현을 하는데 급급했다.  이로 인해서 어느정도 구현을 하였지만, 기억에 남는 지식이 얼마 없었다. &lt;/p&gt;
&lt;p&gt;그래서 오늘은 안내에 나온 학습목표를 위한 내용을 충분히 숙지하고, 구현을 시작하였다. &lt;/p&gt;
&lt;p&gt;좀 어려운 개념이라 구현을 너무 늦게 시작한 감도 없지 않아 있지만 (오후 3시쯤 시작),  어느정도 성공적으로 마무리 지었다. &lt;/p&gt;
&lt;p&gt;과제가 너무 어렵게 나오면 이런식으로 하지 못하겠지만, 가능한 학습과 구현의 밸런스를 맞춰가며 적당하게 타협을 보고 싶다.(너무 한쪽으로만 가고 싶지 않다)&lt;/p&gt;
&lt;p&gt;앞서 언급 하였듯이, 오늘은 코드를 구현하기 전에 기술에대해 다시한번 조사를 시작하였다. &lt;/p&gt;
&lt;p&gt;일단, 내가 얕게 알고 있는 지식으로는 과제에서 나온 형태의 Event Loop에 대한 설명이 살짝 잘못 된 설명이라는 것을 알고 있다. &lt;/p&gt;
&lt;p&gt;이에 대해 확실히 정리하기 위해 계속해서 학습을 하였다. &lt;/p&gt;
&lt;p&gt;그러나 안타깝게도, 용어의 난해함과 내용이 너무 추상적이여서 충분히 이해를 하지 못했다. &lt;/p&gt;
&lt;p&gt;하지만, 이해하려 노력하는 과정에서도 많은 배움을 얻을 수 있었다. &lt;/p&gt;
&lt;h3&gt;구현 하며 느낀점&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;setInterval&lt;/code&gt; 등의 기능들을 활용하여 비동기/동기를 오가며 문제를 해결했다. &lt;/p&gt;
&lt;p&gt;남들은 신기하도록 쉽게 해결 하지만, 나는 구현에 큰 어려움을 겪었다 ㅠㅠ&lt;/p&gt;
&lt;p&gt;그럼에도 구현을 하며 비동기에 대한 이해가 늘어 난것 같다. &lt;/p&gt;
&lt;p&gt;특히 오늘 느낀것중 가장 큰 배움은 다음과 같다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;서로 다른 무한 루프를 돌리는 방법&lt;/li&gt;
&lt;li&gt;서로 다른 무한 루프가 돌아가는 중에 다음 줄을 실행하는 방법&lt;/li&gt;
&lt;li&gt;그러면서 비동기도 생각하는 방법&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;[서로 다른 무한 루프를 돌리는 방법]&lt;/h4&gt;
&lt;p&gt;이 부분은 &lt;code class=&quot;language-text&quot;&gt;setInterval&lt;/code&gt; 을 하면 된다. &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;while&lt;/code&gt; 등의 방법으로 무한 루프를 돌리면, 루프 밖을 나가 다른것을 실행하러 나가면 이를 다시 돌아올 방법이 마땅치 않다. &lt;/p&gt;
&lt;p&gt;이 상황에서 &lt;code class=&quot;language-text&quot;&gt;setInterval&lt;/code&gt;을 하면, &lt;code class=&quot;language-text&quot;&gt;clear&lt;/code&gt; 하지 않는 이상 계속 해서 실행 되기 때문에 무한루프와 같은 효과를 낼 수 있고, 이는 여러개 사용이 가능하다. &lt;/p&gt;
&lt;h4&gt;[서로 다른 무한 루프가 돌아가는 중에 다음 줄을 실행하는 방법]&lt;/h4&gt;
&lt;p&gt;앞서 설명한  맥락과 같다.  &lt;/p&gt;
&lt;p&gt;그런데 여기서 다음 실행할 코드를 비동기라 생각하고, 이 코드에 대한 순서를 고려한다면 구현이 좀 어려워진다. &lt;/p&gt;
&lt;p&gt;위의 &lt;code class=&quot;language-text&quot;&gt;setInterval&lt;/code&gt; 은 비동기 호출로서 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다음에 동기가 나오면 동기를 먼저 실행하고,&lt;/li&gt;
&lt;li&gt;다음에 비동기가 나오면, 나오는 순간 바로 큐로 올려버린다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;우리의 구현의 경우에는 두개의 무한루프를 돌리면서&lt;/p&gt;
&lt;p&gt;두 개 모두 루프를 벗어나 다른것을 실행할 수 있어야 했고&lt;/p&gt;
&lt;p&gt;그러면서 외부의 비동기 함수는 바로 큐로 올리면 안되고, 무한 루프 속 루프가 한차례 돌아간 후에 올려야 한다. &lt;/p&gt;
&lt;p&gt;여기서 마지막 부분에 대한 구현이 가장 어려웠다.  그 이유는&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;동시에 두개의 무한 루프를 돌리기 위해 &lt;code class=&quot;language-text&quot;&gt;setInterval&lt;/code&gt; 을 사용하면&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;밖의 루프(&lt;code class=&quot;language-text&quot;&gt;setInterval&lt;/code&gt;) 와 내부의 루프 (&lt;code class=&quot;language-text&quot;&gt;while&lt;/code&gt; 등) 으로 구분되서 작동해야 한다.&lt;/li&gt;
&lt;li&gt;그런데, 밖의 루프가 interval time에 의해서 계속 실행되므로&lt;/li&gt;
&lt;li&gt;밖의 개수만큼 새로운 내부 루프가 생성된다.&lt;/li&gt;
&lt;li&gt;이로 인해 로직이 꼬이고, 진정한 무한루프에 빠져 버린다…&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;만약에 밖의 루프(&lt;code class=&quot;language-text&quot;&gt;setInterval&lt;/code&gt;)만을 활용하여 코드를 작성하면&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;외부에 있는 비동기 함수들이 바로 큐에 쌓여서&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;setInterval&lt;/code&gt; 과 시작선이 같아지고, 그것은 이번 구현 조건에 부합하지 않았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;결국 나는 편법과 같은 방법을 사용해서 구현했고, 내일 다른 이들은 어떻게 구현했을지 기대 된다.&lt;/p&gt;
&lt;h4&gt;[나의 구현 방법 정리]&lt;/h4&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;outterFunc&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;time &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; count &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 어떤 조건&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; lastTime &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; time&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; 
  &lt;span class=&quot;token comment&quot;&gt;// ...클로져로 내부 변수&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;count &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;// ... some logic&lt;/span&gt;
      count &lt;span class=&quot;token operator&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      lastTime &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 탈출 조건&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;count &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; lastTime &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;5000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;// ...some logic&lt;/span&gt;
      process&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 현재 함수에서 벗어나 재귀로 새롭게 호출&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 단, 이 함수는 setTimeout 을 통해 한번 비동기로 실행&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 그러므로, 맨 처음 시작에서는 위의 코드로 동기적으로 실행되지만&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 그 다음부터는 비동기로 실행되고, 이 이후에 나오는 코드를 큐에 쌓을 수 있다&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;count &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token function&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token function&quot;&gt;outterFunc&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;lastTime&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;outterFunc&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;오전 시간에 느낀것&lt;/h2&gt;
&lt;h3&gt;위치 메서드&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;indexOf&lt;/code&gt; 를 사용시에 주의해야 할 부분이 있다. &lt;/p&gt;
&lt;p&gt;그 것은 이 연산이 &lt;code class=&quot;language-text&quot;&gt;===&lt;/code&gt; 연산을 수행하여 값을 반환한다는 점이다. &lt;/p&gt;
&lt;p&gt;즉, 우리가 서로 다른 배열, 객체를 비교 연산자로 제공하면, 이를 찾지 못한다. &lt;/p&gt;
&lt;p&gt;이를 사용하는데 주의하도록 하자. &lt;/p&gt;
&lt;p&gt;예시)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; p1 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;name&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;lee&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; p2 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;name&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;lee&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; p3 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;p1&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;

p2&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;indexOf&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;p1&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// -1 , 없음&lt;/span&gt;
p3&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;indexOf&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;p1&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 0 , index 0 에 존재&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;배열의 변환&lt;/h3&gt;
&lt;p&gt;배열의 기능을 이용하여 다양한 기본 자료구조를 구현할 수 있다. &lt;/p&gt;
&lt;p&gt;우리가 알고 있는 &lt;code class=&quot;language-text&quot;&gt;push&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;pop&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;shift&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;unshift&lt;/code&gt; 를 사용하면 된다. &lt;/p&gt;
&lt;p&gt;stack 구조 : &lt;code class=&quot;language-text&quot;&gt;push&lt;/code&gt; + &lt;code class=&quot;language-text&quot;&gt;pop&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;queue(FIFO) 구조 : &lt;code class=&quot;language-text&quot;&gt;push&lt;/code&gt; + &lt;code class=&quot;language-text&quot;&gt;shift&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;LIFO 구조 : &lt;code class=&quot;language-text&quot;&gt;pop&lt;/code&gt; + &lt;code class=&quot;language-text&quot;&gt;unshift&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;이때 주의해야 할 점이 있는데, &lt;code class=&quot;language-text&quot;&gt;unshift&lt;/code&gt; 연산자는 받은 인자를 한번에 처리한다. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; arr &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
arr&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;unshift&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;fist&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;second&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

arr &lt;span class=&quot;token comment&quot;&gt;//[&apos;first&apos;,&apos;second&apos;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;앞에서 하나씩 앞에 넣어서 second, first 순서가 될 수 있을거라 착각하면 안된다.&lt;/p&gt;
&lt;p&gt;이 오해는 다음과 같은 방향으로 갈거라 오해해서 생겼다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;a → [ ]&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;→ [a]&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;b → [a]&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;→ [b,a]&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;결론은 아니다 다음과 같이 움직인다&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;a,b → [ ]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;→ [a,b]&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;회고&lt;/h2&gt;
&lt;p&gt;오늘은 실수를 너무 많이 했다. &lt;/p&gt;
&lt;p&gt;master 브랜치에 issue를 올리고…&lt;/p&gt;
&lt;p&gt;master 브랜치에 PR을 보내버렸다…&lt;/p&gt;
&lt;p&gt;안되는 날은 뭘 해도 안되나 보다. &lt;/p&gt;
&lt;p&gt;오늘 실수를 다시 반복하지 않도록 항상 조심하자. &lt;/p&gt;
&lt;p&gt;피곤하다는 말로 변명을 할 수 없다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 챌린지 12일차]]></title><description><![CDATA[피어 세션 중 느낀것 async/await 사용에 대한 고민 JS에서  연산자는 다음과 같은 특징을 갖고 있습니다.  await 문은 async함수의 실행을 중단시키고, Promise가 fulfill되거나 reject되기를 기다리고, 다시 async…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-challenge/day-12/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-challenge/day-12/</guid><pubDate>Tue, 30 Jul 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;피어 세션 중 느낀것&lt;/h2&gt;
&lt;h3&gt;[async/await 사용에 대한 고민]&lt;/h3&gt;
&lt;p&gt;JS에서 &lt;code class=&quot;language-text&quot;&gt;await&lt;/code&gt; 연산자는 다음과 같은 특징을 갖고 있습니다. &lt;/p&gt;
&lt;p&gt;await 문은 async함수의 실행을 중단시키고, Promise가 fulfill되거나 reject되기를 기다리고, 다시 async함수를 실행시킵니다. 이때  await 문의 값은 Promise 에서 fulfill된 값이 됩니다.&lt;/p&gt;
&lt;p&gt;만약 Promise가 reject되면, await은 reject된 값을 throw합니다.&lt;/p&gt;
&lt;p&gt;await 연산자 다음에 나오는 문의 값이 Promise가 아니면 해당 값을 resolved Promise로 변환시킵니다.
&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/await&quot;&gt;출처: MDN web docs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;즉, &lt;code class=&quot;language-text&quot;&gt;await&lt;/code&gt;의 결과 &lt;code class=&quot;language-text&quot;&gt;Promise.resolve()&lt;/code&gt;를 반환하여 &lt;code class=&quot;language-text&quot;&gt;pending&lt;/code&gt; 중인 &lt;code class=&quot;language-text&quot;&gt;Promise&lt;/code&gt;를 반환합니다.
이와 더불어 비동기의 특성상, 비동기의 호출순서가 비동기의 실행순서를 보장하지 않습니다.
우리의 미션의 경우 비동기와 동기 테스트를 작성한 순서에 맞게 호출할 필요가 있었습니다. &lt;/p&gt;
&lt;p&gt;저는 모든 함수를 비동기로 바꿔줄 경우 호출 순서에 이상이 생기는 것을 보고, 비동기 작업만을 &lt;code class=&quot;language-text&quot;&gt;async/await&lt;/code&gt;로 기다리고자 하였습니다.
이를 위하여 &lt;code class=&quot;language-text&quot;&gt;try-catch&lt;/code&gt;문 내에서 &lt;code class=&quot;language-text&quot;&gt;await&lt;/code&gt;를 사용하기 전에, 해당 함수의 호출이 &lt;code class=&quot;language-text&quot;&gt;Promise&lt;/code&gt;를 반환하는 값인지 확인 하였습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; tmp &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;cb&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;tmp &lt;span class=&quot;token keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Promise&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;tmp&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; tmp&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;[테스트 실패를 판별하기 위한 고민]&lt;/h3&gt;
&lt;p&gt;우리의 테스트 코드는 여러가지 assertion을 진행합니다.
이 assertion 중에서 어떤 부분에서 문제가 발생했는지 확인이 필요합니다.
예를 들어, 연산의 결과&lt;code class=&quot;language-text&quot;&gt;Success, Success, Fail&lt;/code&gt;이 발생 한경우, 이는  &lt;code class=&quot;language-text&quot;&gt;Fail&lt;/code&gt;을 반환해야 합니다. &lt;/p&gt;
&lt;p&gt;이를 구현하기 위해, 각 연산의 결과 실패시 에러를 호출 하였고, 이를 &lt;code class=&quot;language-text&quot;&gt;try-catch&lt;/code&gt;로 감싸 주었습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; assert &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function-variable function&quot;&gt;equal&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;args&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;args&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; args&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;Test Fail&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;
  
&lt;span class=&quot;token keyword&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; tmp &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;cb&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;tmp &lt;span class=&quot;token keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Promise&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;tmp&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; tmp&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;e&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;e&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;message &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Test Fail&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    result &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;RED&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;FAIL&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;RESET&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;[Jest 테스트 라이브러리]&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Jest는 JavaScript를 테스트하기 위한 Framework이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Jest는 다음과 같은 기능을 제공한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Test launchers&lt;/li&gt;
&lt;li&gt;Testing structure&lt;/li&gt;
&lt;li&gt;Assertion functions&lt;/li&gt;
&lt;li&gt;Generate and display test progress and results&lt;/li&gt;
&lt;li&gt;Mocks, spies, and stubs&lt;/li&gt;
&lt;li&gt;Generate and compare snapshots&lt;/li&gt;
&lt;li&gt;Generate code coverage&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;[Jest 라이브러리의 특징]&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;이 중 우리는 기본적인 Assertion functions를 구현하였다.
이외의 다양한 기능이 Jest에 존재하고, 이를 통하여 더 많은 방식의 테스트 기법 사용이 가능하다.
특히, 우리의 경우 Unit test에만 치우쳐 테스팅을 진행 하였는데,
위 도구를 사용하면 Integration testing, Functional testing(e2e)등 다양한 기법을 사용 가능하다. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;[Jest 라이브러리의 기능]&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;또한, 프런트 엔드를 개발할때 UI등에 대해 테스트를 작성하는것은 무척 고된 작업이다.
원하는 컴포넌트가 생성, 작동 하는지 확인하기위 airbnb에서 제작한 &lt;code class=&quot;language-text&quot;&gt;enzyme&lt;/code&gt; 을 주로 사용하는데,
이 경우 매번 테스트를 작성할때 컴포넌트의 구조에 대한 명시가 필요하다.
반면, jest의 snapshot과 같은 기능을 사용하면, 이에 대한 추가적인 작성 없이 동일한 결과(컴포넌트의 생성)이 기대되는지 여부를 쉽게 판별할 수 있다. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;[Jest 와 내 코드의 동작 방식 차이]&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;jest의 동작 방식과 나의(혹은 다른 부캠원)의 작동방식 중 가장 두드러지는 차이는,
jest는 모든 테스트를 실행한 뒤 결과를 정리해서 보여준다.(리포트와 같이)
반면, 우리의 코드는 하나의 테스트가 실행될때 마다 이에 대한 결과를 순차적으로 보여준다.
특히, 우리의 구현에서 js코드내에 비동기 코드가 있을경우, 이 비동기 작업에 대한 결과를 기다리고, 이에 따라 사용자 또한 다음 결과를 기다리는데
jest의 경우에는 한번에 완성된 보고서를 보여주니 더욱 이용이 편리하다.&lt;/p&gt;
&lt;h2&gt;챌린지 중 느낀것&lt;/h2&gt;
&lt;h3&gt;구조에 대한 고민&lt;/h3&gt;
&lt;p&gt;항상 문제가 주어지면, 그 문제를 해결하기 위한 자료의 구조를 정의하는게 필요하다. &lt;/p&gt;
&lt;p&gt;이 자료 구조가 초반에 잘못 정의되면, 후반에 굉장히 큰 고통으로 다가오곤 한다.&lt;/p&gt;
&lt;p&gt;우리가 작성하는 함수들은 범용적으로 설계 되는 것이 아니라 주어진 문제를 해결하기 위해 제작되곤 한다. &lt;/p&gt;
&lt;p&gt;우리가 함수를 통해 받아야 할 값들과 반환값의 형태가 어느정도 정해져 있고, 이에 따라 내부의 로직이 고정되곤 한다. 이에 따라, 들어오는 값이 변하게 되면 로직도 변해야 하기에 수정에 큰 비용이 든다. (당연한 말을 길게 풀어써 봤다ㅋ)&lt;/p&gt;
&lt;p&gt;튜토리얼등만 수행하였을 때는 데이터의 구조를 정의하는게 이리도 중요한지 몰랐다. &lt;/p&gt;
&lt;p&gt;어차피 접근해봐야 2 deep level정도로만 탐색하고, 반환할테니 맘편히 객체, 배열을 사용할 수 있었다. &lt;/p&gt;
&lt;p&gt;그러나, 오늘같이 배열과 객체가 같이 사용되면서 3층 이상 떨어지는 자료를 만들게 되면 이를 사용하는데 고민을 많이 해야한다. &lt;/p&gt;
&lt;p&gt;데이터를 단순히 mutable하게 하면 편하지만, 이것은 내가 원하는 방법이 아니다. &lt;/p&gt;
&lt;p&gt;가능한 모든 데이터의 흐름을 immutable하게 가져가기 위해 노력을 하다 보니 자료 구조가 복잡해질 수록 이에 대한 데이터 변환 비용이 기하급수적으로 귀찮아 지는것 같다. &lt;/p&gt;
&lt;p&gt;결론적으로 말해서, 내일부터는 사전에 모든 명세를 꼼꼼히 살펴보고 진행해야 겠다. &lt;/p&gt;
&lt;p&gt;원래 글을 잘 못 읽고, 이해가 느려 명세만 읽다보면 시간이 다 가버리곤 한다. 그래서 코딩 테스트같은 문제를 풀때도 일단 코드를 몇자 적어보고 시작하곤 하는데, 오늘은 너무 코드만 적었던것 같다. &lt;/p&gt;
&lt;h3&gt;로직의 분리의 중요성&lt;/h3&gt;
&lt;p&gt;오늘 Model과 Controller 를 분리하여 작성 해 봤다. &lt;/p&gt;
&lt;p&gt;controller에서도 간단히 처리 됨에도 저장소와 1이라도 연관이 있으면 model에 작성하려 노력했다. &lt;/p&gt;
&lt;p&gt;이렇게 코드를 작성하니 로직이 비교적 단순해 지고, 함수의 사용이 명확해져서 재사용이 용이했다. &lt;/p&gt;
&lt;p&gt;계속 이런식으로 학습해보자.&lt;/p&gt;
&lt;h3&gt;공부를 먼저 하고 했어야…&lt;/h3&gt;
&lt;p&gt;위에도 언급했지만, 오늘은 명세를 꼼꼼히 읽어보지 못했다. 어제와 더불어 오늘도 명세가 잘 읽히지 않고 이해가 가지 않아 코드 작성을 하며 이해하려 했다. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;그러나, 이 접근법은 크게 잘못 되었다는 것을 집을 오며 깨달았다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;결국 회사에서도 그렇지만, 어떻게 하라고 가이드 라인을 명확하게 주는 경우는 없다. &lt;/p&gt;
&lt;p&gt;항상 고민을 통해 내 스스로 가이드 라인을 만들어 가며 구현해야 하는데, 오늘의 경우에는 너무 과제 해결에만 집중했던 것 같다. 오늘 과제의 양이 많아서 제대로 보지 못했다는 것은 핑계다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;하나를 배우더라도 제대로 배워 보자는 나의 마음가짐은 어디를 갔는가…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;오늘은 하나도 제대로 학습하지 못했다. &lt;/p&gt;
&lt;p&gt;반성하고, 내일은 오늘과 같은 실수를 범하지 말자. &lt;/p&gt;
&lt;h3&gt;테스트의 부재&lt;/h3&gt;
&lt;p&gt;첫날 나의 다짐을 어겼다. &lt;/p&gt;
&lt;p&gt;코드 작성 중반쯤 되서야 내가 TDD나 기본적인 Test 코드를 작성하고 있지 않다는 것을 자각했다. &lt;/p&gt;
&lt;p&gt;코드 작성 초반에는 오히려 빨리빨리 되는 것 같았지만, 여러 부분에서 오히려 시간이 더디어 졌고, 결과적으로 낮은 품질의 소프트웨어와 더불어 미션을 완수하지 못했다. &lt;/p&gt;
&lt;p&gt;예를 들어, 오늘 나는 간단한 코드를 계속해서 콘솔에 타이핑을 하며 테스트 하였다. &lt;/p&gt;
&lt;p&gt;이는, 콘솔을 받는 함수와 별도로 테스트 환경을 통해 인위적으로 함수들을 호출하여 통합테스트를 진행할 수 있었던 부분이였다. &lt;/p&gt;
&lt;p&gt;또한 기본적으로 유닛 테스트도 작성 하지 않으니, 문제가 생겼을 때 이에 대한 수정이 번거롭고 흐름이 잘 이해되지 않았다. &lt;/p&gt;
&lt;p&gt;항상 그렇지만, &lt;/p&gt;
&lt;p&gt;복잡할수록 태스트가 필요하다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;테스트에서 타협을 보지 말자&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;또 한번 immutable 에 대한 고민&lt;/h3&gt;
&lt;p&gt;위에서 살짝 언급했지만, immutable에 대한 고민을 계속 했다. &lt;/p&gt;
&lt;p&gt;특히 OOP의 개념보다는 함수적 사고를 갖고 프로그램을 작성하려 노력했기 때문에, 순수 함수를 작성하고자 노력했다. &lt;/p&gt;
&lt;p&gt;그러나, 원 데이터에 손상을 주지 않고 데이터를 수정하여 적용하는 로직들에서 너무 큰 복잡함이 따라 왔다. &lt;/p&gt;
&lt;p&gt;예를 들어 다음 코드를 살펴 보자…&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; store &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;store&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;some_name &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; some_name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;copiedOutter&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      files&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;copiedOutter&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;files&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;some_other_name &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; cf&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;some_other_name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;cf&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
          status&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;in progress&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
          modified_at&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;기존의 &lt;code class=&quot;language-text&quot;&gt;store&lt;/code&gt; 를 손상시키지 않고 shallow copy를 통하여 새로운 값을 포함하는 객체(또는 배열)을 조합하는 방식으로 작성하였다. &lt;/p&gt;
&lt;p&gt;단순 무식한 방법으로 immutable을 구현하려 하였는데, 깊이가 2단계 이상으로 들어가니 로직이 너무 복잡해 졌다 . 이 또한 &lt;code class=&quot;language-text&quot;&gt;spread syntax&lt;/code&gt; 덕분에 이만큼 줄어 들었음에도 아주 더티하다..&lt;/p&gt;
&lt;p&gt;만약 내가 &lt;code class=&quot;language-text&quot;&gt;store&lt;/code&gt; 를 변형 시키고자 했다면 단순히 해당 프로퍼티에 접근해 값을 바꿔주면 끝났을 것이다. &lt;/p&gt;
&lt;p&gt;하지만, FP의 개념을 살리면서 이를 구현하자니 너무 복잡해 졌다. &lt;/p&gt;
&lt;p&gt;아직 간단한 방법은 찾지 못했다. (&lt;strong&gt;라이브러리 없이 !!!!&lt;/strong&gt;) &lt;/p&gt;
&lt;p&gt;이에 대한 고민을 더 해보고, immutablejs와 같은 도구를 한번 더 살펴봐야 겠다. &lt;/p&gt;
&lt;h2&gt;오전 시간에 느낀것&lt;/h2&gt;
&lt;h3&gt;Array 객체의 특징&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Array.prototype.length 는 읽기 전용이 아니다. 이 값을 덮어쓰면, 인스턴스가 변해버린다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; arr &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
arr &lt;span class=&quot;token comment&quot;&gt;// [empty * 5]&lt;/span&gt;
arr&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length &lt;span class=&quot;token comment&quot;&gt;// 5&lt;/span&gt;
arr&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;
arr &lt;span class=&quot;token comment&quot;&gt;// [empty * 3]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위처럼, 그냥 뒤의 값이 잘려 버린다. 조심하자. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Array는 new 키워드 없이도 생성이 가능하다&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Garbage Collection in JS&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;이 부분에 대한 책의 내용은 워낙 오래된 브라우저 기준이라 지금도 적용이 되는지 모르겠다.&lt;/li&gt;
&lt;li&gt;이 부분에 대한 나의 생각은 그냥 큰 고민없이 로직을 작성하면 어느정도 브라우저가 해결해 줄것이다…ㅎ&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;회고&lt;/h2&gt;
&lt;p&gt;오늘은 아쉬움이 많이 남는 날이다. &lt;/p&gt;
&lt;p&gt;내일은 더 발전되고 변한 나의 모습이면 좋겠다. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;하나를 배우더라도 제대로 배워 보자&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;테스트에서 타협을 보지 말자&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 챌린지 11일차]]></title><description><![CDATA[오전 시간에 느낀점 오늘은 일찍 와서 책을 보았다. 앞부분만 보고 끝까지 읽지 않았던 자바스크립트 노랑이를 읽었다. 이 책을 이번주 안에 1/4를 읽기로 마음을 먹고, 차근차근 책을 읽으니 좋은 내용이 참 많았다. 3.7.1 매개변수의 이해 ES…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-challenge/day-11/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-challenge/day-11/</guid><pubDate>Mon, 29 Jul 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;오전 시간에 느낀점&lt;/h2&gt;
&lt;p&gt;오늘은 일찍 와서 책을 보았다. 앞부분만 보고 끝까지 읽지 않았던 자바스크립트 노랑이를 읽었다.&lt;/p&gt;
&lt;p&gt;이 책을 이번주 안에 1/4를 읽기로 마음을 먹고, 차근차근 책을 읽으니 좋은 내용이 참 많았다.&lt;/p&gt;
&lt;h3&gt;3.7.1 매개변수의 이해&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ES에서 함수는 매개변수의 개수를 따지지 않고, 타입을 체크하지도 않는다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;매개변수는 내부적으로 배열로 표현된다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;배열로 표현되고, 배열처럼 동작하기는 하지만, &lt;code class=&quot;language-text&quot;&gt;Array&lt;/code&gt;의 인스턴스는 아니다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;매개변수에 명시적인 이름을 정하지 않고도 접근이 가능하다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이를 모방하여 오버로딩을 구현할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;매개변수와 &lt;code class=&quot;language-text&quot;&gt;arguments&lt;/code&gt;(접근자) 는 각각 다른 메모리 공간을 사용하지만, 값의 변화는 반영이 된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;그러나 이 반영은 단방향이여서 &lt;code class=&quot;language-text&quot;&gt;arguments&lt;/code&gt;를 변화시키면 해당 변수의 값도 변한다.&lt;/li&gt;
&lt;li&gt;그러나 반대는 변하지 않는다.&lt;/li&gt;
&lt;li&gt;또한 만약 매개변수를 넘기지 않았더라면, &lt;code class=&quot;language-text&quot;&gt;arguments&lt;/code&gt;를 변화준다고 하여도 해당 로컬 변수명을 통해 값에 접근할 수 있는것은 아니다.&lt;/li&gt;
&lt;li&gt;그 이유는, 함수 정의에서 정의한 매개변수의 길이를 따라서 &lt;code class=&quot;language-text&quot;&gt;arguments&lt;/code&gt; 배열을 생성하는게 아니라, 함수를 호출할 때 넘긴 이름 붙은 매개변수 목록을 따르기 때문이다.&lt;/li&gt;
&lt;li&gt;만약 ,정의한 매개변수를 넘기지 않으면 자동으로 &lt;code class=&quot;language-text&quot;&gt;undefined&lt;/code&gt; 가 할당되고, 변경 되지않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;3.7.2 오버로딩 없음&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;같은 이름을 갖은 함수를 여러번 정의하면, 마지막 함수가 해당 이름을 소유하게 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;값을 반환하지 않는 함수는 사실 undefined를 반환하는 것이다.&lt;/h3&gt;
&lt;h3&gt;4.1.1 동적 프로퍼티&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;원시값 vs 참조값으로 나뉜다.&lt;/li&gt;
&lt;li&gt;흥미롭게도 원시값에는 프로퍼티가 없지만(객체가 아니지만) 이를 추가하려 해도 에러가 생기진 않는다. 다만, 사용을 못할뿐&lt;/li&gt;
&lt;li&gt;동적으로 프로퍼티를 추가할 수 있는 값은 참조값 뿐이다&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;4.1.2 값 복사&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;원시값은 현재 저장된 값을 새로 생성한 다음 새로운 변수에 복사한다.&lt;/li&gt;
&lt;li&gt;즉, 서로의 값은 완전히 분리되어 있다.&lt;/li&gt;
&lt;li&gt;참조값 또한 다른 변수로 복사하면, 원래 변수에 들어있던 값이 다른 변수로 복사된다.&lt;/li&gt;
&lt;li&gt;차이는, 들어있던 값은 객체가 아니고 힙에 저장된 객체를 가리키는 포인터이며&lt;/li&gt;
&lt;li&gt;이 포인터가 복사 되는것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;4.1.3 매개변수 전달&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;함수의 매개변수는 모두 &lt;code class=&quot;language-text&quot;&gt;값&lt;/code&gt; 으로 전달된다.&lt;/li&gt;
&lt;li&gt;함수에 객체들을 매개변수로 전달할 때도, 이 객체를 가리키는 포인터가 복사되어 지역변수로서 작동하는 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;4.1.4 타입 판별&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;typeof&lt;/code&gt; 를 사용시에, string, number, boolean, undefined라면 정확한 타입을 알 수 있다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;하지만, null, object, array 등은 모두 &lt;code class=&quot;language-text&quot;&gt;object&lt;/code&gt;로 나온다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;특히 null이 primitive value임에도 &lt;code class=&quot;language-text&quot;&gt;object&lt;/code&gt; 로 나오는 것에 주의하자.&lt;/li&gt;
&lt;li&gt;이것은 초기 ES에 이렇게 명세되었기 때문이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;그러므로 해당 값이 객체인지 아닌지는 크게 중요치 않다.&lt;/li&gt;
&lt;li&gt;이 값이 어떤 타입의 객체인지 알아야 하며 이는 &lt;code class=&quot;language-text&quot;&gt;instanceof&lt;/code&gt; 로 알 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;챌린지 중 느낀것&lt;/h2&gt;
&lt;p&gt;문제가 무언가 이상하긴 했지만, 충분히 있을법한 가정이라 고민을 많이 하였다.&lt;/p&gt;
&lt;p&gt;일반적인 방법으로 접근 하였다면, 코드 자체에 변화를 주었겠지만, 오늘 미션의 경우 주어진 코드를 변화시키지 않고 문제를 해결해야 했기 때문에 고민을 많이 했다.&lt;/p&gt;
&lt;p&gt;결론을 말하자면, 일반적인 방법으로는 해결이 안되는것 같다.&lt;/p&gt;
&lt;p&gt;node를 통해서 process를 빼온뒤 따로 처리하던지&lt;/p&gt;
&lt;p&gt;인위적으로 모두를 timeout안에서 async를 주던지&lt;/p&gt;
&lt;p&gt;js를 파싱해서 앞뒤로 async를 주던지…&lt;/p&gt;
&lt;p&gt;순수한 vanila js로는 도저히 안되는것 같다.&lt;/p&gt;
&lt;p&gt;그래도 내가 혹시 모르는게 있어서 안보이는 것은 아닐까 하는 생각에 &lt;code class=&quot;language-text&quot;&gt;Promise&lt;/code&gt; 와 &lt;code class=&quot;language-text&quot;&gt;Generator&lt;/code&gt; 를 다시 한번 훑어볼 수 있는 기회가 되었다.&lt;/p&gt;
&lt;p&gt;특히, &lt;code class=&quot;language-text&quot;&gt;await&lt;/code&gt; 를 &lt;code class=&quot;language-text&quot;&gt;Promise&lt;/code&gt; 를 반환하지 않는 값을 할당하였을때, resolved된 Promise가 반환된다는 사실이 충격적으로 다가왔다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;오늘 공부한 내용중 &lt;code class=&quot;language-text&quot;&gt;Generator&lt;/code&gt; 부분은 양이 많으므로 추후에 따로 정리하도록 하겠다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;위 난해한 조건을 제외하고는 상대적으로 평이한 미션이였다.&lt;/p&gt;
&lt;h2&gt;회고&lt;/h2&gt;
&lt;p&gt;안다고 생각하더라도 꼼꼼하게 다시 보자.&lt;/p&gt;
&lt;p&gt;잘못 아는 것 만큼 위험한 건 없다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[ReactJS에서의 styled-jsx]]></title><description><![CDATA[programmers 에서 진행하는 react 스터디를 통해 styled-jsx를 접하게 되었다. 처음에는 개인적으로 문법을 사용하는 방법이 워낙 괴랄하여 거부감이 많이 들었다. 뭔가, 너무 react…]]></description><link>https://sukjae.github.io/daily-study/daily/2019-07-28/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/daily/2019-07-28/</guid><pubDate>Sun, 28 Jul 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;programmers 에서 진행하는 react 스터디를 통해 styled-jsx를 접하게 되었다.&lt;/p&gt;
&lt;p&gt;처음에는 개인적으로 문법을 사용하는 방법이 워낙 괴랄하여 거부감이 많이 들었다.&lt;/p&gt;
&lt;p&gt;뭔가, 너무 react 스럽지 않고 편법을 사용하는 느낌이였다.&lt;/p&gt;
&lt;p&gt;그러나 이 기술이 Next.js에 기본으로 포함되어 있고, 생각보다 많이 사용한다는 점에 놀라며 학습을 하였다.&lt;/p&gt;
&lt;h3&gt;기본 문법&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;p&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;only &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt; paragraph will &lt;span class=&quot;token keyword&quot;&gt;get&lt;/span&gt; the style &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;p&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;style jsx&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;
      p {
        color: red;
      }
    &lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;style&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;신기하게 위처럼 코드를 작성하면, 해당 컴포넌트 내부에 있는 &lt;code class=&quot;language-text&quot;&gt;p&lt;/code&gt; 태그에만 적용된다.&lt;/p&gt;
&lt;p&gt;이 &lt;code class=&quot;language-text&quot;&gt;style&lt;/code&gt; 은 기본적으로 해당 컴포넌트에만 적용 있고, 위 아래로 해당 스타일이 적용 되지 않는 특징이 있다.&lt;/p&gt;
&lt;p&gt;즉, 이 스타일은 해당 컴포넌트에 isolate 되어 독립된 스타일을 제공한다.&lt;/p&gt;
&lt;p&gt;어찌보면 이러한 스타일 방식은 React의 컴포넌트화를 통한 재사용성 증대와 독립성 증대를 따르는 모양세 인것 같다.&lt;/p&gt;
&lt;p&gt;문제는, 이러한 스타일 규칙이 해당 파일만의 규칙이 아닐 경우 생긴다.&lt;/p&gt;
&lt;p&gt;예를들어, 하나의 컴포넌트가 두개의 서로 다른 상황에서 사용될 경우 CSS의 특징상 별도의 상속 구조(선택자)를 선택해야 하는 경우가 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;css&quot;&gt;&lt;pre class=&quot;language-css&quot;&gt;&lt;code class=&quot;language-css&quot;&gt;&lt;span class=&quot;token selector&quot;&gt;.cs1 p&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; red&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token selector&quot;&gt;.cs2 p&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; blue&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이러한 상황에서, p태그는 해당 컴포넌트에 있지만, cs1과 cs2는 상위 컴포넌트에 포함되어 있다고 가정하자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;Ptag&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;p&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;Loo&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;p&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;style jsx&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;
      p {
        color: red;
      }
    &lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;style&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;Cs1&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;div className&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;cs1&apos;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
      &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Ptag&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;Cs2&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;div className&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;cs2&apos;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
      &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Ptag&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Ptag&lt;/code&gt; 의 입장에서, &lt;code class=&quot;language-text&quot;&gt;cs1&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;cs2&lt;/code&gt; 의 상황에 따라 &lt;code class=&quot;language-text&quot;&gt;p&lt;/code&gt; 태그에 다른 스타일을 적용해야 하는데 이에 대한 엘리멘트가 해당 컴포넌트에 없다.&lt;/p&gt;
&lt;p&gt;위에서 언급하였듯이 기본적으로 컴포넌트 속의 스타일은 그 컴포넌트에만 종속되고 고립된다.&lt;/p&gt;
&lt;p&gt;이 문제를 해결하기 위해서는 &lt;code class=&quot;language-text&quot;&gt;:global()&lt;/code&gt; 을 사용하면 된다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;:global()&lt;/code&gt; 은 해당 컴포넌트의 스코프를 벗어나 전역적으로 해당 요소를 찾는다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;Ptag&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;p&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;Loo&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;p&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;style jsx&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;
      :global(cs1) p {
        color: red;
      }
      :global(cs2) p {
        color: blue;
      }
    &lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;style&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;또한, 전역적으로 사용해야 할 태그가 있다면 다음과 같이 사용하고, 컴포넌트의 범위를 벗어나 적용된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;style jsx global&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;
      body {
        background: red;
      }
    &lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;style&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이 외에도 변수를 제공할 수 있고, SSR에서도 사용될 수 있으며, css preprocessor 등과 같이 사용이 가능하는 등 다양한 옵션들이 존재한다. 이는 추후에 따로 정리하도록 하겠다.&lt;/p&gt;
&lt;p&gt;결론적으로, styled-jsx 는 jsx를 스타일링할때 매우 도움이 됨을 느낄 수 있었다.&lt;/p&gt;
&lt;p&gt;기본적인 CSS문법을 그대로 활용하면 되므로 개발도 편하고, 퍼블리셔등과 작업할때 적용이 편할 것 같다 .&lt;/p&gt;</content:encoded></item><item><title><![CDATA[JS에서 Spread syntax는 shallow copy일까 deep copy 일까]]></title><description><![CDATA[어제 정리한 내용중에 immutable data pattern 이라는 부분이 있다. 여기서 정리 하였듯이, Primitive value를 제외한 모든 것이 mutable 하고, 이로 인한 사이드 이펙트를 방지하기 위해 copy…]]></description><link>https://sukjae.github.io/daily-study/daily/2019-07-27/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/daily/2019-07-27/</guid><pubDate>Sat, 27 Jul 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;어제 정리한 내용중에 immutable data pattern 이라는 부분이 있다.&lt;/p&gt;
&lt;p&gt;여기서 정리 하였듯이, Primitive value를 제외한 모든 것이 mutable 하고, 이로 인한 사이드 이펙트를 방지하기 위해 copy 를 만들어 값에 할당하는 방식을 취한다.&lt;/p&gt;
&lt;p&gt;다른분이 이에 대해 궁금해 하셔서 나는 js Spread syntax를 통해 shallow한 copy를 만들어 immutable data pattern을 모방하는 방법에 대해 설명했다.&lt;/p&gt;
&lt;p&gt;그러면서 다음과 같이 언급하며 내용을 시작하였다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;그래서 저는 다음과 같이 구현하였습니다.
- 주의 하셔야 할게, spread 로 copy하면 shallow가 맞습니다.
- 객체가 복잡해지면 deep copy할 전략이 필요합니다.
- 그러나, 이 todolist 라는 객체가 값만을 포함하고 있고,
- 변경 되는 부분을 매번 새로운 객체(혹은 배열)로 만들어 합쳐서 전달하고
- 항상 이 약속을 지키면 위의 mutable한 성질로 인해 값이 변형될 걱정을 많이 줄일 수 있는것 같습니다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그러나, 어떤분이 &lt;code class=&quot;language-text&quot;&gt;spread 로 copy하면 shallow가 맞습니다&lt;/code&gt; 라는 부분에 대해 다음과 같은 의문을 던지셨다.&lt;/p&gt;
&lt;h4&gt;다른분 A님의 의견&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;자바와 유사하게 프리미티브 밸류는 딥, 객체는 쉘로우 카피가 되는 것 같다. 그러므로 무조건 쉘로우 카피라고 말하는 것은 오해의 여지가 있을 것 같다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;나의 답변&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;자바스크립트에서는 object와 array가 spread 연산자를 사용할 수 있다. 둘 모두 js에서는 primitive value가 아니므로, Primitive value가 spread 로 deep 하게 copy 된다는 가정에 오류가 있는 것 같다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;이에 대한 다른분 A님의 답변&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;객체의 속성이 프리미티브 타입인 경우 딥카피가 된다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이에 대해 나는 추가적으로 언급하진 않았지만, 이 글에서 정리하려 한다.&lt;/p&gt;
&lt;p&gt;일단, 항상 이러한 논쟁은 단어에 대해 해석하고 있는 의미가 서로 다르기 때문에 나타나곤 한다.&lt;/p&gt;
&lt;p&gt;내 생각에 다른분 A님과 나는 Shallow copy와 Deep copy에 대해 다른 해석을 하고 있던것 같다.&lt;/p&gt;
&lt;p&gt;나는 다음 위키의 내용과 동일한 생각을 갖고 있다.&lt;/p&gt;
&lt;h3&gt;Shallow copy&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;aka field-by-field copy&lt;/li&gt;
&lt;li&gt;If the field value is a reference to an object (e.g., a memory address) it copies the reference, hence referring to the same object as A does, and if the field value is a primitive type it copies the value of the primitive type.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Deep copy&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;fields are dereferenced:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;즉, 다른분 A님이 말씀하신 &lt;code class=&quot;language-text&quot;&gt;객체의 속성이 프리미티브 타입인 경우&lt;/code&gt; 에 primitive를 지원하는 언어에서는 값(value) 이 복사되며, 이 또한 Shallow copy의 정의의 일부분이다.&lt;/p&gt;
&lt;p&gt;무조건 새로운 값이 복사된다고 Deep copy 되었다라고 해석하기에는 문제가 있다.&lt;/p&gt;
&lt;p&gt;결국, 우리가 관심 있어야 할 것은 어떠한 메소드의(여기에선 spread syntax) 결과가 항상 deep copy를 제공하는 가에 대한 여부이다.&lt;/p&gt;
&lt;p&gt;JS의 Spread syntax는 Shallow copy를 제공한다.&lt;/p&gt;
&lt;h2&gt;JS에서 Spread syntax는 언제부터 등장했을까?&lt;/h2&gt;
&lt;p&gt;ES2018부터 정식으로 등장할 예정이다.&lt;/p&gt;
&lt;p&gt;그러나 우리가 Reactjs등을 하며 너무나도 자연스럽게 사용할 수 있는 이유에는 Node lts 버전들이 이미 spread syntax를 지원해주기 때문이다. (땡큐 노드!)&lt;/p&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 챌린지 10일차]]></title><description><![CDATA[피어 세션 중 느낀것 옵저버 패턴의 장점 하나의 이벤트에 대해서 다수의 서로 다른 액션이 가능하다. 이 과정에서, 이벤트를 방생시키는 주체와, 이벤트를 소비하는 대상이 서로 디커플링이 되어 종속을 최소화할 수 있다. immutable value Js…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-challenge/day-10/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-challenge/day-10/</guid><pubDate>Fri, 26 Jul 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;피어 세션 중 느낀것&lt;/h2&gt;
&lt;h3&gt;옵저버 패턴의 장점&lt;/h3&gt;
&lt;p&gt;하나의 이벤트에 대해서 다수의 서로 다른 액션이 가능하다. 이 과정에서, 이벤트를 방생시키는 주체와, 이벤트를 소비하는 대상이 서로 디커플링이 되어 종속을 최소화할 수 있다.&lt;/p&gt;
&lt;h3&gt;immutable value&lt;/h3&gt;
&lt;p&gt;Js에서 원시값은 불변값이다.&lt;/p&gt;
&lt;p&gt;쉽게 생각하여 원시값 이외의 모든것은 object이고.&lt;/p&gt;
&lt;p&gt;이는 &lt;code class=&quot;language-text&quot;&gt;typeof []&lt;/code&gt; 을 해보면 알 수 있다.&lt;/p&gt;
&lt;p&gt;이러한 원시값에는 다음과 같은 것들이 포함된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Boolean&lt;/li&gt;
&lt;li&gt;null&lt;/li&gt;
&lt;li&gt;undefined&lt;/li&gt;
&lt;li&gt;Number&lt;/li&gt;
&lt;li&gt;String&lt;/li&gt;
&lt;li&gt;Symbol&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;immutable data pattern&lt;/h3&gt;
&lt;p&gt;위에도 언급하였지만, 원시함수를 제외한 모든 것들은 객체이다. 객체는 js에서 기본적으로 레퍼렌스로 접근하여 그 값에 변화를 줄 수 있고, 가변성을 띈다는 것은 자명하다.&lt;/p&gt;
&lt;p&gt;예를들어 array나 object를 생각해보자.&lt;/p&gt;
&lt;p&gt;이렇게 가변성의 성질을 방지하기 위해, 의도적으로 배열이나 객체에 대한 defensive copy 를 만들어 작업하는 방법이다.&lt;/p&gt;
&lt;p&gt;쉽게 말하여, 그냥 복사본을 만들어 작업하는게 immutable data pattern이다.&lt;/p&gt;
&lt;p&gt;그러나, 매번 복사를 하는게 너무 많은 코스트가 든다면, freeze하여 불변으로 만드는 방법도 있다.&lt;/p&gt;
&lt;p&gt;그러나 이 패턴에 대해 오해 하는 경우가 있다.&lt;/p&gt;
&lt;p&gt;예를 들어, 내 변수에는 {a:1}이 있었는데, {a:2}가 되면 변수에 할당된 값이 변했으니 불변이 아닌것 아니야?&lt;/p&gt;
&lt;p&gt;→ 이에 대한 나의 생각은 이러하다.&lt;/p&gt;
&lt;p&gt;데이터에 변화를 주는것은 필수적이다. 그러나 이 데이터의 변화가 우리가 의도한것인지, 의도하지 않은것인지가 중요한것 같다.&lt;/p&gt;
&lt;p&gt;우리는 일련의 트랜잭션 혹은 작업에서 데이터를 가지고 놀다가 최종적인 데이터를 저장한다.&lt;/p&gt;
&lt;p&gt;위에서 말한 불변성이란,&lt;/p&gt;
&lt;p&gt;시작부터 데이터 저장 바로 전까지, 실제 데이터에 어떠한 변화도 이르켜선 안된다는 말로 받아드리면 될것 같다.&lt;/p&gt;
&lt;h2&gt;금요일 프로젝트 중 느낀것&lt;/h2&gt;
&lt;h3&gt;프로젝트 운영의 만족도&lt;/h3&gt;
&lt;p&gt;금요일 프로젝트에 대해 많이 걱정을 하였다. 아무래도 8명이라는 많은 인원이 새로 모여 코드를 짜고, 가지고 있는 코드 스텍도 모두 상이하기 때문이다.&lt;/p&gt;
&lt;p&gt;고민을 하던 중, 나는 욕심을 버려야 한다는 것을 느꼈다. 지금까지, 팀 프로젝트나 해커톤과 같은 팀 프로젝트를 진행하면, 항상 너무 많은 기획, 오버엔지니어링 등이 문제가 되어 시간내에 끝내지 못했다.&lt;/p&gt;
&lt;p&gt;그래서 이번에는 구현에 제일 집중을 하고, 기술 스택이나 복잡한 부가적인 기능들을 고려하지 않았다.&lt;/p&gt;
&lt;p&gt;나는 최종적으로 아무런 라이브러리를 사용하지 않고,&lt;/p&gt;
&lt;p&gt;HTML, 순수 CSS, 순수 자바스크립트(바닐라JS, web api사용)이렇게 딱 3개의 파일만으로 구현하는것을 목표로 하였다.&lt;/p&gt;
&lt;p&gt;복잡하게 하면, npm 같은 패키지 매니지 툴을 써서 sass, less 등이나 웹팩등으로 멋찌게 구현할 수 있겠지만, 일단 모두의 기술스택과 수준을 짐작할 수 없기에 핵심에만 집중하기로 하였다.&lt;/p&gt;
&lt;p&gt;다행히, 팀원 모두가 이 생각에 동의를 하였고 가장 기본적인 형태로 프로젝트를 진행할 수 있었다.&lt;/p&gt;
&lt;p&gt;또 감사했던 부분이, 기획이 너무 잘 구성 되어 있었다. 우리가 작업해야 할 분류가 명확했고, 정의가 명확했다.&lt;/p&gt;
&lt;p&gt;그래서 우리는 4가지 기능 구현에 집중하여 4팀으로 나누어 2명씩 페어프로그래밍을 하였다.&lt;/p&gt;
&lt;h3&gt;페어프로그래밍&lt;/h3&gt;
&lt;p&gt;페어 프로그래밍을 시도한 이유는, 모두의 기술 수준을 모르기 떄문이다.&lt;/p&gt;
&lt;p&gt;항상 여러 팀 프로젝트를하면, 결국엔 욕심이 많고 실력이 뛰어난 한두명이 대부분의 작업을 하게 된다.&lt;/p&gt;
&lt;p&gt;나는 그렇게 하기보다, 간단하더라도 모두가 기여할 수 있고, 배울 수 있는 기회를 갖길 원했다.&lt;/p&gt;
&lt;p&gt;그래서 페어프로그래밍을 시도하였다. 다른 분들은 어떻게 하셨는지 모르지만, 나와 나의 파트너님은 어느정도 페어프로그래밍에 맞춰 작업을 진행한것 같다.&lt;/p&gt;
&lt;p&gt;내가 네비게이터가 되고, 파트너님이 드라이버가 되어 서로의 지식을 공유하며 코드를 작성할 수 있었다.&lt;/p&gt;
&lt;p&gt;기능구현이 간단하여 내가 드라이버가 될 기회는 없었지만, 서로 기능 구현에 대해 고민하며 집중적으로 코드를 작성할 수 있었다.&lt;/p&gt;
&lt;p&gt;다음에도 기회가 된다면 짝 프로그래밍을 해보고 싶다.&lt;/p&gt;
&lt;h2&gt;추가적으로 마스터님께 질문한 부분들&lt;/h2&gt;
&lt;h3&gt;타입스크립트가 타입을 강제하여 자바스크립트의 장점을 상쇄시킨다는 얘기가 많다 .현업, 그리고 마스터님은 어떻게 생각하시나&lt;/h3&gt;
&lt;p&gt;상황에 따라 다르겠지만, 큰 프로젝트에서는 이점이 많이 보이고, 최근 많은 기업들이 도입을 시도하고 있다.&lt;/p&gt;
&lt;h3&gt;경력직 개발자가 이직시에 코딩테스트 준비를 하는가&lt;/h3&gt;
&lt;p&gt;개발자라도 이직전에 2~3달 공부를 한다.&lt;/p&gt;
&lt;h3&gt;지난주까지의 미션의 난이도는 어느정도인지&lt;/h3&gt;
&lt;p&gt;중이다. 원래 기획하길 점진적으로 상승시키려 하였다&lt;/p&gt;
&lt;h2&gt;회고&lt;/h2&gt;
&lt;p&gt;만족스러운 작업이였다. 남들보다 더 많은 결과물을 낸것은 아니지만, 주어진 과제를 효율적으로 해결할 수 있었다.&lt;/p&gt;
&lt;p&gt;또 많은것을 배우고 가는 하루다. 내일도 새로운 배움이 있기를 바란다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 챌린지 9일차]]></title><description><![CDATA[…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-challenge/day-9/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-challenge/day-9/</guid><pubDate>Thu, 25 Jul 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;피어 세션 중 느낀것&lt;/h2&gt;
&lt;h3&gt;셀 스크립트가 필요한 이유&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;다수의 반복되는 명령어를 하나의 스크립트 파일에 넣어 실행하여, 개발자의 수고를 덜어준다.&lt;/li&gt;
&lt;li&gt;다수의 반복되는 명령어를 수기로 입력시, 실수로 인하여 명령어를 잘못 입력할 수 있는데, 이를 코드로 관리 한다면 실수를 방지할 수 있다.&lt;/li&gt;
&lt;li&gt;스크립트로 사용가능한 다양한 언어들이 있는데 (예를 들어 파이썬, js 등), 이와 달리 셀 스크립트로 작성 시 셀에서 부가적인 도구 설치 없이 바로 사용이 가능하다는 장점이 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;타입스크립트가 필요한 이유&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;자바스크립트의 특성상 타입을 강하게 제한하지 않는다. 따라서 동적으로 타입이 변형되기도 하고, 이는 개발자가 원치 않은 결과로 이어지기도 한다.&lt;/li&gt;
&lt;li&gt;사용될 수 있는 타입을 정의함으로서 원치 않은 결과를 방지하고, 통일된 규격을 맞춰 여러명이 함께 코딩을할 수 있다.&lt;/li&gt;
&lt;li&gt;또한, 타입체크를 코드 작성시 실시간으로 진행하게 되면, 컴파일시 발생할 수 있는 문제들을 사전에 어느정도 방지가 가능하며 동시에 안내에 따라 타입에 대해 큰 신경 없이 코드를 작성할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;챌린지 중 느낀것&lt;/h2&gt;
&lt;p&gt;오늘은 OOP에 대해 집중적으로 학습하였다.&lt;/p&gt;
&lt;p&gt;OOP개념을 다시 돌아보기엔 부족한 시간이기에 구현하기 급급하였지만,&lt;/p&gt;
&lt;p&gt;지난번에 FP로 작성하였던 코드를 다시 한번 OOP로 구현할 수 있는 좋은 기회였다.&lt;/p&gt;
&lt;p&gt;특히 옵저버 패턴에 대해 간단하기 구현할 수 있었던 점이 굉장히 도움이 되었다.&lt;/p&gt;
&lt;p&gt;또한, 지난번과 다른 자료구조를 택함으로서 로직이 훨씬 깔끔해졌다.&lt;/p&gt;
&lt;h3&gt;Observable&lt;/h3&gt;
&lt;p&gt;아직 Observable 을 제대로 이해한것은 아니다, 그러나 하나의 인스턴스를 서로 공유하면서 함수를 호출할 수 있다는 점이 새롭게 다가왔다.&lt;/p&gt;
&lt;p&gt;Observable 을 구현함에 있어서 subject와 observer를 기존의 코드와 최대한 분리하려 고민을 하였다.&lt;/p&gt;
&lt;p&gt;클래스에 subjet클래스를 상속받아서 구현하고, observer를 리스너가 위치한 코드에서 생성한 뒤 리스너가 위치한 코드에서 subject의 메소드를 호출하여 구현하였다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 이렇게 constructor 안에 메소드를 넣을 필요가 없었다.&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; Subject &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;observers &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;subscribeObserver&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;observer&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;observers&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;observer&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;notifyAllObservers&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;observers&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;observers&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;runFunc&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 옵져버 == 리스너&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; Observer &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 여기선, 하나의 함수만 연결할 수 있다.&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 여기에 Observer에서 구현한 코드를 그대로 넣어도 똑같이 작동 했겠지만,&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 코드 내에 다른 공간에서도 이와 같은 옵져버를 사용할 수 있도록 분리 하였다.&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 즉, subject --- observer(==exe)를&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// subject --- observer --- exe 로 삼등분 한 느낌이다&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;runFunc &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; func
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

module&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;exports &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  Subject&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  Observer&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// Subject 부분, 옵저버가 주시해야 할 코드의 위치. 여기서 시그널을 발생시킴.&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; Subject &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;./Observable&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;someFunc&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;subscribeObserver&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;observer1&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;someAction&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;notifyAllObservers&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; subject &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Subject&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
someFunc&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Object&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;subject&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
someFunc&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;constructor &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; someFunc&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// Observer 부분. 시그널이 반영될 코드&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; Observer &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;./Observable&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; someClass &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;someFunc&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;someAction&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;// 옵저버가 시그널을 발생시키면 실행되어야 할 코드.&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 실행해야 할 코드를 옵져버에 넣어 인스턴스를 생성한다.&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 이제 이 옵져버는 위 함수를 복사하여 갖고있다.(__proto__로 연결한건 아닌것 같다.)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; observer &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Observer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;someAction&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token comment&quot;&gt;// someFunc는 넘겨받은 인스턴스이다.&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 위에서 someFunc에 prototype으로 Subject의 인스턴스인 subject를 연결 하였다.&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 이를 통해서 우리는 someFunc.__proto__.subscribeObserver() 로 접근이 가능한것 같다.&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 생각해보면, 객체를 인자로 넘길때는 레퍼렌스 참조와 같이 원래의 객체가 넘어오므로, 이 인스턴스&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 또한 위해서 만들어진 인스턴스 그 자체인듯 하다.&lt;/span&gt;
    someFunc&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;subscribeObserver&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;observer&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Node에서 http.get 부분…&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;http.get&lt;/code&gt; 은 &lt;code class=&quot;language-text&quot;&gt;axios&lt;/code&gt; 나 &lt;code class=&quot;language-text&quot;&gt;fetch&lt;/code&gt; 처럼 친절하지 않다.&lt;/p&gt;
&lt;p&gt;request를 보내고, response를 받을때 받은 response는 buffer의 형태로 흐르듯 날라온다.&lt;/p&gt;
&lt;p&gt;어찌보면 http의 통신이 사실 그러하기 때문에 당연한 현상이지만, 직관적으로는 결과값은 최종값이여야 할것같다. 쉽게 사용하려면 &lt;code class=&quot;language-text&quot;&gt;axios&lt;/code&gt; 등을 사용하고, &lt;code class=&quot;language-text&quot;&gt;http.get&lt;/code&gt; 으로 간단하게 구현 하려면 다음과 같이 하면 된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; options &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  hostname&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;localhost&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  port&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;8090&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  path&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;/api&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
http
  &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;options&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; body &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&quot;&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 여기서 on data 이벤트가 발생하는 동안 계속해서 buffer로 날라온다.&lt;/span&gt;
    res&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;data&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;chunk&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      body &lt;span class=&quot;token operator&quot;&gt;+=&lt;/span&gt; chunk
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 여기서 on end 이벤트가 발생하는 순간,&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 우리는 모든 response가 왔다 파악하고, 그 다음 액션을 취하면 된다.&lt;/span&gt;
    res&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;end&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;// 이제 body에는 모든 buffer가 쌓여서 하나의 데이터 뭉치가 되었다.&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;// 이를 바로 사용하면 된다.&lt;/span&gt;
      console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;todolist&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;error&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;Error: &lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;e&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;message&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;소통의 중요성&lt;/h3&gt;
&lt;p&gt;자바스크립트에 &lt;code class=&quot;language-text&quot;&gt;Class&lt;/code&gt; 는 그저 신택틱 슈거에 불가하고, 이를 기존의 함수로 구현할 수 있는것을 안다. 따라서 챌린지 미션에서 클래스에 대한 안내가 명확하지 않아 초반에 잘못된 구현을 하였다.&lt;/p&gt;
&lt;p&gt;미션에는 다음과 같은 내용이 포함되어 있었다. &lt;code class=&quot;language-text&quot;&gt;ES Classes 형태로 구현해야 한다.&lt;/code&gt; , &lt;code class=&quot;language-text&quot;&gt;ES6 Classes 패턴을 사용할 수 없으며&lt;/code&gt; , &lt;code class=&quot;language-text&quot;&gt;ES Classes문법으로 구현한다&lt;/code&gt; , &lt;code class=&quot;language-text&quot;&gt;ES Classes를 사용&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;그냥 단순히 생각하면 클래스를 사용 하라는 것과 사용하지 말라는 두개로 보일 수 있다. 그런데 자세히 보면 위 내용은 다른 의미를 내포할 수 있다.&lt;/p&gt;
&lt;p&gt;예를 들어, &lt;code class=&quot;language-text&quot;&gt;Classess 형태로 구현&lt;/code&gt; 이라는 부분은 &lt;code class=&quot;language-text&quot;&gt;class&lt;/code&gt; 가 제공하는 기능을 모방하여 구현 하라고 해석될 수 있다. 즉, &lt;code class=&quot;language-text&quot;&gt;class 키워드&lt;/code&gt; 를 사용하지 말고 &lt;code class=&quot;language-text&quot;&gt;class 기능을 구현 하라&lt;/code&gt; 로 볼 수 있다. &lt;code class=&quot;language-text&quot;&gt;패턴&lt;/code&gt; 도 같은 맥락에서 해석이 가능하다.&lt;/p&gt;
&lt;p&gt;또한, &lt;code class=&quot;language-text&quot;&gt;Classes 문법&lt;/code&gt; 와 &lt;code class=&quot;language-text&quot;&gt;Classes&lt;/code&gt; 는 &lt;code class=&quot;language-text&quot;&gt;class 키워드&lt;/code&gt; 를 사용하라로 표현될 수 있다.&lt;/p&gt;
&lt;p&gt;이렇듯, 단어 선택이 매우 중요함을 알 수 있다. 실제 협업을 진행할 때도 서로간의 오해가 없도록 자주 소통하는 습관을 가져야 겠다.&lt;/p&gt;
&lt;h2&gt;회고&lt;/h2&gt;
&lt;h3&gt;잘못한 부분&lt;/h3&gt;
&lt;p&gt;집에 돌아와 잘못 생각한 부분들이 있었는데, 그중 가장 큰 부분은 contructer 에 method를 넣었다는 점이였다. 그냥 메소드로 구현하고, constructer안에서 this를 바인딩 해주면 될 부분을 거추장 스럽게 작성한것 같아 아쉽다.&lt;/p&gt;
&lt;h3&gt;만족스러운 부분&lt;/h3&gt;
&lt;p&gt;오늘 한것중에 만족스러운 부분은, 구현을 함에 있어 불필요한 부부을 많이 제외했다는 점이다.&lt;/p&gt;
&lt;p&gt;예를 들어, 일전에는 JSON 파일을 입출력시 계속해서 덮어쓰었다. 이번에는 단순히 로컬 메모리에 올려서 프로그램을 수해하였다. 파일을 작성하는 코드가 메인 코드에서 사라지니 로직이 깔끔해졌다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 챌린지 8일차]]></title><description><![CDATA[피어 세션 중 느낀것 Immutable vs mutable immutable…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-challenge/day-8/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-challenge/day-8/</guid><pubDate>Wed, 24 Jul 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;피어 세션 중 느낀것&lt;/h2&gt;
&lt;h3&gt;Immutable vs mutable&lt;/h3&gt;
&lt;p&gt;immutable를 염두에 두고 설계를 하면, 내부 상태를 원치 않는 상황에서 변화시킬 걱정을 하지 않고 코드를 작성할 수 있다. 우리가 내부의 상태를 변화시킬 때는, 우리가 원하는 상황에서만, 원하는 도구로만 변화를 시킬 수 있어야 한다.&lt;/p&gt;
&lt;p&gt;이와 같은 기법은 협업을 하며 코드를 작성할 때 큰 도움이 된다. 데이터가 흐르면서 계속해서 상태를 변화 시키다면, 이후에 해당 코드를 활용하거나 수정할 때 그 흐름을 파악하기 어렵고, 약간의 변화가 큰 오류를 만들어 낸다 .&lt;/p&gt;
&lt;h3&gt;함수만으로 구현하는데 어떤 장점과 단점이 존재하는가 ?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;장점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;동시성 처리에 강점이 있다.&lt;/li&gt;
&lt;li&gt;코드가 간결해 진다.&lt;/li&gt;
&lt;li&gt;사이드 이펙트를 크게 고려하지 않아도 된다.&lt;/li&gt;
&lt;li&gt;유닛 테스트를 작성하기 편하다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;단점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Data Consistency를 보장하기 위해 복잡함을 수반한다.&lt;/li&gt;
&lt;li&gt;간결한 코드를 읽기 위해서 학습이 필요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;챌린지 중 느낀것&lt;/h2&gt;
&lt;h3&gt;Docker&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://hub.docker.com/_/ubuntu&quot;&gt;docker hub에서 오피셜 docker ubuntu image&lt;/a&gt;로 container를 생성하였다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.docker.com/sites/default/files/Docker_CheatSheet_08.09.2016_0.pdf&quot;&gt;docker cheatsheet가 있으니 참고하자&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이렇게 생성해준 도커를 포트를 열고 이름을 지정해주는게 일반적이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;docker run -dit -p 1200:22 -p 1100:80 --name boostcamp1 ubuntu:18.02&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이렇게 run시켜준것은 stop을 한뒤 rm 하여 삭제 가능하다.&lt;/p&gt;
&lt;p&gt;현재 활성화된 도커에 접속하기 위해 &lt;code class=&quot;language-text&quot;&gt;run&lt;/code&gt; 을 사용한다면, 새로운 컨테이너가 생길 뿐이니 주의하자.&lt;/p&gt;
&lt;p&gt;활성화된 도커 (&lt;code class=&quot;language-text&quot;&gt;docker ps&lt;/code&gt; 로 확인 후 )에 접속하기 위해서는 다음과 같은 코드를 사용하면 된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;docker attach boostcamp1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;설치는 간편 하였지만, 너무 컴팩트한 이미지를 다운받아서 그런지 기본적인 &lt;code class=&quot;language-text&quot;&gt;sudo&lt;/code&gt; 도 설치되어 있지 않아 추가 해 줘야 했다 .&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;apt-get update &amp;amp;&amp;amp; apt-get install -y sudo &amp;amp;&amp;amp; rm -rf /var/lib/apt/lists/*&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이제 apt-get도 최신버전이고, sudo도 설치 되었으니, 외부에서 ssh 연결을 하기 위한 프로그램을 설치해 주었다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;apt-get install openssh-server&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;근데 문제는 또 nano와 같은 편집기도 설치되어 있지 않더라. 그래서 설치했다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;apt-get install nano&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 openssh-server에는 루트계정의 로그인을 받아야 하는데 다음과 같이 설정할 수 있었다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;nano /etc/ssh/sshd_config

...
PermitRootLogin yes 로 지정
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이렇게 설치된 ssh 프로그램을 세가지 중요한 커맨드를 활용할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;service ssh start # ssh 시작하기
service ssh stop # ssh 종료하기
service ssh status # ssh 활성 상태 조회&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;start가 안되있으면 외부에서 ssh 연결이 안되는 것은 당연하다.&lt;/p&gt;
&lt;p&gt;이렇게 설정을한 뒤 주소와 포트를 확인하여 다음과 같이 접속이 가능하다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;ssh -p 1200 root@localhost&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;아래와 같이 scp 를 통한 복사도 가능하다. (이유는 모르겠지만, scp에서는 -p가 대문자 -P이다!)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;scp -P 1200 ./backup/backup_${DATE}.zip lee@localhost:~/backup&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;근데 위 방법은 password를 요구하는데, 보통 ssh-key를 활용한다는 것을 염두에 두자.&lt;/p&gt;
&lt;p&gt;마지막으로, 도커가 활성화된 상태에서 추가적으로 포트를 바꿔주거나 설정을 바꿔줘야 하는 상황이 발생할 때 다음과 같은 방법을 사용할 수 있다. 일반적으로 생각할 수 있는것은, 도커를 죽이고 새로 생성(run)하는 방법인데, 다음과 같은 방법을 사용한다면 현재 도커 상태 그대로(유저 포함) 복+붙이 가능하다 .&lt;a href=&quot;https://stackoverflow.com/a/26622041&quot;&gt;[설명 링크]&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/engine/reference/commandline/stop/&quot;&gt;stop&lt;/a&gt; running container&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;docker stop test01&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/engine/reference/commandline/commit/&quot;&gt;commit&lt;/a&gt; the container&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;docker commit test01 test02&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; The above, &lt;code class=&quot;language-text&quot;&gt;test02&lt;/code&gt; is a new image that I’m constructing from the &lt;code class=&quot;language-text&quot;&gt;test01&lt;/code&gt; container.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;re-&lt;a href=&quot;https://docs.docker.com/engine/reference/commandline/run/&quot;&gt;run&lt;/a&gt; from the commited image&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;docker run -p 8080:8080 -td test02&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;sudo&lt;/code&gt; 를 설치해준 뒤 필요에 따라 유저를 생성할 수 있다.&lt;/p&gt;
&lt;p&gt;이번 기회에 도커의 다양한 커맨드를 잘 활용할 수 있었다.&lt;/p&gt;
&lt;p&gt;그러나, 이렇게 도커를 이미지로 받아서 하나하나 셋팅하기 보단 스크립트를 작성해서 자동화 해야 한다는 것을 안다. 이제 사용법에 익숙해 졌으니, 다음부터는 스크립트를 작성하도록 하겠다.&lt;/p&gt;
&lt;h3&gt;shell scripting&lt;/h3&gt;
&lt;p&gt;존재는 알고 있었지만, 직접 구현한적도 문법을 본적도 없는 것 이여서 너무나 생소했다.&lt;/p&gt;
&lt;p&gt;그냥 파이썬으로 되겠구나 싶었지만 이를 위한 언어와 문법이 존재 하더라.&lt;/p&gt;
&lt;p&gt;또, 파이썬이나 노드로 구현하면 해당 os에서 해당 언어를 위한 도구를 설치해줘야 하고, 속도의 문제도 있는것 같다. 생소하지만, shell scripting으로 작성해 보았다.&lt;/p&gt;
&lt;p&gt;결국 쉘 스크립팅은 우리가 터미널에 작성하는 커맨드들의 연장선 이더라. 우리가 자주 쓰는 커맨드의 뭉탱이를 그냥 쉘 스크립트에 기술해 놔도 순차적으로 잘 수행된다.&lt;/p&gt;
&lt;p&gt;순회를 하는것, 변수를 할당하는것 등 많은 신기한 작성법이 있었다.&lt;/p&gt;
&lt;p&gt;문법이 약간 뭐라할까… 동적이긴 한데 너무 스트릭한 부분도 있다. 특히 변수를 셋팅하고 값을 넣어줄 때 &lt;code class=&quot;language-text&quot;&gt;=&lt;/code&gt;가 변수명 바로 뒤에 붙어야 한다는게 신기했다. 이게 띄어쓰기가 들어가면 오류가 난다.&lt;/p&gt;
&lt;p&gt;또, &lt;code class=&quot;language-text&quot;&gt;${}&lt;/code&gt; 를 string에 넣으면서 다이나믹하게 string을 생성하는것은 뭔가 모던한거 같았다 .&lt;/p&gt;
&lt;p&gt;또 array도 지원하여 신기하였다.&lt;/p&gt;
&lt;p&gt;string으로 처리되는것 같아 신기했다. 결국에 우리가 입력하는것도 string이니, 이 string의 조합을 잘 만들어서 무언가 액션을 취하는 것 같다 .&lt;/p&gt;
&lt;p&gt;현재 나의 의문은, 많은 cli 도구가 유저에게 인풋을 받고, 다양한 부가 기능을 &lt;code class=&quot;language-text&quot;&gt;-&lt;/code&gt;나 &lt;code class=&quot;language-text&quot;&gt;--&lt;/code&gt; 등으로 받는데 이러한 장치들을 쉽게 만들 수 있는 프레임 워크가 없을까 라는 생각이 든다.&lt;/p&gt;
&lt;p&gt;추가적인 학습을 위해 좋은 자료를 기록한다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikibooks.org/wiki/Bash_Shell_Scripting&quot;&gt;Bash shell scripting wikibooks&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;bash가 무엇인지부터 스크립팅이 무엇인지 상세히 기술되어있다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://linuxconfig.org/bash-scripting-tutorial-for-beginners&quot;&gt;Bash scripting for beginners&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GIF와 같은 사진이 포함되어 있어 설명을 이해하기 쉽다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://codeburst.io/your-perfect-kickstart-to-shell-scripting-857b81c0939b&quot;&gt;Your perfect kickstart to shell scripting&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;정말 쉽게 안내되어 있다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://google.github.io/styleguide/shell.xml&quot;&gt;shell scripting design guide by Google&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;구글에서 여러 언어에 대해 디자인 가이드를 만들어 놓은 것 같은데, 그중 쉘 스타일도 있다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/a/1951523&quot;&gt;shell scripting array 사용법&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/a/20983251&quot;&gt;shell scripting에 색 입히기&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;추가적으로, cheat.sh&lt;/h3&gt;
&lt;p&gt;또, 다른 참가자 분이 공유해주신 꿀팁을 이용하여 다양한 예제를 손쉽게 활용할 수 있는 법도 배웠다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;curl cheat.sh/command_name&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://cheat.sh/&quot;&gt;cheat.sh&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이를 활용하면, 손쉽게 해당 커맨드의 활용 예시를 파악할 수 있다.!&lt;/p&gt;
&lt;h2&gt;회고&lt;/h2&gt;
&lt;p&gt;오늘은 주변에 많은 분들이 도커와 과제에 대해 물어봐 주셔서 뿌듯한 하루였다 .&lt;/p&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 챌린지 7일차]]></title><description><![CDATA[피어 세션 어제 작성한 코드를 돌아보며 두가지 부분에 대한 생각을 추가로 정리하였다.  를 구현 하면서  에 접근 하기위한 3가지 방법  를 다른 변수에 넣기  해주기 arrow function…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-challenge/day-7/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-challenge/day-7/</guid><pubDate>Tue, 23 Jul 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;피어 세션&lt;/h2&gt;
&lt;p&gt;어제 작성한 코드를 돌아보며 두가지 부분에 대한 생각을 추가로 정리하였다.&lt;/p&gt;
&lt;h3&gt;&lt;code class=&quot;language-text&quot;&gt;bindMembers&lt;/code&gt; 를 구현 하면서 &lt;code class=&quot;language-text&quot;&gt;this.msg&lt;/code&gt; 에 접근 하기위한 3가지 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt; 를 다른 변수에 넣기&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript=&quot;&gt;&lt;pre class=&quot;language-javascript=&quot;&gt;&lt;code class=&quot;language-javascript=&quot;&gt;const Checker = class {
    ...
    bindMembers(names) {
        const that = this
        return function (source) {
         ... // 여기서 that으로 that.msg 접근 가능&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;bind&lt;/code&gt; 해주기&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript=&quot;&gt;&lt;pre class=&quot;language-javascript=&quot;&gt;&lt;code class=&quot;language-javascript=&quot;&gt;const Checker = class {
    ...
    bindMembers(targets) {
    return checkMember.bind(this);
    function checkMember(source) {
    				... // 여기서 this으로 this.msg 접근 가능&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;arrow function를 사용하여 기능을 구현하고 &lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt;와 같은 위치 &lt;code class=&quot;language-text&quot;&gt;constructor&lt;/code&gt; 에 넣어주기&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript=&quot;&gt;&lt;pre class=&quot;language-javascript=&quot;&gt;&lt;code class=&quot;language-javascript=&quot;&gt;const Checker = class {
    constructor(msg) {
      this.msg = msg;
      this.bindMembers = () =&amp;gt; ... // 여기서 this으로 this.msg 접근 가능&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;code class=&quot;language-text&quot;&gt;lodash&lt;/code&gt; 로 부터 필요한 메소드만 불러와서 사용하기&lt;/h3&gt;
&lt;p&gt;챌린지 미션에서 사용된 &lt;code class=&quot;language-text&quot;&gt;lodash&lt;/code&gt; 메소드는 &lt;code class=&quot;language-text&quot;&gt;every&lt;/code&gt; 하나뿐 이였다.&lt;/p&gt;
&lt;p&gt;이를 위해 &lt;code class=&quot;language-text&quot;&gt;lodash&lt;/code&gt; 의 모든 메소드를 불러오는 것은 불필요 하기 때문에 한가지 메소드 (&lt;code class=&quot;language-text&quot;&gt;every&lt;/code&gt; 만 불러오게 하였다.) 최종적으로 번들 사이즈를 줄일 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;기존 코드&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript=&quot;&gt;&lt;pre class=&quot;language-javascript=&quot;&gt;&lt;code class=&quot;language-javascript=&quot;&gt;const _ = require(&amp;quot;lodash&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;수정된 코드&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript=&quot;&gt;&lt;pre class=&quot;language-javascript=&quot;&gt;&lt;code class=&quot;language-javascript=&quot;&gt;const _every = require(&amp;quot;lodash/every&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;챌린지 중 느낀것&lt;/h2&gt;
&lt;p&gt;오늘은 주어진 미션을 따라 스켈레톤 &amp;#x26; 수도코드 작성하며 디자인을 먼저하고 개발을 진행하였다.&lt;/p&gt;
&lt;p&gt;이번에는 간단한 함수 구현이 아닌 실제 돌아가는 프로그램을 제작하였는데, 나는 이를 최대한 함수형으로 작성하려 노력했다.&lt;/p&gt;
&lt;p&gt;또한 코드를 작성함에 있어 TDD를 접목하고자 시도하였다.&lt;/p&gt;
&lt;h3&gt;스켈레톤&lt;/h3&gt;
&lt;p&gt;스켈레톤을 처음 작성해 봐서 그런지 생각을 정리하는데 어려움이 많았고, 후에 구현된 코드는 스켈레톤 코드와 큰 차이가 생겼다. 스켈레톤을 작성하며 기능을 나누고, 어떤 관계를 갖을지 고민하는게 어려웠던 것 같다.&lt;/p&gt;
&lt;h3&gt;TDD&lt;/h3&gt;
&lt;p&gt;오늘은 TDD와 Test code에 대한 장점을 잘 느긴것 같다&lt;/p&gt;
&lt;p&gt;이를 구현하기 위해 시간은 굉장히 많이 소요 되었고, 나중에는 시간이 부족하여 모든 부분을 TDD로 구현 하지는 못했지만, 그 위력을 느끼기에 충분한 시간이였다.&lt;/p&gt;
&lt;p&gt;오늘 나는 6시가 다 되어서 내 코드에 설계적 오류가 있음을 발견하였다 .&lt;/p&gt;
&lt;p&gt;하나하나 유닛테스트를 작성해 가며 큰 문제 없이 기능들을 작성하였지만,&lt;/p&gt;
&lt;p&gt;이 기능들이 한데 모이는 테스트 코드를 작성하며 이 문제를 발견하였다.&lt;/p&gt;
&lt;p&gt;(어떻게 보면 통합 테스트 중에 문제를 찾은것 같다.)&lt;/p&gt;
&lt;p&gt;내가 가졌던 설계 미스는 아주 바보 같은 실수였는데, 문제는 코드를 작성하며 가장 작은 기능만을 생성하니 이 문제가 쉽게 보이지 않았다는 점이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;json&quot;&gt;&lt;pre class=&quot;language-json&quot;&gt;&lt;code class=&quot;language-json&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token property&quot;&gt;&quot;todo&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token property&quot;&gt;&quot;type&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;todo&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token property&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;someId&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token property&quot;&gt;&quot;title&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;someTitle&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token property&quot;&gt;&quot;tags&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;[someTag]&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 코드와 같이 todo라는 key값으로 value를 array로 포함 하는데, 그 array 안의 각각의 객체들이 다시 한번 type으로서 동일한 정보를 가져버렸다.&lt;/p&gt;
&lt;p&gt;기능을 구현하면서 위 부분을 객체속의 type만 고민하며 코드를 작성 하였는데, 나중에 보니 리스트에서 추가 삭제 이동 하는 기능이 필요해서 멘붕이 왔다. 어찌보면 모든 로직을 다시 짜야 할 수 있는 상황임에도 불구하고, Test코드 덕분에 문제를 나름 수월하게 해결할 수 있었다.&lt;/p&gt;
&lt;p&gt;다행히 나에겐 테스트가 있었고, &lt;code class=&quot;language-text&quot;&gt;yarn test --watchAll&lt;/code&gt; 를 참조하며 실시간으로 코드에서 변화시켜야 할 부분을 수정해 갈 수 있었다. 테스트 덕분에 어떤 부분들이 오류가 있고, 어떤 기대값을 갖는지 체크해가면서 방향을 잡을 수 있었다 .&lt;/p&gt;
&lt;p&gt;이와 같이 틀린길로 가거나 내가 생각지 못한 이슈가 터질때 테스트는 큰 힘을 발휘하는것 같다. 테스트와 함께하면 복잡한 문제도 큰 어려움 없이 차근차근 헤쳐갈 수 있다&lt;/p&gt;
&lt;p&gt;TDD는 에러를 수정할때도 큰 힘을 발휘햇지만 처음 코드를 작성 할때도 많은 도움이 되었다. 기능별로 새분화하여 하나씩 초록불을 만들어 가다 보니, 나중에는 하나의 통합 기능이 완성되어 이를 잘 활용할 수 잇었다. 각각의 기능이 제 역할을 제대로 잘 수행 하므로, 이 기능을 사용하여 다른 기능을 구현할 때 먼저 구현한 기능이 오류가 있을 여지가 확실히 줄었던 것 같다.&lt;/p&gt;
&lt;p&gt;TDD로 구현을 하면 복잡한 로직을 머릿속에 다 넣고 있지 않더라도 차근차근 기능을 구현해갈 수 있는것 같다. 이 덕분에 멘붕에 빠지지 않았던 것 같다.&lt;/p&gt;
&lt;h3&gt;함수형 코드&lt;/h3&gt;
&lt;p&gt;이번에 나는 코드를 최대한 함수형으로 작성하려 노력햇다. 물론 후반에 시간이 없어 많이 꼬이긴 했지만, 함수형의 장점을 많이 느낄 수 있었다.&lt;/p&gt;
&lt;p&gt;이전 시간에 수행했던 단순한 기능을 만드는 과제에서 넘어가 여러 기능들이 통합되는 작업물을 만드니, 확실히 함수형으로 작성하는게 큰 도움이 되었다.&lt;/p&gt;
&lt;p&gt;특히 순수 함수로서 사이드 이펙트 없이 데이터를 핸들링 한다는 점 덕분에 코드를 술술 짤 수 있었다.&lt;/p&gt;
&lt;p&gt;항상 새로운 객체, 배열을 반환하고 기존의 데이터를 치환하는 형태로 코드를 작성하니, 기능들이 서로 디커플링이 잘 되고 사용이 편리 하였다.&lt;/p&gt;
&lt;p&gt;특히, 문제가 생겻을 때 문제가 되는 함수만을 찾아 수정 할 수 있고, 이 수정이 다른 곳에 미칠 영향을 크게 생각 안하고 수정할 수 있다는 점이 굉장히 편리했다.&lt;/p&gt;
&lt;p&gt;물론, 내가 작성한 코드들이 최적화가 되었거나, 효율적이진 못하다. 매 순간 데이터를 복사하여 치환해야 하기 때문에 자연스레 로드가 많이 들 수 있다. 이는 더 수정을 하여 발전시켜야 할 부분이다.&lt;/p&gt;
&lt;h2&gt;회고&lt;/h2&gt;
&lt;p&gt;오늘도 정신없는 하루 였다. 아쉬운 점이 있다면, 어느샌가 코드 구현에 급급하여 글을 잘 읽으려 하지 않는 나의 모습이 보였다는 것이다.&lt;/p&gt;
&lt;p&gt;항상 생각하며 코드를 작성하도록 노력하자.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 챌린지 6일차]]></title><description><![CDATA[…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-challenge/day-6/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-challenge/day-6/</guid><pubDate>Mon, 22 Jul 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;주간 자기 회고 시간 중 느낀것&lt;/h2&gt;
&lt;p&gt;오늘은 오전 시간에 캠프에대한 설문 및 회고시간을 가졌다.&lt;/p&gt;
&lt;p&gt;매일매일 기록과 회고를 한 덕분에 오래 생각할 필요는 없었고, 캠프에 대한 설문 작성 위주로 시간을 할애하였다.&lt;/p&gt;
&lt;p&gt;그리고, 오전 후반 시간에는 주변 이들과 회고에 대한 공유를 하는 시간이 있었는데, 다들 이번 캠프 를 통해 많이 성장하고 있다는게 느껴졌다. 나 또한 짧은 기간이지만 큰 성장을 하였던거 같아 만족스럽다.&lt;/p&gt;
&lt;p&gt;나의 경우에는 지난 일주일 동안 테스트, 타입스크립트, linter 등 내가 평소에 잘 사용하지 않았던 기술들을 많이 활용할 수 있었다.&lt;/p&gt;
&lt;p&gt;또한, 코드를 완성한 뒤 리펙토링을 하는데 많은 시간을 할애할 수 있었고, 코드를 작성하는 기술이 많이 늘어난것 같다.&lt;/p&gt;
&lt;p&gt;더불어 코드를 간결하게 작성하고, 함수형 프로그래밍을 사용하는데 주요한 함수들을 잘 활용할 수 있게 된것 같다.&lt;/p&gt;
&lt;h2&gt;챌린지 중 느낀것&lt;/h2&gt;
&lt;h3&gt;디버깅&lt;/h3&gt;
&lt;p&gt;오늘은 월요일이라 여유를 갖고 챌린지에 임했다. 낮잠도 자면서, 천천히 코드를 작성하였다.&lt;/p&gt;
&lt;p&gt;오늘은 디버깅과 관련한 주제가 주어졌고, 코드를 수정하는 과제가 나왔는데 생각보다 많은것을 배울 여지를 준 과제였다.&lt;/p&gt;
&lt;p&gt;처음에 과제를 받았을 때는 단순히 코드를 수정하는 것인줄 알고 얕 보았지만, 과제를 조금 더 깊이 들어가니 실제 작업중에 자주 생길만한 문제들이 많이 보였고 generator와 같은 자주 사용하지 않던 기능을 조금 더 이해할 수 있었다.&lt;/p&gt;
&lt;p&gt;이번 기회를 통하여 VScode와 Debug 기능에 대해 명확하게 알 수 있었는데, 특히 다른 참가자 분께서 디버깅을 하는 경우 함수의 끝에 breakpoint 를 넣으면 내장 함수를 들어가지 않고 variable들을 볼 수 있다는 점을 알려주셔서 많은 도움이 되었다.&lt;/p&gt;
&lt;p&gt;코드를 그대로 남길 수 없어 자세한 사고 과정은 서술할 수 없지만, 내가 문제를 해결하며 주요하게 고민하였던 부분들에 대해 언급하겠다.&lt;/p&gt;
&lt;p&gt;나는 디버깅을 할때 두가지 부분에 대해 유의하며 진행했다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;내 코드 자체에 오류가 있을 경우(SyntaxError, TypeError 등)&lt;/li&gt;
&lt;li&gt;내 코드에 오류는 없지만, 로직이 잘못되어 원하는 결과가 나오지 않는경우&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1번 문제의 경우에는 vscode의 linter를 설치하여 사용할 수 있고, 디버그 모드로 들어가 순회하며 오류를 찾을 수 있다.&lt;/p&gt;
&lt;p&gt;2번의 경우에는 디버깅 모드로 들어가 함수 전후로 Variables에 할당된 값을 비교 분석하여 체크한다.&lt;/p&gt;
&lt;p&gt;즉, 내가 지금 갖고 있는 문제가 코드 자체가 잘못 되었는지, 로직이 잘못 되었는지를 잘 고민하여야 한다.&lt;/p&gt;
&lt;p&gt;만약 로직이 잘못 되었는데, 코드의 오류를 찾는 것은 무의미하다. 차라리 디버깅 모드에서 코드를 빠르게 넘겨가며 내가 원하는 값들이 원하는 순간에 원하는 곳에 할당되어 있는지 파악하는게 옳다.&lt;/p&gt;
&lt;p&gt;예를 들어, 다음과 같이 type 혹은 syntax 등의 코드에 대한 에러일때는 수정해야 할 부분이 명확해 진다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;  TypeError&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; a&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Checker is not a constructor
      at Object&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;anonymous&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;  Exception has occurred&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; SyntaxError
  SyntaxError&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; Identifier &lt;span class=&quot;token string&quot;&gt;&apos;msg&apos;&lt;/span&gt; has already been declared&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;테스트&lt;/h3&gt;
&lt;p&gt;반면, 테스트는 잘 작성할 수 없었다. 이 부분은 다른 분들의 코드를 파악하며 학습해야 겠다.&lt;/p&gt;
&lt;p&gt;특히 generator와 같이 호출하는 횟수에 따라 반환값이 달라지는 경우는 어떻게 테스트를 해야 하는지 감이 오지 않았다 .&lt;/p&gt;
&lt;p&gt;또한 함수들끼리 서로 왔다 갔다 하며 연결고리가 복잡하게 얽혀 있는 경우에도 테스트를 어떻게 진해해야 할지 감이 오지 않았다.&lt;/p&gt;
&lt;p&gt;만약 이 코드를 TDD로 작성하려 한다 해도 어떻게 해야 할지 모르겠다.&lt;/p&gt;
&lt;p&gt;이 부분들은 주말에 다시 한번 더 고민해봐야 겠다.&lt;/p&gt;
&lt;h2&gt;회고&lt;/h2&gt;
&lt;p&gt;여유를 부리면 안되지만 여유를 부린 하루였다.&lt;/p&gt;
&lt;p&gt;열차가 지나가는 모습이 보이는 자리에 앉아 느긋하게 코딩하는 하루였다 .&lt;/p&gt;</content:encoded></item><item><title><![CDATA[prototype과 __proto__에 대한 간단한 생각 정리]]></title><description><![CDATA[은 함수(function)에만 기본적으로 내장된다.  ?? 함수를 제외한 다른 자료형 (ex, array, object, number, etc…]]></description><link>https://sukjae.github.io/daily-study/daily/2019-07-21/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/daily/2019-07-21/</guid><pubDate>Sun, 21 Jul 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;&lt;code class=&quot;language-text&quot;&gt;.prototype&lt;/code&gt; 은 함수(function)에만 기본적으로 내장된다.&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; obj &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
obj&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype &lt;span class=&quot;token comment&quot;&gt;// undefined&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
func&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype &lt;span class=&quot;token comment&quot;&gt;// {constructor: ƒ}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;code class=&quot;language-text&quot;&gt;.__proto__&lt;/code&gt; ??&lt;/h3&gt;
&lt;p&gt;함수를 제외한 다른 자료형 (ex, array, object, number, etc)에서는 &lt;code class=&quot;language-text&quot;&gt;.prototype&lt;/code&gt; 은 기본적으로 없다. 그러나 모든 기본 자료형에 &lt;code class=&quot;language-text&quot;&gt;__proto__&lt;/code&gt; 는 존재한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; obj &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
obj&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;__proto__ &lt;span class=&quot;token comment&quot;&gt;// {constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;code class=&quot;language-text&quot;&gt;.__proto__&lt;/code&gt; 안에 &lt;code class=&quot;language-text&quot;&gt;constructor&lt;/code&gt; 가 왜 있을까&lt;/h3&gt;
&lt;p&gt;위 코드에서 &lt;code class=&quot;language-text&quot;&gt;.__proto__&lt;/code&gt; 의 반환값은 객체이다. 그리고 이 객체안에 &lt;code class=&quot;language-text&quot;&gt;constructor&lt;/code&gt; 가 존재한다.&lt;/p&gt;
&lt;p&gt;그런데 이 &lt;code class=&quot;language-text&quot;&gt;constructor&lt;/code&gt; 은 함수 자료형에서만 기본적으로 &lt;code class=&quot;language-text&quot;&gt;prototype&lt;/code&gt; 에 내장되어 있는 프로퍼티 인데, 왜 함수 자료형이 아닌 보통의 객체에 포함되어 있는 것일까?&lt;/p&gt;
&lt;p&gt;그 이유는, 결국 obj 또한 기본 자료형이자 최상위에 존재하는 &lt;code class=&quot;language-text&quot;&gt;Object&lt;/code&gt; 를 통해 만들어지기 때문이다.&lt;/p&gt;
&lt;p&gt;즉, 위에서 객체 리터럴로 생성된 &lt;code class=&quot;language-text&quot;&gt;obj&lt;/code&gt; 는 &lt;code class=&quot;language-text&quot;&gt;Object&lt;/code&gt; 를 통해 만들어진 인스턴스 이고, 그로 인해 &lt;code class=&quot;language-text&quot;&gt;Object&lt;/code&gt; 가 가졌던 여러 기능들과 &lt;code class=&quot;language-text&quot;&gt;constructor&lt;/code&gt; 를 내포하고 있는 것이다.&lt;/p&gt;
&lt;p&gt;그리고, JS에서는 모든 것들이 객체로 표현되면서 동시에 함수와 연관을 갖고 있는데, 사실 &lt;code class=&quot;language-text&quot;&gt;Object&lt;/code&gt; 또한 함수일 뿐이다.&lt;/p&gt;
&lt;p&gt;이는 우리가 &lt;code class=&quot;language-text&quot;&gt;Object&lt;/code&gt; 를 사용할때, &lt;code class=&quot;language-text&quot;&gt;new&lt;/code&gt; 키워드를 사용함을 통해 유추할 수 있는데, 맞다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;new&lt;/code&gt; 키워드는 함수이기에 사용할 수 있는 것이고, 다음과 같이 알아볼 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;Object &lt;span class=&quot;token comment&quot;&gt;// ƒ Object() { [native code] }&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// {}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// {}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 결과에서 유추하듯, &lt;code class=&quot;language-text&quot;&gt;Object&lt;/code&gt; 는 함수로 구현되어 있으며, 객체를 반환하고 생성할 수 있는 함수이다.&lt;/p&gt;
&lt;h3&gt;그래서 &lt;code class=&quot;language-text&quot;&gt;.__proto__&lt;/code&gt; 와 &lt;code class=&quot;language-text&quot;&gt;.prototype&lt;/code&gt; 이 시사하는 바는 무엇일까?&lt;/h3&gt;
&lt;p&gt;내가 내린 가장 심플한 결론은, 함수(&lt;code class=&quot;language-text&quot;&gt;Foo&lt;/code&gt; 라고 하자)를 통해 &lt;code class=&quot;language-text&quot;&gt;.prototype&lt;/code&gt; 이 생성되고, 이와 동시에 &lt;code class=&quot;language-text&quot;&gt;.prototype.constructor&lt;/code&gt; 가 생성된다.&lt;/p&gt;
&lt;p&gt;이 &lt;code class=&quot;language-text&quot;&gt;.prototype&lt;/code&gt; 에 다른 프로퍼티를 연결 하면, 위 함수 &lt;code class=&quot;language-text&quot;&gt;Foo&lt;/code&gt; 를 통해 생성될 인스턴스(혹은 객체, 여기선 &lt;code class=&quot;language-text&quot;&gt;bar&lt;/code&gt; 라고 하자) 들은 위 기능을 &lt;code class=&quot;language-text&quot;&gt;.__proto__&lt;/code&gt; 의 구성 요소로서 참조하게 되고, 결국에는 &lt;code class=&quot;language-text&quot;&gt;Foo&lt;/code&gt; 가 갖고 있는 &lt;code class=&quot;language-text&quot;&gt;prototype&lt;/code&gt; 으로 연결된 기능 혹은 값들을 &lt;code class=&quot;language-text&quot;&gt;bar&lt;/code&gt; 가 자신의 &lt;code class=&quot;language-text&quot;&gt;__proto__&lt;/code&gt; 를 거쳐 사용할 수 있는 것이다.&lt;/p&gt;
&lt;p&gt;그렇다면, 우리가 사용하는 기본 자료형을 포함해서 모든 것들이 &lt;code class=&quot;language-text&quot;&gt;__proto__&lt;/code&gt; 를 포함하고 있는데, 이는 무엇을 시사하는 것일까?&lt;/p&gt;
&lt;p&gt;내 생각에는 앞서 말햇듯이 JS는 모든것을 함수로서 구현 하였기 때문에, 해당 기본 자료형으로 만들어진 무언가(객체, 숫자, 변수 등등)은 모두 그 위의 함수(혹은 클래스?같은)의 기능을 &lt;code class=&quot;language-text&quot;&gt;__proto__&lt;/code&gt; 로서 제공 받은 것 이다.&lt;/p&gt;
&lt;p&gt;따라서, 우리가 거의 모든 자료형에서 &lt;code class=&quot;language-text&quot;&gt;toString()&lt;/code&gt; 함수를 사용할 수 있는 것도 위와 같은 맥락으로, 상위 함수 어딘가에서 &lt;code class=&quot;language-text&quot;&gt;.prototype&lt;/code&gt; 으로 정의되었던 &lt;code class=&quot;language-text&quot;&gt;toString()&lt;/code&gt; 함수를 구현체? 들이 사용할 수 있는 것이다. 그리고 이 &lt;code class=&quot;language-text&quot;&gt;toString()&lt;/code&gt; 은 현재 사용하는 값의 &lt;code class=&quot;language-text&quot;&gt;__proto__&lt;/code&gt; 로 연결 되는 것이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;__proto__ &lt;span class=&quot;token comment&quot;&gt;// &quot;1,2,3&quot; //[constructor: ƒ, concat: ƒ,...toString: ƒ, ...]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[Js에서 composition over inheritance가 뜻 하는게 무엇일까]]></title><description><![CDATA[공부 이유 ReactJS 문서에도 composition over inheritance…]]></description><link>https://sukjae.github.io/daily-study/daily/2019-07-20/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/daily/2019-07-20/</guid><pubDate>Sat, 20 Jul 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;공부 이유&lt;/h2&gt;
&lt;p&gt;ReactJS 문서에도 composition over inheritance를 선호한다는 말이 나와있다.&lt;/p&gt;
&lt;p&gt;나도 이 부분에 대해 느낌으로는 알고 있었으나, 어떻게 다른지 명확하게 알지 못해 찾아보았고, 아직 알아보는 중이다.&lt;/p&gt;
&lt;p&gt;지금까지 찾아본 내용을 작성하며 미래에 이번 기록이 잘못됨을 깨달으면 수정하고자 한다.&lt;/p&gt;
&lt;h2&gt;공부 내용&lt;/h2&gt;
&lt;p&gt;일단, 내가 JS에서 갖고 있던 composition과 inheritance에 대한 생각을 간단히 언급하려 한다.&lt;/p&gt;
&lt;p&gt;composition:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;수평적으로 기능(메소드)별로 이어 붙여 연결하는 방식.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;inheritance:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;맥가이버 칼을 만들어서 한번에 공유 하듯이, 많은 기능의 뭉치를 수직적으로 연결하는 방식&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;내 생각이 맞는지 확인하기 위해 다른 이들의 생각을 찾아 보았다.&lt;/p&gt;
&lt;p&gt;일단 위키에서 둘을 비교한 글을 적어 보겠다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Composition over inheritance (or composite reuse principle) in object-oriented programming (OOP) is the principle that classes should achieve polymorphic behavior and code reuse by their composition (by containing instances of other classes that implement the desired functionality) rather than inheritance from a base or parent class.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;출처: [Composition over inheritance](&lt;a href=&quot;https://en.wikipedia.org/wiki/Composition&quot;&gt;https://en.wikipedia.org/wiki/Composition&lt;/a&gt;&lt;/em&gt;over&lt;em&gt;inheritance)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;위의 뜻을 직역하면,&lt;/p&gt;
&lt;p&gt;oop에서 composition over inheritance가 의미 하는 바는 클래스가 다른 클래스(혹은 부모 클래스)로 부터 기능을 상속 받는게 아니라 다형성을 가져야 하고, 합성을 통해 코드를 재사용해야 한다.&lt;/p&gt;
&lt;p&gt;여기서 합성(composition)이란 다른 클래스의 인스턴스를 포함 함으로서 원하는 기능을 구현 하는 것을 말한다.&lt;/p&gt;
&lt;p&gt;또 &lt;a href=&quot;https://stackoverflow.com/a/8696786&quot;&gt;StackOverflow의 어떤 이의 설명&lt;/a&gt; 을 포함시켜 보겠다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The language is irrelevant when dealing with composition vs inheritance.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;composition vs inheritance을 논할때 언어를 따지는 것은 부적절하다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Composition is simply when a class is composed of other classes; or to say it another way, an instance of an object has references to instances of other objects.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Composition은 쉽게 말하여 클래스가 다른 클래스로 합성 되었을때를 뜻한다.&lt;/p&gt;
&lt;p&gt;다시 말해, 객체의 인스턴스가 다른 객체의 인스턴스를 &lt;strong&gt;참조(references)&lt;/strong&gt; 할 때를 의미한다.&lt;/p&gt;
&lt;p&gt;자바스크립트에서는 클래스가 없다.(없었다 라는 표현이 맞지만, 일단 이렇게 작성한다. 현재는 class가 있긴 하니깐.)&lt;/p&gt;
&lt;p&gt;그렇지만 prototype을 통해 inheritance 를 구현한다. (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance&quot;&gt;MDN의 Inheritance in JavaScript&lt;/a&gt;)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;hi&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
hi&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;greeting&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;또한, JS에서는 function과 생성자를 통하여 인스턴스를 만들 수 있다는 것이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;hi&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; ins &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;hi&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그러므로, 위 설명글에서 클래스를 JS에서는 함수로 봐도 무방 할듯 하다. (단지 프로토타입이라는 개념으로 클래스와는 다르게 구현되었을 뿐이다.)&lt;/p&gt;
&lt;h2&gt;다음에 알아봐야 할 부분&lt;/h2&gt;
&lt;p&gt;아직 차이가 명확하지 않다.&lt;/p&gt;
&lt;p&gt;단지 이어붙이는 방식 이기 때문에 합성이라는 표현을 쓴다면,&lt;/p&gt;
&lt;p&gt;prototype을 통해 기능을 하나하나 이어 붙이는 방식과(==상속) 무엇이 다를까&lt;/p&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 챌린지 5일차]]></title><description><![CDATA[…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-challenge/day-5/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-challenge/day-5/</guid><pubDate>Fri, 19 Jul 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;피어 세션 중 느낀것&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;문제에 맞딱드렸을땐, 정의한 가정에 오류가 있을 수 있음을 인식하자&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;어제 작성한 코드중, 개선의 여지가 있음을 알게 되었다.&lt;/p&gt;
&lt;p&gt;구체적으로 언급하면 다음과 같은 코드였는데, 이 코드를 줄일 수 있는 가장 핵심적인 방법은 처음 내린 가정을 수정하는 것 이였다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;원래 작성한 코드&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;someFuncA&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;b&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;c&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;someFuncB&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;b&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;c&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;someWrapper&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;args&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;someFuncA&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;someFuncB&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;innerFunc&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;acc&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; cur&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; i&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;acc&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;slice&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; i&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    																		&lt;span class=&quot;token function&quot;&gt;someFuncA&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;cur&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; acc&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    																		&lt;span class=&quot;token function&quot;&gt;someFuncB&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;cur&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; acc&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;outerFunc&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;&lt;span class=&quot;token constant&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;B&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;reduce&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;innerFunc&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 코드에서 보면, &lt;code class=&quot;language-text&quot;&gt;someWrapper&lt;/code&gt; 에서 &lt;code class=&quot;language-text&quot;&gt;.C&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;.S&lt;/code&gt;를 분리할 방법을 찾지 못하여 함수를 분리하여 사용했다.&lt;/p&gt;
&lt;p&gt;어떻게 하면 반환값에 필요한 모든 정보를 변수없이 넣을 수 있을지 고민하였고, 그 결과로 나온 형태는 다음과 같았다. (다음 코드로 가는 과정은 [&lt;a href=&quot;https://github.com/sukjae/daily-study/blob/master/boost-camp/day-4.md&quot;&gt;부스트캠프 4일차 챌린지중 느낀것&lt;/a&gt;] 을 참조 바란다)&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;[...acc.slice(0, i),someFuncA(cur, B[i], acc[i]),someFuncB(cur, B[i], acc[i])]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;여기서 눈 여겨 봐야 할 점이, 어차피 &lt;code class=&quot;language-text&quot;&gt;[S,C]&lt;/code&gt; 순서로 만들어 진다는 것이다.&lt;/p&gt;
&lt;p&gt;나는 &lt;code class=&quot;language-text&quot;&gt;someWrapper&lt;/code&gt; 함수가 두가지 정보를 내포 하고 있고, 그 정보는 각자 내포하는 의미가 다르므로&lt;/p&gt;
&lt;p&gt;하나의 함수에 대한 하나의 반환값으로 표현하기 위해서는 객체로 표현함이 옳다고 생각했다. &lt;strong&gt;(나의 가정)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;이를 배열로 표현하지 않은 이유는, 배열은 두 값이 서로 index로만 분리되어 있어, 사실상 같은 의미를 갖는 값들을 제공할때만 사용해야 한다 생각했다.&lt;/p&gt;
&lt;p&gt;그러나, 피어세션중 다른 한 분이 객체가 배열로 표현하는것을 제안하셨고, 코드를 돌이켜 보니 충분히 가능한 방법이였다. 나는 내가 세웠던 가정이 불변의 규칙이라 생각하고, 이를 수정할 생각을 전혀 못하였는데, 내 반환값에 대한 구조를 다시 보니 다음과 같았다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;[...prev, someFuncA(),someFuncB(),someFuncA(),someFuncB(),someFuncA(),...]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;즉, 어차피 같은 순서로 배열로 반환되게 된다.&lt;/p&gt;
&lt;p&gt;즉, 나는 &lt;code class=&quot;language-text&quot;&gt;.C&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;.S&lt;/code&gt; 값이 완전 독립적인 의미를 갖는다 생각하였지만, 사실은 두 값은 하나의 고통된 의미를 갖는 것이였다.&lt;/p&gt;
&lt;p&gt;따라서 나의 코드를 다음과 바꾸니 훨씬 깔끔 해 졌다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;최종 개선 코드&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;someFuncA&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;b&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;c&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;someFuncB&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;b&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;c&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 반환값을 배열로 변환&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;someWrapper&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;args&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;someFuncA&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;someFuncB&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;innerFunc&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;acc&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; cur&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; i&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;acc&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;slice&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; i&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;someWrapper&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;cur&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; acc&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;outerFunc&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;&lt;span class=&quot;token constant&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;B&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;reduce&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;innerFunc&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;기존의 두 값을 각각 연산하여 두번의 함수를 호출하는 것에서, 하나의 함수를 호출하여 더 간략해진 코드로 작성이 가능해졌다.&lt;/p&gt;
&lt;h2&gt;금요일 프로젝트 중 느낀것&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;역시 팀 프로젝트는 어렵다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;팀 프로젝트를 진행하다 보면, 팀원들의 성향에 따라 분위기가 너무 급변한다.&lt;/p&gt;
&lt;p&gt;적극적으로 참여를 꺼리고, 자기 주장이 강한(나의 얘기일 수 있다.) 사람들이 너무 많아지면,&lt;/p&gt;
&lt;p&gt;프로젝트 디벨롭은 너무 다운되거나 너무 격양될 수 있다.&lt;/p&gt;
&lt;p&gt;그럼에도, 혼자 하는것 보다는 머리를 맞대고 협업을 하는게 옳다.&lt;/p&gt;
&lt;p&gt;힘들고, 귀찮다고 협업에 참여하는 기회를 놓쳐버린다면, 배우는것도 얻어가는것도 없을것이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;팀 프로젝트에서 토론은 공격이 아니라 단조(Forging)를 하는 과정이다&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;팀 프로젝트를 함에 있어 가장 중요한 것은 의견 조율인것 같다.&lt;/p&gt;
&lt;p&gt;운 좋게 팀원 모두가 비슷한 목적을 갖고 있다거나,&lt;/p&gt;
&lt;p&gt;소수의 자기주장이 강한 분들이 리드하거나,&lt;/p&gt;
&lt;p&gt;협업 경험이 많은 분들이 팀에 존재 한다면 의견 조율이 원활하게 돌아가겠지만 그런 상황은 많지 않다.&lt;/p&gt;
&lt;p&gt;반면 자기 의견이 너무 없거나,&lt;/p&gt;
&lt;p&gt;자신이 원하는 방향으로 흘러가지 않는다 하여 프로젝트에 참여를 잘 하지 않는다면&lt;/p&gt;
&lt;p&gt;프로젝트에 진전이 있기 힘들고, 좋은 결과물이 나오기 어려운 것 같다.&lt;/p&gt;
&lt;p&gt;결국 프로젝트를 진행하면서 나오는 토론은 서로를 공격하기 위한게 아니라,&lt;/p&gt;
&lt;p&gt;더 좋은 결과물을 내기 위해 열을 내는 작업임을 왜 알지 못하는지 모르겠다.&lt;/p&gt;
&lt;p&gt;우리는 칼을 들고 서로를 베기 위해 프로젝트를 하는게 아니라&lt;/p&gt;
&lt;p&gt;더 강력한 칼을 만들기 위해 수도 없이 망치로 두들기는 작업을 하는 것이다.&lt;/p&gt;
&lt;h2&gt;추가적으로 마스터님께 질문한 부분들&lt;/h2&gt;
&lt;h3&gt;회사에서 신입을 선발할 때 비 전공자, 학원 출신을 바라보는 시선이 어떠한가&lt;/h3&gt;
&lt;p&gt;요새 출신 학교, 출신 학과 등을 많이 보진 않는 편이다.&lt;/p&gt;
&lt;p&gt;그러나 개발 관련 전문 용어를 모르고 있다면, 면접 등에서 불리할 수 있다. 부스트 캠프 맴버쉽 과정등에서 이와 관련한 전문 용어들을 다수 얻어 갈 수 있을 것이다.&lt;/p&gt;
&lt;h3&gt;과거에 부스트 캠프와 같은 넥스트를 진행하셨는데, 그때와 지금은 무엇이 달라졌나&lt;/h3&gt;
&lt;p&gt;그때와 지금의 방향은 비슷하다.&lt;/p&gt;
&lt;p&gt;단지 그때는 주어진 문제를 학교의 형태로 해결하려 하였고,&lt;/p&gt;
&lt;p&gt;지금은 학교와는 다른 형태(지금의 부스트캠프, 우아한테크코스 등)로도 가능함을 알고 시도하고 있다.&lt;/p&gt;
&lt;h3&gt;현업에서 프로젝트를 새로 시작할때 기술스택이나 라이브러리를 어떻게 선택하게 되나&lt;/h3&gt;
&lt;p&gt;상황에 따라 다른것 같다.&lt;/p&gt;
&lt;p&gt;하지만 초기에는 대부분 CTO 등 개발을 총괄하시는 분들이 전반적인 역량을 파악하여 방향을 정하게 된다.&lt;/p&gt;
&lt;p&gt;물론 역량과 자원이 된다면 실제 모든 중요 선택지를 구현하여 테스트 하는 방법을 사용하기도 한다 (카카오톡 예시)&lt;/p&gt;
&lt;h3&gt;채용시 알고리즘 테스트에 대한 관점&lt;/h3&gt;
&lt;p&gt;과거 토익, 토플 만능 시대와 비슷한 양상인것 같아 지양하고 싶다.&lt;/p&gt;
&lt;p&gt;알고리즘 테스트는 최소한의 지식을 갖고 있다를 보여줄 뿐이지 업무의 역량을 파악하기 힘들다.&lt;/p&gt;
&lt;p&gt;그러나 회사 입장에서는 이러한 기준으로 선발이 편해 도입을 많이 한다.&lt;/p&gt;
&lt;p&gt;앞으로 회사들이 변화하였음 좋겠다.&lt;/p&gt;
&lt;h2&gt;회고&lt;/h2&gt;
&lt;p&gt;오늘은 챌린지 과정이 없어서 비교적 시간이 널널했다.&lt;/p&gt;
&lt;p&gt;하지만, 언제나 그렇듯 내가 배움을 얻고자 한다면 더 큰 노력을 들여 배움을 구할 수 있다.&lt;/p&gt;
&lt;p&gt;오늘 또한 많은 것을 느끼고, 많은 것을 배울 수 있는 하루였다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 챌린지 4일차]]></title><description><![CDATA[챌린지 중 느낀것 주어진 기능을 완성 한 뒤 시간이 많이 남아 재밌는 도전을 해봤다.   단, 코드의 가독성을 일부러 떨어트리는,  예를 들어 그 스스로 적당한 이름이 있을 수 있는 count 변수를 임의의 한글자 x…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-challenge/day-4/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-challenge/day-4/</guid><pubDate>Thu, 18 Jul 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;챌린지 중 느낀것&lt;/h2&gt;
&lt;p&gt;주어진 기능을 완성 한 뒤 시간이 많이 남아 재밌는 도전을 해봤다. &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;극단적 코드 줄이기&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;단, 코드의 가독성을 일부러 떨어트리는, &lt;/p&gt;
&lt;p&gt;예를 들어 그 스스로 적당한 이름이 있을 수 있는 count 변수를 임의의 한글자 x로 바꾸는 등의 편법은 안된다&lt;/p&gt;
&lt;p&gt;순수히 한가지 목적을 위하여 두가지 수단만을 사용한다. &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;불필요한 변수 제거하기&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;변수명을 극단적으로 줄이는 것은 안되지만, 변수를 제거하는것은 좋은 행동인듯 하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;불필요한 로직 제거하기&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;변수를 줄이다보면 클로저등이 필요없어 하나의 함수로 가능 해지기도 한다.&lt;/li&gt;
&lt;li&gt;또한, 로직을 줄여 한가지 함수로 두, 세가지 함수가 하는 일을 할 수 있다면 더욱 좋은 코드가 될것 이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;위 두가지 수단을 염두에 두고 코드 줄이기를 하였다. &lt;/p&gt;
&lt;p&gt;결과는 만족할만한 결과가 나왔다. &lt;/p&gt;
&lt;h3&gt;변수 줄이기&lt;/h3&gt;
&lt;p&gt;특히, 클로저에 편의를 위해 저장했던 공통 변수들을 하나씩 제거하니 외부 함수가 전혀 필요 없어졌다. &lt;/p&gt;
&lt;p&gt;이로 인해 두개의 함수로 작성 되었던 코드를, 하나의 함수로도 동일한 기능을 제공할 수 있었다. &lt;/p&gt;
&lt;h3&gt;로직 변화주기&lt;/h3&gt;
&lt;p&gt;루프를 돌리던것, 재귀를 돌리던것, reduce를 돌리던것 등 다양한 방법으로 같은 목적을 달성하는 고민을 하였다. &lt;/p&gt;
&lt;p&gt;그 중 가장 간단해지는 로직을 선택하여 구현하니 코드가 깔끔해 졌다.&lt;/p&gt;
&lt;h3&gt;재귀함수 클로져 날리기&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;어디서 찾아본게 아니라, 제 머릿속에서 하나씩 연구하며 내놓은 결과이다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;어제까지 재귀함수를 사용할때, 외부 함수에 공통 변수를 둔 뒤, &lt;/p&gt;
&lt;p&gt;새로운 내부 함수를 만들고 return으로 재귀함수를 호출하는 식으로 작성 하였다 .&lt;/p&gt;
&lt;p&gt;그러한 이유는 외부하수로 return을 하여 재귀를 호출할 방법이 마땅히 떠오르지 않았다. &lt;/p&gt;
&lt;p&gt;아래 코드로 생각해 보자 .&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;    &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;outerFunc&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    	&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; someVar &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    	&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;innerFunc&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    		&lt;span class=&quot;token comment&quot;&gt;// ... some logic&lt;/span&gt;
    		&lt;span class=&quot;token comment&quot;&gt;// .. some recursion logic&lt;/span&gt;
    	&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;innerFunc&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;someInitialVal&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;어제까지는 위 코드와 같이 작성 하였는데, 크게 두가지 이유로 그리하였다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;재귀가 도는 동안 공통의 참조가 될 대상인 &lt;code class=&quot;language-text&quot;&gt;someVar&lt;/code&gt; 가 필요하였다. &lt;/li&gt;
&lt;li&gt;내부의 &lt;code class=&quot;language-text&quot;&gt;innerFunc&lt;/code&gt; 을 익명으로 작성하고 싶었지만, 그 경우 재귀를 돌릴 수 없었다. (호출할 대상이 없으니…)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;그리하여 타협점을 찾아 &lt;code class=&quot;language-text&quot;&gt;outerFunc&lt;/code&gt; 를 호출하면, 자동으로 innerfunc가 실행되어 재귀 로직을 돌리도록 하였다. &lt;/p&gt;
&lt;p&gt;이 코드가 나쁜 코드는 아니지만, 위 기능에서 공통의 참조 대상이 &lt;code class=&quot;language-text&quot;&gt;someVar&lt;/code&gt;  가 굳이 필요 없다면, 재귀를 돌릴 다른 방법이 필요하다. &lt;/p&gt;
&lt;p&gt;그러한 경우에도 &lt;code class=&quot;language-text&quot;&gt;outerFunc&lt;/code&gt; 가 필요할까 라는 고민을 오늘 많이 하였다. 그 결과 나온 나의 결론은 다음과 같다 &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;dec2bin&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;&lt;span class=&quot;token constant&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;B&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;dec2bin&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;someMutation&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;코드를 보면 알겠지만, 더이상 &lt;code class=&quot;language-text&quot;&gt;outerFunc&lt;/code&gt; 가 필요하지 않다. &lt;/p&gt;
&lt;p&gt;탈출 조건을 재귀함수 내부 초반에 넣어야 한다는 고정관념에서 벗어나니, &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;return&lt;/code&gt; 값에 탈출 조건을 넣는 괴상한 코드를 작성해 볼 수 있었다. &lt;/p&gt;
&lt;p&gt;즉, 위 코드는 재귀의 탈출 조건과 재귀 실행 요건등을 리턴에 모두 압축 시켜놓은 참 신기한 코드가 되었다. &lt;/p&gt;
&lt;h3&gt;리듀서에서 &lt;code class=&quot;language-text&quot;&gt;accumulator&lt;/code&gt;로 복잡하게 값을 전달할 수 있지만,,, 그러지 말아보자.&lt;/h3&gt;
&lt;p&gt;코드 작성 중반에 변수들을 줄이기 위해 다음과 같은 로직을 작성 하였었다. &lt;/p&gt;
&lt;p&gt;일단, 이 코드를 작성하게 된 계기는 다음과 같다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;someArrayA&lt;/code&gt; 와 &lt;code class=&quot;language-text&quot;&gt;someArrayB&lt;/code&gt; 가 존재한다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;someFunc&lt;/code&gt; 에 &lt;code class=&quot;language-text&quot;&gt;someArrayA&lt;/code&gt; 와 &lt;code class=&quot;language-text&quot;&gt;someArrayB&lt;/code&gt; 를 넣어 어떤 값을 반환 받는데, 이 값은 두가지 정보를 갖고 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;someFunc&lt;/code&gt;의 반환값은 객체 형태로서, {S:1, C:1} 이런식이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;문제는 &lt;code class=&quot;language-text&quot;&gt;someFunc&lt;/code&gt;에 3번째 인자가 존재하는데, 이 인자는 reduce로 순회를 하며 직전에  &lt;code class=&quot;language-text&quot;&gt;someFunc&lt;/code&gt;에서 반환된 객체의 C값이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;즉, &lt;code class=&quot;language-text&quot;&gt;i&lt;/code&gt;순서에서  &lt;code class=&quot;language-text&quot;&gt;someFunc&lt;/code&gt; 연산의 결과로 &lt;code class=&quot;language-text&quot;&gt;{S:1, C:1}&lt;/code&gt;  객체가 나오는데, &lt;code class=&quot;language-text&quot;&gt;i+1&lt;/code&gt; 순서에서 &lt;code class=&quot;language-text&quot;&gt;i&lt;/code&gt; 때 연산된 C값을 3번째 인자로 넣는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;정리하면,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;결과적으로 내가 연산의 끝에 필요한 것은 배열 한개 이다.&lt;/li&gt;
&lt;li&gt;하지만, &lt;code class=&quot;language-text&quot;&gt;reduce&lt;/code&gt;등으로 순회를 하며 팔로우(keep track)  해야하는 값은 두가지 이다 (현재까지의 배열(정답) &amp;#x26;&amp;#x26; 직전 단계의 연산 결과(C))&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위 가정을 해결하기 위해 초반에는 클로저를 통해 외부와 내부 함수 사이 공용변수를 두었다. &lt;/p&gt;
&lt;p&gt;이 변수의 값을 계속 접근하여 flag를 뒤집듯이 연산을 이어 나갔다. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;    &lt;span class=&quot;token comment&quot;&gt;// 초반 코드&lt;/span&gt;
    
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;outerFunc&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    		&lt;span class=&quot;token comment&quot;&gt;// ... some logic&lt;/span&gt;
    		&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; res &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 외부의 어떤 값&lt;/span&gt;
    		&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; flag &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// reduce가 순회하며 초기화 되지 않을 저장소&lt;/span&gt;
    		&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; result &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; someArrayA&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;reduce&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;acc&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; cur&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; i&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    		  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; tmpResult &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;someFunc&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;cur&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; someArrayB&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; flag&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    			flag &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; tmpResult&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;C&lt;/span&gt;
    		  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;acc&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;r&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; tmpResult&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    		    &lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    		&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    		&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;result&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; someVal&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그러나, &lt;code class=&quot;language-text&quot;&gt;outerFunc&lt;/code&gt; 와 내부 저장 변수를 모두 제거하고 싶은 마음에 &lt;code class=&quot;language-text&quot;&gt;flag&lt;/code&gt; 를 일단 없애고 보니 아래 코드와 같은 모습이 나와버렸다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;    &lt;span class=&quot;token comment&quot;&gt;// 중반 코드&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;outerFunc&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    		&lt;span class=&quot;token comment&quot;&gt;// ... some logic&lt;/span&gt;
    		&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; result &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; someArrayA&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;reduce&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;acc&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; cur&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; i&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    		  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; tmpResult &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;someFunc&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;cur&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; someArrayB&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; acc&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;c&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    		  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    		    &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;acc&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    		    r&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;acc&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;r&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; tmpResult&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    		    c&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; tmpResult&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    		  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    		&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; r&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; c&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    		&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;result&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; someVal&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;flag&lt;/code&gt; 를 제거하는데에는 성공햇지만, 계속 따라가야할 변수를 잡을 방법을 생각하지 못하여 배보다 배꼽이 더 커진듯하다. &lt;/p&gt;
&lt;p&gt;그러나 아직 &lt;code class=&quot;language-text&quot;&gt;outerFunc&lt;/code&gt; 이 남아있었고, 로직도 너무 더러워서 고민을 많이 하였다. &lt;/p&gt;
&lt;p&gt;그 결과 나온 아이디어가, 다음과 같았다. (최종)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;어차피 flag와 같이 하나의 값만 참조한다면, 이 값을 배열 끝에 이어 붙이는건 어떨까&lt;/li&gt;
&lt;li&gt;예를 들어, (괄호 &lt;code class=&quot;language-text&quot;&gt;{}&lt;/code&gt; 가 제거해야 할 대상)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;    index &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;
    
    index &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;
    &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;
    
    index &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;
    &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;
    &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;즉, 이전 배열의 가장 끝에 존재 하였던 값 (위 코드에서 는 &lt;code class=&quot;language-text&quot;&gt;tmpResult.C&lt;/code&gt; , 즉 이전 &lt;code class=&quot;language-text&quot;&gt;someFunc&lt;/code&gt; 연산의 결과 중 &lt;code class=&quot;language-text&quot;&gt;C&lt;/code&gt; 값.) 을 제거하여 새로운 값을 이어 붙이는 전략이다. &lt;/p&gt;
&lt;p&gt;이 경우, &lt;code class=&quot;language-text&quot;&gt;accumulator&lt;/code&gt; 로 재 생성된 배열이 지속적으로 전달되고, &lt;/p&gt;
&lt;p&gt;우리는 루프마다 &lt;code class=&quot;language-text&quot;&gt;accumulator&lt;/code&gt; 에서 넘겨 받은 배열중에 정확히 어떤 부분에 미래에 참조할 새로운 C값이 있고, 어떤 부분에 과거에 참조한 C값이 있는지 알 수 있다. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;결과적으로, 새로 배열을 생성하기 전에 배열의 가장 마지막 엘리먼트가 C값, 즉 제거해야 할 대상이다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;이를 통해 최종적으로 나온 결과물은 이러하다.&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;someFunc&lt;/code&gt; 을 두개의 함수 &lt;code class=&quot;language-text&quot;&gt;someFuncA&lt;/code&gt; 와 &lt;code class=&quot;language-text&quot;&gt;someFuncB&lt;/code&gt; 로 분리 하였다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;innerFunc&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;acc&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; cur&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; i&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;acc&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;slice&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; i&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;someFuncA&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;cur&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; acc&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;someFuncB&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;cur&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; acc&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;outerFunc&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;&lt;span class=&quot;token constant&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;B&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;reduce&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;innerFunc&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;결과적으로 상당히 깔끔한 코드가 작성되었다. &lt;/p&gt;
&lt;p&gt;위 코드를 한줄로도 작성할 수 있지만, 가독성을 위해 분리해 두었다. &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;reduce&lt;/code&gt; 에 대한 &lt;code class=&quot;language-text&quot;&gt;return&lt;/code&gt; 값만 배열로 하나 존재하는데, 이 안에서 모든 로직이 진행된다. &lt;/p&gt;
&lt;h2&gt;회고&lt;/h2&gt;
&lt;p&gt;어제에 이어 &lt;code class=&quot;language-text&quot;&gt;reduce&lt;/code&gt; 에 대한 새로운 관점을 발견하게 되어 기분이 좋다. &lt;/p&gt;
&lt;p&gt;종종 리팩토링을 하며 코드를 줄이기 위한 고민을 많이 해봐야 겠다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 챌린지 3일차]]></title><description><![CDATA[피어 세션 중 느낀것 오늘 역시 새로운 용어들을 많이 들었고, 다른 이들의 생각과 고민의 흔적을 들어볼 수 있었다.  그중에 몇가지 기억에 남는 토론을 적는다.  thorw & try catch 에러를 핸들링 하기 위해서 try catch…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-challenge/day-3/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-challenge/day-3/</guid><pubDate>Wed, 17 Jul 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;피어 세션 중 느낀것&lt;/h2&gt;
&lt;p&gt;오늘 역시 새로운 용어들을 많이 들었고, 다른 이들의 생각과 고민의 흔적을 들어볼 수 있었다. &lt;/p&gt;
&lt;p&gt;그중에 몇가지 기억에 남는 토론을 적는다. &lt;/p&gt;
&lt;h3&gt;thorw &amp;#x26; try catch&lt;/h3&gt;
&lt;p&gt;에러를 핸들링 하기 위해서 try catch로 묶어주는 것이 좋은 디자인 패턴일까에 대한 고민이였다. &lt;/p&gt;
&lt;p&gt;나는 이 부분에 대해서 프런트앤드와 관련해서는 사용자의 앱이 crash될 수 있기 때문에 try catch로 묶기보단 console.error등의 방법을 쓰는게 나을것 같다는 생각을 전달 하였다. &lt;/p&gt;
&lt;h3&gt;빈 객체를 만들고 외부에서 정의하는 패턴&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;이 부분은 아직 검증을 하지는 못했으니, 주말에 찾아봐야 한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;어떤분이 다음과 같은 방식으로 코드를 작성하여 여쭤보았다 .&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const obj = {}
obj.someMethod = function(){}
obj.someProp = 1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;내가 원래 주로 하던 방법은 obj을 정의하면서 method와 property를 정의하는것 이였는데, &lt;/p&gt;
&lt;p&gt;위 패턴의 용도를 알게 되었다. &lt;/p&gt;
&lt;p&gt;가장 중요하게는 서로 다른 메서드에서 서로를 참조할때 문제가 발생할 수 있다고 한다. &lt;/p&gt;
&lt;p&gt;예를들어 다음과 같은 상황을 얘기하는 것 같다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; obj &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token function-variable function&quot;&gt;someMethod&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;someOtherMethod&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token function-variable function&quot;&gt;someOtherMethod&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그러나 빈 객체를 먼저 정의하고, 그 객체에 메소드를 이어 붙인다면, 순서를 잘 맞출 수 있을것이다. &lt;/p&gt;
&lt;p&gt;그러나 내가 들었던 생각은 &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;어차피 호이스팅 되지 않던가? 객체안에서는 안되나?&lt;/li&gt;
&lt;li&gt;객체 안은 일단 생성하면 서로 참조할 수 있게 되지 않을까?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;더 알아봐야 할듯 하다. 그러나 재밋는 발상이다. &lt;/p&gt;
&lt;h3&gt;monkey patch&lt;/h3&gt;
&lt;p&gt;대충 검색해 보았을때, 이에 대해 안티패턴, 폴리필 등의 키워드로 검색된다. &lt;/p&gt;
&lt;p&gt;오늘은 시간이 없어 제대로 알아보진 못했지만, 간단하게 들은 내용으로는 런타임에서 함수의 속성을 바꿔 다른 기능을 사용할 수 있게 하는 패턴인것 같다. &lt;/p&gt;
&lt;p&gt;내가 구현한 코드에 대해서 위 방법이라고 언급하셔서 찾아보려 한다. &lt;/p&gt;
&lt;p&gt;물론, 나는 이 몽키패치를 염두에 두고 개발한것은 아니였다. (위 정의만 봤을때는 내가 고려한 방법은 아닌것 같다. )&lt;/p&gt;
&lt;p&gt;내가 고려한 방법은 함수형 프로그래밍에서 curried function을 사용하여 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;같은 로그를 여러 함수들이 공유를 하며 사용할 수 있다&lt;/li&gt;
&lt;li&gt;로그를 위한 장치는 다양한 방법들을 부착 시킬 수 있다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;를 목표로 구현했었다. &lt;/p&gt;
&lt;p&gt;물론 내 생각대로 작성되지 않아 오해가 있을 수 있겠으나, 이 또한 나의 부족함이니 더 연구해보도록 하겠다. &lt;/p&gt;
&lt;h3&gt;전략 패턴, 팩토리 패턴&lt;/h3&gt;
&lt;p&gt;이 부분은 주말에 꼭 찾아보도록 하겠다. &lt;/p&gt;
&lt;h2&gt;챌린지 중 느낀것&lt;/h2&gt;
&lt;h3&gt;재귀에 대한 학습 필요성&lt;/h3&gt;
&lt;p&gt;막상 재귀 함수를 작성하려 하니 생각보다 원활하게 작성이 되지 않았다 .&lt;/p&gt;
&lt;p&gt;return을 쌓아가며 최종 반환값을 기대하는 방식으로 짜야 할것 같음에도 &lt;/p&gt;
&lt;p&gt;잘 되지 않아 클로저를 통한 변수 공유를 시도하였다.&lt;/p&gt;
&lt;p&gt;물론 마지막에는 코드가 잘 나온것 같다. &lt;/p&gt;
&lt;p&gt;코드를 작성하며 재귀와 reduce를 사용함에 있어&lt;/p&gt;
&lt;p&gt;reducer가 갑자기 떠올랐다. 그리고 문득 든 생각이, &lt;/p&gt;
&lt;p&gt;어차피 acc로 다음 인자를 전달받고, 이 acc는 계속 변화할 수 있고 단지 다음에 대한 refer의 용도라면&lt;/p&gt;
&lt;p&gt;매 순간 재귀를 돌릴 때 마다 합성된 값을 acc로 넘겨, 최종적으로 이 값을 전달받으면 되지 않는가 라는 생각이 들었고&lt;/p&gt;
&lt;p&gt;옮은 생각 이였다. &lt;/p&gt;
&lt;p&gt;이 패턴은 내가 redux를  활용하며 당연스래 사용하던 패턴이였는데, 쌩으로 구현하며 내 부족함을 또 한번 느끼게 되었다.&lt;/p&gt;
&lt;h3&gt;reduce에 대한 고찰&lt;/h3&gt;
&lt;p&gt;Array클래스에 있는 다양한 내장함수를 새로이 구현하는 기능을 시도 하였다. &lt;/p&gt;
&lt;p&gt;그중에서 reduce가 가장 시간이 오래 걸리고, 골치 아팠는데 &lt;/p&gt;
&lt;p&gt;그 이유는 내가 reduce에 대해 잘못 알고 있던 부분 때문 이였다. &lt;/p&gt;
&lt;p&gt;나는 reduce의 인자로 callback함수와 뒤의 초기값 인자가 필수 요소라고 착각하고 있었다. &lt;/p&gt;
&lt;p&gt;그러나, 뒤의 초기값에 대한 인자는 선택사항이며 이에 따라 다르게 행동함을 알게 되었다. &lt;/p&gt;
&lt;p&gt;정리하자면, initialValue에 따라 초기에 두 부분이 영향을 받는다. (currentIndex,currentValue)&lt;/p&gt;
&lt;p&gt;일단 initialValue가 주어진다면 currentIndex는 0, 주어지지 않는다면 1로 셋팅 된다&lt;/p&gt;
&lt;p&gt;또한 initialValue가 주어지다면 currentValue는 initialValue가 되고, 주어지지 않는다면 array의 첫번째 아이템으로 셋팅된다. &lt;/p&gt;
&lt;p&gt;재귀함수로 구현한 reduce에서 첫번째 accumulator값은 currentValue로 시작하는데, &lt;/p&gt;
&lt;p&gt;이를 쉽게 정리하면 다음과 같을것 같다. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;initialValue(초기값)이 주어진 경우, initialValue를 포함하여 array전체를 한번 훑는다. (n+1)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;initialValue(초기값)이 주어지지 않은 경우, array전체를 한번 훑는다. (n)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;return값이 없는 함수의 경우 jest에서 어떻게 테스트 할까&lt;/h3&gt;
&lt;p&gt;이 부분에 대해 고민을 많이 하였다. &lt;/p&gt;
&lt;p&gt;일단 .toBe나 toEqual 등의 방법을 사용하기 위해서는 전후의 값을 비교해야 한다. &lt;/p&gt;
&lt;p&gt;console.log같은 방법이 아닌, return을 비교해야 하는데 forEach같은 것은 어떻게 테스트할 수 있을까&lt;/p&gt;
&lt;p&gt;처음에 든 생각은 snapshot을 활용한 방법이였으나, 또 아닌것 같아 그만 두었다 &lt;/p&gt;
&lt;p&gt;두번째로 든 생각은 외부의 값에 변화를 이르키고, 그 값을 비교하는 것이다.&lt;/p&gt;
&lt;p&gt;즉 의도적으로 side effect를 이르키는 방법이다. &lt;/p&gt;
&lt;p&gt;이 방법이 구현하기도 생각하기도 쉬워서 이렇게 하였다. &lt;/p&gt;
&lt;h3&gt;jest에서 블록당 독립된 테스트 환경 구축이 가능할까&lt;/h3&gt;
&lt;p&gt;jest에서 계속 테스트를 하니, 각각의 test문에서 함수가 실행되는 것이 독립된 공간에서 실행되는게 아닌듯 하다. 이를 완전히 격리시켜 줄 방법을 찾아봐야 하겠다. &lt;/p&gt;
&lt;h3&gt;map, reduce, filter등을 사용할때, arrow function을 사용하면 context가 변화되어 주의&lt;/h3&gt;
&lt;p&gt;항상 arrow function 사용시에 동적바인딩에 주의하여야 한다. &lt;/p&gt;
&lt;p&gt;이 부분을 조금 더 이해할 필요가 있고, 이 또한 주말에 집중해서 정리해야 겠다. &lt;/p&gt;
&lt;p&gt;fat arrow를 사용하면 다음과 같이 참조하는 context에 변화가 생기게 된다. &lt;/p&gt;
&lt;p&gt;물론 this를 활용하지 않음이 더 좋을것 같지만, 그럼에도 이런 일이 생길 수 있음을 숙지하고 있자 &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;    &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;b&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;c&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;a&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// undefined&lt;/span&gt;
    
    &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;b&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;c&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;a&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// {a:1}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;회고&lt;/h2&gt;
&lt;p&gt;여러모로 힘든 하루였다. &lt;/p&gt;
&lt;p&gt;불합격 통보를 받고 정신적으로 힘든 상태에서 꾹꾹 참아가며 주어진 과제를 해나갔다. &lt;/p&gt;
&lt;p&gt;힘든 상황임에도 포기하지 않고 끝까지 해내서 뿌듯한 하루였다. &lt;/p&gt;
&lt;p&gt;내일은 더 발전된 모습의 내가 되었으면 한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 챌린지 2일차]]></title><description><![CDATA[피어 세션 후기 오늘 처음 피어 세션을 통해 코드리뷰를 했다. 모두 높은 수준의 지식과 긱함을 같고 있어 굉장이 놀라운 경험이엿다. 조원 중 한명은 타입과 디자인에 대해 광적으로(좋은 의미)로 집착을 하였고 또 다른 한명은 기본적인 js…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-challenge/day-2/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-challenge/day-2/</guid><pubDate>Tue, 16 Jul 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;피어 세션 후기&lt;/h2&gt;
&lt;p&gt;오늘 처음 피어 세션을 통해 코드리뷰를 했다.&lt;/p&gt;
&lt;p&gt;모두 높은 수준의 지식과 긱함을 같고 있어 굉장이 놀라운 경험이엿다.&lt;/p&gt;
&lt;p&gt;조원 중 한명은 타입과 디자인에 대해 광적으로(좋은 의미)로 집착을 하였고&lt;/p&gt;
&lt;p&gt;또 다른 한명은 기본적인 js에 대한 지식이 탄탄함을 느낄 수 잇었다&lt;/p&gt;
&lt;p&gt;마지막 한명은 js에 대해 아직은 많이 모르는 듯 하지만 끊임없이 배울려 노력한다&lt;/p&gt;
&lt;p&gt;조원 세명 모두에게 많은걸 배우고 느낄 수 잇던 경험이였다&lt;/p&gt;
&lt;p&gt;이번에 나는 while loop안에 변화되는 const 상수를 넣는 실수를 범햇는데, 팀원 분들이 딱 지적 해 주어서 발전된 코드를 내놓을 수 있었다.&lt;/p&gt;
&lt;p&gt;피어 세션 동안 다른분의 코드를 살펴보며 예외 처리에 대한 아이디어나 다양한 js 이론 등에 대해 토론해 보는 좋은 경험이였다&lt;/p&gt;
&lt;h2&gt;과제 후기&lt;/h2&gt;
&lt;p&gt;오늘 주어진 과제로도 많은것을 배울 수 잇었다.&lt;/p&gt;
&lt;p&gt;새로운것을 찾아본 것은 아니지만, 여러가지 구현 방법 중 선택을 위해 다양한 고민을 해볼 수 있었다.&lt;/p&gt;
&lt;p&gt;특히, 함수의 호출시마다 logging을 쌓아놓고,&lt;/p&gt;
&lt;p&gt;난중에 logging함수 호출 시 쌓인 스텍을 반환하는 작업이 잇었는데&lt;/p&gt;
&lt;p&gt;이 부분에 많은 고민을 하였다.&lt;/p&gt;
&lt;p&gt;나의 주 관심사는 어떻게 하면 메인 함수와 logging 함수를 최대한 decoupling할 수 잇을지에 대한 고민 이엿다.&lt;/p&gt;
&lt;h3&gt;내가 설정한 요구 사항&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;로깅을 위한 객체는 필요시마다 재 생성할 수 잇다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;재 생성된 객체는 각각의 로그 인벤토리(스택)을 갖고 있다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;독립된 기능을 제공하는 함수들이 존재한다&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;기능 함수와 로깅을 위한 객체는 서로 최대한 독립적으로 decouple되야 한다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;배스트는 하나의 연결고리를 가지고, 서로에 대한 함수 호출 없이 알아서 작동하는 방식이다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;내가 고민 했던 방법은 다음과 같다&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;가장 기본적인 방법으로(안좋은) 그냥 메인에서 로깅 함수를 호출한다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;두 함수가 항상 같은 컨텍스트에 존재해야 한다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또 다른 기본적인 방법(안좋은) 전역변수로 로그 스택을 쌓는다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;당연히, 가장 쉽지만 가장 안좋은 방법이다. 전역은 건드리면 안된다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Event emmiter등의 방법으로 메인→logging 방향으로 신호를 보낸다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이 경우 일방적인 데이터의 흐름 이므로 메인 함수에서 로깅 함수의 호출 방법에 대한 고민을 하지 않아도 된다&lt;/li&gt;
&lt;li&gt;또한 내가 알기론 보통의 웹페이에서 중앙에 로그를 관리하기 위한 방법으로 스이기도 한다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;.json, .txt등 db의 역할이 되는 외부 저장소를 생각 해 보았다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;로그가 발생할 때 마다 파일을 작성하여 저장해 두는 방식이다&lt;/li&gt;
&lt;li&gt;하지만 굳이 필요 없는 접근법인듯 하여 제외했다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bind하여 this로 접근한다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이게 내가 한 방법이다. 콜백 함수와 객체를 전달하여 두개를 binding하였다&lt;/li&gt;
&lt;li&gt;this를 통해 해당 메소드를 접근하고, 해당 메소드가 존재하는지 여부를 체크하였다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;클로저를 사용하여 각 함수마다 레퍼 컨테스트를 적용한다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위의 this를 사용하는것 보다 훨씬 깔끔한듯 하다.&lt;/li&gt;
&lt;li&gt;이 글을 작성하며 복기를 하다가 생각난 방법이다.&lt;/li&gt;
&lt;li&gt;This를 사용할 필요 없이 전달받은 함수 혹은 객체에 해당 메소드가 있는지 활용하면 된다&lt;/li&gt;
&lt;li&gt;물론 바인딩도 불필요 하다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;그러나 아직까지도 깔끔한 방법을 생각해내지 못했다.&lt;/p&gt;
&lt;p&gt;내일 다른이들이 구현한 방법을 살펴보고 더 나은 방법을 연구해 보도록 하겠다.&lt;/p&gt;
&lt;h2&gt;회고&lt;/h2&gt;
&lt;p&gt;오늘은 외부에 잠시 나갔다 올 일이 있어서 많은 시간 공부에 할애하지 못했다.&lt;/p&gt;
&lt;p&gt;새로운 것을 적용하거나 공부하진 못했지만, 내가 갖고 있는 지식을 돌이켜 보고 깊이 생각할 수 있는 시간 이였다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 챌린지 나의 다짐]]></title><description><![CDATA[절대 지각하지 않는다. 9 to 9 모든 코드에 Test를 적용한다. 새로운 것들을 적용해 본다. 커밋 규칙을 준수한다. 매일 배운 내용은 그날 정리한다.]]></description><link>https://sukjae.github.io/daily-study/boost-camp-challenge/day-0/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-challenge/day-0/</guid><pubDate>Mon, 15 Jul 2019 00:00:00 GMT</pubDate><content:encoded>&lt;ol&gt;
&lt;li&gt;절대 지각하지 않는다. &lt;strong&gt;9 to 9&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;모든 코드에 Test를 적용한다.&lt;/li&gt;
&lt;li&gt;새로운 것들을 적용해 본다.&lt;/li&gt;
&lt;li&gt;커밋 규칙을 준수한다.&lt;/li&gt;
&lt;li&gt;매일 배운 내용은 그날 정리한다.&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[부스트캠프 2019 챌린지 1일차]]></title><description><![CDATA[주어진 문제를 해결하며 적용한 라이브러리 Jest - testing library JsDoc - markup language used to annotate JavaScript source code files TypeScript - It is a…]]></description><link>https://sukjae.github.io/daily-study/boost-camp-challenge/day-1/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/boost-camp-challenge/day-1/</guid><pubDate>Mon, 15 Jul 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;주어진 문제를 해결하며 적용한 라이브러리&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Jest&lt;/strong&gt; - testing library&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JsDoc&lt;/strong&gt; - markup language used to annotate JavaScript source code files&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TypeScript&lt;/strong&gt; - It is a strict syntactical superset of JavaScript, and adds optional static typing to the language.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ESLint&lt;/strong&gt; - static code analysis tool for identifying problematic patterns found in JavaScript code&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;오늘 시도한 것&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;TDD (잘 안됬음)&lt;/li&gt;
&lt;li&gt;Unit Testing&lt;/li&gt;
&lt;li&gt;Type Checking&lt;/li&gt;
&lt;li&gt;Airbnb linter&lt;/li&gt;
&lt;li&gt;영어로 커밋 메시지 작성해 보기&lt;/li&gt;
&lt;li&gt;Refactoring&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;오늘 배운 것&lt;/h2&gt;
&lt;h3&gt;Jest 넣어보기&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;jest 에서 typecheck는 함수를 인자로 받는다.&lt;/li&gt;
&lt;li&gt;지금은 unit test만 작성 하였지만, 추후에는 다른 테스팅 기법도 시도해 봐야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/47397208/error-is-thrown-but-jests-tothrow-does-not-capture-the-error&quot;&gt;Error is thrown but Jest’s &lt;code class=&quot;language-text&quot;&gt;toThrow()&lt;/code&gt; does not capture the error&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;type checking 넣어보기 (type script &amp;#x26; jsdoc)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;runtime에서 type을 체킹하는 것과 코드상에서 체킹하는것을 비교 고민해봐야 할듯 하다.&lt;/li&gt;
&lt;li&gt;런타임에서 타입체킹을 강제하지 않기 때문에 따로 에러 헨들링 해줘야 하는것 같다.&lt;/li&gt;
&lt;li&gt;예시 &lt;code class=&quot;language-text&quot;&gt;if(typeof varFirst !== &amp;#39;number&amp;#39;){throw new TypeError();}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;이렇게 발생한 에러는 Jest에서 다음과 같이 테스트할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token function&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;wrong type testing&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;expect&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// @ts-ignore&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;gcd&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;a&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;b&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;toThrow&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;TypeError&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;여기서 작은 팁은, 위 테스트가 에러를 가정한 테스트 임으로 VSCode에서는 type error로 계속해서 어필한다. 이를 방지하기 위해 &lt;code class=&quot;language-text&quot;&gt;// @ts-ignore&lt;/code&gt; 을 추가한다. (해당 라인의 코드 바로 위에 작성해야함)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;JSDoc 조금 더 자세히&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Technically, we are going to &lt;strong&gt;use TypeScript but not for compiling&lt;/strong&gt; our code.&lt;/li&gt;
&lt;li&gt;Instead we’ll use it to &lt;strong&gt;check&lt;/strong&gt; the types of our JavaScript code &lt;strong&gt;during code time&lt;/strong&gt; using JSDocs comments and type inference.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;즉, JSDoc을 사용함에 있어 TS를 활용하지만 컴파일 단계에서 파일을 변환(ts→js) 하는게 아니라 코딩중에 체크하는 방법이 된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;타입을 사용하면 다음과 같은 장점을 얻을 수 있다.&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Early detection of type errors&lt;/li&gt;
&lt;li&gt;Better code analysis&lt;/li&gt;
&lt;li&gt;Improved IDE support&lt;/li&gt;
&lt;li&gt;Promotes dependable refactoring&lt;/li&gt;
&lt;li&gt;Improves code readability&lt;/li&gt;
&lt;li&gt;Provides useful IntelliSense while coding&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;또한 JSDoc은 일반적인 JS의 주석의 형태를 띈다는 특징을 갖고 있다.&lt;/p&gt;
&lt;p&gt;이 특징은 타입 체크를 위하여 별도의 컴파일이나 변형이 필요치 않다는 것을 의미 한다. 최종 단계에서 minify등을 할시에 자동으로 주석을 날릴 수 있으므로 매력적이다.&lt;/p&gt;
&lt;p&gt;typescript와 활용해서 만들 수 있는 큰 시너지중에 하나는 d.ts와 연동이 가능하다는 것이다.&lt;/p&gt;
&lt;p&gt;별도의 커스텀 타입을 정의한 뒤 본 JS의 extension을 망가트리지 않는 선에서 활용이 가능하다.&lt;/p&gt;
&lt;p&gt;아래 컨텐츠에 자세히 서술되어 있다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.com/@trukrs/type-safe-javascript-with-jsdoc-7a2a63209b76&quot;&gt;Type Safe JavaScript with JSDoc - TruckJS - Medium&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;linter 넣어보기 (airbnb)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;여러 Linter중에 가장 유명하고 기본이 되는 airbnb 스타일로 적용을 하였다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;처음에 하나하나 스타일링을 맞추다, 귀찮아서 save시에 autoFix옵션을 설정 하였다 .&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이는 VSCode 의 ESLint 패키지에서 설정 가능하며 아래 내용을 참조하자&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint&quot;&gt;ESLint - Visual Studio Marketplace&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;github 잘못 푸시 했을때&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;git으로 원격 repository로 잘못된 branch로 push를 하는 실수를 했다.&lt;/li&gt;
&lt;li&gt;이로 인해 fork된 나의 repository는 master로 오염되었고, 나에게 할당되어 있던 branch로 이미 작성된 commit message를 옮길 방법이 필요 했다.&lt;/li&gt;
&lt;li&gt;결국에, commit message를 옮길 방법은 찾았지만, 굳이 master로 내 private forked repository에 올라간 commit을 지울 필요는 없었기에 그냥 놔두었다.&lt;/li&gt;
&lt;li&gt;아래 답변을 활용하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/6465699/git-push-to-wrong-branch&quot;&gt;Git push to wrong branch&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;/h3&gt;
&lt;h2&gt;회고&lt;/h2&gt;
&lt;p&gt;비교적 쉬운 난이도의 과제가 주어지니 코드 외적인 것을 고민할 시간이 많았다.&lt;/p&gt;
&lt;p&gt;그로 인해 지금껏 적용해 보지 않았던 것들을 많이 시도해볼 수 있었다.&lt;/p&gt;
&lt;p&gt;오늘 적용한 그대로를 쌓아가며 매일 매일 발전하도록 하자.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[JS 이해하기 [JS, nodeJS, V8, Libuv]-1탄]]></title><description><![CDATA[공부 이유 JS를 공부하며 항상 햇갈리는 개념들이 있었다. 나는 JS를 공부한다 해야 하나 NodeJS를 공부한다 해야하나 JS event loop은 도대체 무엇일까 JS는 왜, 어떻게 single thread, non blocking io…]]></description><link>https://sukjae.github.io/daily-study/daily/2019-07-14/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/daily/2019-07-14/</guid><pubDate>Sun, 14 Jul 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;공부 이유&lt;/h2&gt;
&lt;p&gt;JS를 공부하며 항상 햇갈리는 개념들이 있었다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;나는 JS를 공부한다 해야 하나 NodeJS를 공부한다 해야하나&lt;/li&gt;
&lt;li&gt;JS event loop은 도대체 무엇일까&lt;/li&gt;
&lt;li&gt;JS는 왜, 어떻게 single thread, non blocking io일까?&lt;/li&gt;
&lt;li&gt;NodeJS가 browser에서 쓰이던가? 안 쓰이면 그 사이에는 무엇이 있던가&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;등등… 위 내용을 하나씩 정리 해 보도록 한다.&lt;/p&gt;
&lt;p&gt;이번 챕터에서는 JS, nodeJS, v8 등 혼란스러운 용어 정리를 해보고&lt;/p&gt;
&lt;p&gt;다음에는 event loop과 관련된 디테일한 정리를 해보도록 한다.&lt;/p&gt;
&lt;h2&gt;공부 내용&lt;/h2&gt;
&lt;p&gt;일단, 용어에 대한 정리는 wiki에 영어로 너무 잘 나와있다. 그중 중요한 부분만 적어본다.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/JavaScript&quot;&gt;JavaScript&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;JavaScript often abbreviated as JS, is a high-level, &lt;strong&gt;interpreted programming language&lt;/strong&gt; that c&lt;strong&gt;onforms to the ECMAScript specification&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;The vast majority of websites use it, and major web browsers have a &lt;strong&gt;dedicated JavaScript engine to execute it.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;JavaScript supports event-driven, functional, and imperative (including object-oriented and prototype-based) programming styles.&lt;/li&gt;
&lt;li&gt;It has APIs for working with text, arrays, dates, regular expressions, and the DOM, but the language itself &lt;strong&gt;does not include any I/O&lt;/strong&gt;, such as networking, storage, or graphics facilities. &lt;strong&gt;It relies upon the host environment&lt;/strong&gt; in which it is embedded to provide these features.&lt;/li&gt;
&lt;li&gt;The terms Vanilla JavaScript and Vanilla JS refer to &lt;strong&gt;JavaScript not extended by any frameworks or additional libraries&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Node.js&quot;&gt;Node.js&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Node.js is an open-source, cross-platform &lt;strong&gt;JavaScript run-time environment&lt;/strong&gt; that executes JavaScript code &lt;strong&gt;outside of a browser.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Node.js lets developers use &lt;strong&gt;JavaScript to write command line tools and for server-side scripting.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Node.js has an &lt;strong&gt;event-driven architecture capable of asynchronous I/O&lt;/strong&gt;. These design choices aim to optimize &lt;strong&gt;throughput&lt;/strong&gt; and &lt;strong&gt;scalability&lt;/strong&gt; in web applications with many input/output operations, as well as for real-time Web applications&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Chrome_V8&quot;&gt;Chrome V8(aka. V8)&lt;/a&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Chrome V8, or simply V8, is an open-source &lt;strong&gt;JavaScript engine&lt;/strong&gt; developed by The Chromium Project for Google Chrome and Chromium web browsers.&lt;/li&gt;
&lt;li&gt;V8 &lt;strong&gt;compiles&lt;/strong&gt; JavaScript directly &lt;strong&gt;to native machine code before executing&lt;/strong&gt; it&lt;/li&gt;
&lt;li&gt;The compiled code is &lt;strong&gt;additionally optimized (and re-optimized) dynamically at runtime&lt;/strong&gt;, based on heuristics of the code’s execution profile.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Libuv&quot;&gt;libuv&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;libuv is a multi-platform C library that provides &lt;strong&gt;support for asynchronous I/O based on event loops.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;위 내용을 한번 정리 해 보자&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;JS&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;우리가 사용하는 &lt;strong&gt;‘언어’.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;웹브라우저에서 고유한 JS engine으로 실행됨 (크롬브라우저→V8 engine)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;I/O와 관련된 어떠한 API도 제공하지 않는다. I/O기능은 호스트 환경에 의해 의지한다.&lt;/li&gt;
&lt;li&gt;Vanila JS는 어떠한 framework, library로 오염되지 않은 순수한 JS를 뜻함&lt;/li&gt;
&lt;li&gt;ES의 표준을 따름&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;NodeJS&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JS가 사용되는 &lt;strong&gt;‘실행 환경’(run-time env.)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;JS를 브라우저 밖에서 사용하기 위해 고안됨&lt;/li&gt;
&lt;li&gt;command line tool과 server side 스크립팅을 위해 사용됨&lt;/li&gt;
&lt;li&gt;이를 통해 유저에게 전달하기 전에 동적 컨텐츠 생성 가능&lt;/li&gt;
&lt;li&gt;이벤트 드리븐, 비동기 I/O를 가능케 함(I/O는 JS에서 제공치 못했던 부분임을 기억)&lt;/li&gt;
&lt;li&gt;이를 통해 &lt;strong&gt;throughput와 scalability에서 이득&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;V8&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JS가 사용되는 &lt;strong&gt;‘엔진’&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;사용된다는 의미는 JS코드를 파싱하고 변환하여 실행 가능한 커맨드로 바꾸는 작업을 함&lt;/li&gt;
&lt;li&gt;즉, 바로 &lt;strong&gt;네이티브하게 실행 가능한 기계 언어로 변환&lt;/strong&gt;하는 장치&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Libuv&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NodeJS를 만들기 위해 고안된 도구&lt;/li&gt;
&lt;li&gt;실질적으로 nodeJS의 async IO를 관리하기 위한 도구를 제공하는 녀석.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;우리가 알고 있는 Event-Loop이 사실 이 라이브러리가 구현 하는 것이다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;마지막으로 다음을 한번 더 정리하자.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JS engine vs JS runtime env&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;JS Engine은&lt;/strong&gt; JS코드를 파싱하여 실행 가능한 &lt;strong&gt;코드로 변환하기 위한 장치&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JS Runtime Env 는&lt;/strong&gt; JS가 가지고 있는 태생적인 한계(외부와의 소통. 즉 I/O)&lt;strong&gt;를 보충하기 위한 장치.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;그리고 둘은 독립적인 존재가 아니라 포함 관계이다.&lt;/p&gt;
&lt;p&gt;즉,&lt;/p&gt;
&lt;p&gt;NodeJS는 V8과 Libuv위에 구현되어 있고,&lt;/p&gt;
&lt;p&gt;비슷하게 웹브라우저(크롬 등)에서도 JS engine과 JS Runtime Env 위에 구현되어 있을 것이다.&lt;/p&gt;
&lt;p&gt;웹 브라우저 또한 event-loop등의 기능을 제공하기 때문에,&lt;/p&gt;
&lt;p&gt;구현한 라이브러리는 다를 수 있지만, 비슷하게 보고 학습하면 될듯 하다.&lt;/p&gt;
&lt;h2&gt;한줄 정리&lt;/h2&gt;
&lt;p&gt;JS는 언어&lt;/p&gt;
&lt;p&gt;NodeJS는 JS 실행 환경&lt;/p&gt;
&lt;p&gt;V8은 JS 엔진&lt;/p&gt;
&lt;p&gt;끗&lt;/p&gt;</content:encoded></item><item><title><![CDATA[bash_profile 와 zsh에 관한 글]]></title><description><![CDATA[TL;DR 그냥 bash_profile내용을 zshrc 파일에 넣으면 된다 기본 터미널을 Iterm2로 바꾸고, zsh로 바뀌었음에도 bash_profile…]]></description><link>https://sukjae.github.io/daily-study/daily/2019-07-13/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/daily/2019-07-13/</guid><pubDate>Sat, 13 Jul 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;TL;DR&lt;/h2&gt;
&lt;p&gt;그냥 bash_profile내용을 zshrc 파일에 넣으면 된다&lt;/p&gt;
&lt;p&gt;기본 터미널을 Iterm2로 바꾸고, zsh로 바뀌었음에도 bash_profile에 넣어도 왜 아무런 변화가 없는지, 왜 여전히 터미널에서 명령어 사용이 안되는지 삽질 하였다.&lt;/p&gt;
&lt;p&gt;생각해보면, 단순한 문제였다.&lt;/p&gt;
&lt;p&gt;기본 터미널을 사용하였을때는 bash를 사용하였으니 bash_profile에 관련 설정을 넣으면 되었다.&lt;/p&gt;
&lt;p&gt;이 단순한 방법의 연결고리를 찾지 못했을때 별짓을 다 했다.&lt;/p&gt;
&lt;p&gt;(이렇게 한걸음 한걸음 배워가는 것이다…)&lt;/p&gt;
&lt;h2&gt;zsh에서 기능 사용 방법&lt;/h2&gt;
&lt;p&gt;나는 다음과 같은 방법을 주로 사용했었다…&lt;/p&gt;
&lt;p&gt;방법 1. 매번 해당 폴더에 가서 명령어를 실행한다.&lt;/p&gt;
&lt;p&gt;방법 2. bash_profile을 zsh에서 매번 source하여 임의로 실행한다&lt;/p&gt;
&lt;p&gt;방법 3. bash&lt;em&gt;profile을 source하는 코드를 zsh에 포함함으로서 zsh가 실행될때 마다 bash&lt;/em&gt;profile의 모든 내용을 실행하도록 한다.&lt;/p&gt;
&lt;h3&gt;단점&lt;/h3&gt;
&lt;p&gt;방법1 : 매번 명령어를 찾아 가야 한다. 예를 들어, 해당 기능을 실행하기 위해 설치된 파일을 매번 가야 한다. 생각 해보자.. 끔찍하다&lt;/p&gt;
&lt;p&gt;방법2 : 방법1 보다는 아주 조금 낫다. 왜냐하면 모든 설치된 기능을 일일이 찾을필요 없이 bash_profile에 저장되어 있는 소스를 그래도 zsh에서 실행하기 때문.&lt;/p&gt;
&lt;p&gt;방법3 : 방법2 보다 조금 낫다. 방법2는 매번 터미널을 켤때 마다 커맨드를 실행 해 줘야 하는데, 이 경우 자동으로 해준다.&lt;/p&gt;
&lt;p&gt;방법2&amp;#x26; 방법3의 치명적인 문제는, 매번 켜질때 마다 로딩을 기다려야 하고 불필요하게 다 훑어야 한다는 것이다.&lt;/p&gt;
&lt;p&gt;이 방법들을 사용할때는, 정말 이 방법 밖에 없나 싶었다.&lt;/p&gt;
&lt;p&gt;무식하면 몸이 고생한다고… 이렇게 한동안 사용했던게 신기하다&lt;/p&gt;
&lt;p&gt;하지만 위에 언급한대로 ~/.zshrc에 내용을 옮김으로서 싹 해결되었다.&lt;/p&gt;
&lt;h1&gt;결론&lt;/h1&gt;
&lt;p&gt;bash_profile의 내용을 그대로 zshrc 넣으면 된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;# If you use bash
echo &amp;#39;export PATH=/usr/local/Cellar/ruby/2.4.1_1/bin:$PATH&amp;#39; &amp;gt;&amp;gt; ~/.bash_profile

# If you use ZSH:
echo &amp;#39;export PATH=/usr/local/Cellar/ruby/2.4.1_1/bin:$PATH&amp;#39; &amp;gt;&amp;gt; ~/.zprofile&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/a/43293653/5755608&quot;&gt;How do I install ruby gems on Mac&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;참고: [방법 3] 처럼 나같이 무식한 방법을 썻던 사람들…&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/robbyrussell/oh-my-zsh/issues/3807#issuecomment-187930190&quot;&gt;.bash_profile needs to be sourced after oh-my-zsh updates · Issue #3807 · robbyrussell/oh-my-zsh&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://seonift.github.io/2018/02/05/macOS-%ED%84%B0%EB%AF%B8%EB%84%90%EC%97%90%EC%84%9C-adb-%EC%8B%A4%ED%96%89-%EC%8B%9C-%EB%82%98%EC%98%A4%EB%8A%94-command-not-found-adb-%EC%98%A4%EB%A5%98-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95/&quot;&gt;[macOS] 터미널에서 adb 실행 시 나오는 ‘command not found: adb’ 오류 해결 방법&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[ReactJS에서 props.render vs props.children vs HOC]]></title><description><![CDATA[공부 이유 : Composition over Inheritance ReactJS에서 선호되는 방식 중 하나이다. 또한, JS에서도 선호되는 방식이다. React docs 에서 학습을 하다보면, 항상 Composition 과 Inheritance…]]></description><link>https://sukjae.github.io/daily-study/daily/2019-07-12/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/daily/2019-07-12/</guid><pubDate>Fri, 12 Jul 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;공부 이유 :&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Composition over Inheritance&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ReactJS에서 선호되는 방식 중 하나이다.&lt;/p&gt;
&lt;p&gt;또한, JS에서도 선호되는 방식이다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://reactjs.org/docs/composition-vs-inheritance.html#containment&quot;&gt;React docs&lt;/a&gt; 에서 학습을 하다보면, 항상 Composition 과 Inheritance 를 비교하며 children 패턴을 보여준다.&lt;/p&gt;
&lt;p&gt;이해는 가지만, 나는 이것이&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;render를 통해 직접 컴포넌트를 주입하는 방식(props.render)&lt;/li&gt;
&lt;li&gt;Higher order component 를 통해 감싸는 방식&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;과 무엇이 다른지 명확하게 알지 못해 알아 보았고, 정리하게 되었다.&lt;/p&gt;
&lt;h2&gt;공부 내용 :&lt;/h2&gt;
&lt;h3&gt;props.render&lt;/h3&gt;
&lt;p&gt;다음과 같은 이름으로도 불린다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;render prop&lt;/li&gt;
&lt;li&gt;render callback&lt;/li&gt;
&lt;li&gt;function as child&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 방법은 함수를 갖는 props를 값으로서 전달하여 사용하는 방식이다.&lt;/p&gt;
&lt;p&gt;이를 통하여 서로 다른 두개의 컴포넌트를 분리된(decouppled) 상태에서 데이터 교환이 용이하게 한다.&lt;/p&gt;
&lt;p&gt;그렇다면 props.render와 props.children은 무엇이 다른가?&lt;/p&gt;
&lt;p&gt;사실상 하는 기능은 동일하다. 단지 다른 사용 방법을 가지고 있을 뿐이다.&lt;/p&gt;
&lt;p&gt;조금 더 컴팩트하고 명시적으로(props.render) 작성하냐, 혹은 구조적으로 짜임새 있게(props.children) 작성 하냐의 차이인것 같다 .&lt;/p&gt;
&lt;h3&gt;HOC는&lt;/h3&gt;
&lt;p&gt;higher order component이다&lt;/p&gt;
&lt;p&gt;감싸질 컴포넌트를 감싸는 컴포넌트로 넣어 주어 감싸진 컴포넌트를 반환하는 방식이다.&lt;/p&gt;
&lt;p&gt;어떻게 보면 FP에서 currying 과 유사한 패턴이라 보면 될것 같다. (난중에 확인)&lt;/p&gt;
&lt;p&gt;주로 초기값을(컴포넌트 기준으로는 대부분 props) 해당 컴포넌트에 전달하는 역할을 한다.&lt;/p&gt;
&lt;p&gt;또는, 컴포넌트에 따라, 상황에 따라 다른 view를 랜더링하기 위한 wrap로도 사용되는 것 같다.&lt;/p&gt;
&lt;p&gt;단점으로는,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;사용에 너무 많은 코드를 작성해야 한다.&lt;/li&gt;
&lt;li&gt;props 이름의 중복이 될 수 있다. (아래 서술)&lt;/li&gt;
&lt;li&gt;다수의 HOC를 합성하면, props가 어디에서 부터 온 것인지 알기 힘들어진다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;그래서 둘중에 무엇을 왜 사용해야 하는가&lt;/h3&gt;
&lt;p&gt;결국에는 &lt;strong&gt;cross-cutting concerns&lt;/strong&gt;에 대처하기 위해 사용된다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;잠깐, cross-cutting concerns이 뭔데?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;**cross-cutting concerns는 쉽게 생각하여, 반복적으로 나오는 코드를 뜻한다.**

조금 더 자세히 얘기하면,

A **Concern** is a term that refers to a part of the system divided on the basis of the functionality.

즉, Concern은 기능을 기준으로 나뉘어진 시스템의 일 부분이다. (관심사라 직역 되지만, 관심을 가져야 할 부분으로 읽는게 나을듯 하다.)

이 관심을 갖는 기능들을 한대 관통하는 기능. 즉 여러번 사용될 수 있는 기능에 대한 고려를 의미하는 듯 하다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/23700540/cross-cutting-concern-example&quot;&gt;출처&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;즉, 반복적으로 같은 패턴으로 사용된 기능을 제작하기 위해 위 두 기능을 사용한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;보통, 이 공통의 관심사를 HOC를 통해 구현하곤 했다. 하지만, 위에 서술한 HOC의 단점들이 존재하여 이를 해결 할 render props를 활용하여 공통의 관심사를 구현한다.&lt;/p&gt;
&lt;h3&gt;HOC → render props 패턴으로 갈경우&lt;/h3&gt;
&lt;p&gt;우리는 props에 의해 변수를 덮어 쓸 걱정을 안해도 된다.&lt;/p&gt;
&lt;p&gt;생각해보면, component에서 props를 통해 넘어가는 값은 객체와 같다.&lt;/p&gt;
&lt;p&gt;따라서, state 값을 넘겨주면 key, value에 따라 props로 넘어 가는 것이다.&lt;/p&gt;
&lt;p&gt;이는 또 달리 말하여 두 컴포넌트에 공통된 규칙을 따라야 하므로 종속성이 강해 진다 할 수 있다.&lt;/p&gt;
&lt;p&gt;(정확히 같은 변수명을 사용 해야 하고, 변수명 충돌을 방지 해야 한다)&lt;/p&gt;
&lt;p&gt;반면, render와 같은 방법으로 함수를 통해 compose하게 된다면,&lt;/p&gt;
&lt;p&gt;특정된 key를 통해 value를 참조 하는게 아닌, 넘어오는 인자를 통해 접근이 가능하다.&lt;/p&gt;
&lt;p&gt;즉, 인자의 순서만 맞춘다면 변수의 이름을 중복할 걱정이나, 변수명을 정확히 쓸 걱정을 안해도 된다.&lt;/p&gt;
&lt;p&gt;따라서, 순서만 맞게 사용하면 되고, 이로 인해 조금 더 나은 분리가 가능하다&lt;/p&gt;
&lt;h2&gt;한줄 정리 :&lt;/h2&gt;
&lt;p&gt;대부분의 경우 HOC보다는 함수를 넘겨 받는 식으로 코드를 작성함이 더 나은 코드인것 같다.&lt;/p&gt;
&lt;p&gt;종속성을 줄이고, 코드양을 줄여 같은 기능을 제공할 수 있다면 이를 사용함이 맞다.&lt;/p&gt;
&lt;p&gt;그럼에도 불구하고 HOC가 사용되도 좋은 패턴은 여전히 존재한다. (db연결이나 redux store연결 등 다양하다)&lt;/p&gt;
&lt;p&gt;결국, 이 또한 상황에 맞게 융통성을 갖추어 사용하도록 하자.&lt;/p&gt;
&lt;p&gt;다음에는 어찌하여 React hooks가 위 HOC, render props를 대체할 수 있다 하는지 알아보겠다.&lt;/p&gt;
&lt;p&gt;레퍼런스&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.com/tandemly/im-breaking-up-with-higher-order-components-44b0df2db052&quot;&gt;I’m Breaking up with Higher Order Components. - tandemly - Medium&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Just Enough Functional Programming - 3탄]]></title><description><![CDATA[공부 이유 : 요즘 functional programming과 reactive programming을 학습하며 다양한 Intro 강의들을 찾아 학습하고 있다. 그 중에서 오랜만에 깔끔하고 잘 만들어진 강의가 있어 정리해 보았다. [Just Enough…]]></description><link>https://sukjae.github.io/daily-study/daily/2019-07-11/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/daily/2019-07-11/</guid><pubDate>Thu, 11 Jul 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;공부 이유 :&lt;/h2&gt;
&lt;p&gt;요즘 functional programming과 reactive programming을 학습하며 다양한 Intro 강의들을 찾아 학습하고 있다. 그 중에서 오랜만에 깔끔하고 잘 만들어진 강의가 있어 정리해 보았다. &lt;a href=&quot;https://egghead.io/courses/just-enough-functional-programming-in-javascript&quot;&gt;[Just Enough Functional Programming in JavaScript]&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;공부 내용 :&lt;/h2&gt;
&lt;p&gt;강의에서 강사는 말 그대로 Functional Programming을 바로 사용할 수 있을 정도의 적당한 레벨의 지식을 전달한다. 전체적인 느낌을 보기도 좋고, 실무에 부분 부분 적용 해 보기도 좋은 것 같다. &lt;/p&gt;
&lt;h3&gt;CH9. Improve JavaScript Function Usability with Proper Argument Order in Functional Programming&lt;/h3&gt;
&lt;p&gt;이번 강의에서는 FP의 원칙을 따라 인자들의 전달 순서를 정하는 방법에 대해 논한다. &lt;/p&gt;
&lt;p&gt;전달될 인자를 특정한 순서로 제공 함으로써 다음과 같은 장점을 얻을 수 있다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;partial application 가 주는 장점들&lt;/li&gt;
&lt;li&gt;improve reusability&lt;/li&gt;
&lt;li&gt;enable composition of functions&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;우리는 인자 전달 방식중에 &lt;strong&gt;데이터를 항상 마지막에 전달&lt;/strong&gt;하는 방법에 대해 논할것이다 .&lt;/p&gt;
&lt;p&gt;이를 통하여 하나의 함수의 연산 결과가 다른 함수의 인자로 연결되는 것을 가능하게 할것이다. &lt;/p&gt;
&lt;p&gt;다음 예시와 같은 함수의 형태에서는 partial applied function을 생성할 수 없다. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;    &lt;span class=&quot;token comment&quot;&gt;// Argument Order&lt;/span&gt;
    
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;cb&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; array&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; array&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;cb&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 예를 curried function으로 바꿔주면 아래와 같이 된다. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;    &lt;span class=&quot;token comment&quot;&gt;// Argument Order&lt;/span&gt;
    
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;array&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;cb&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; array&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;cb&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; arr &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; n &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt; 
    
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; withArr &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;arr&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;withArr&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;double&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;withArr&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; n &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 예시에서 우리는 data를 고정하고 callback의 변화를 주며 함수를 호출 하였다. &lt;/p&gt;
&lt;p&gt;즉, curried function으로 생성된 함수에서 우리가 의미있는 변화를 줄 수 있는 부분은 callback function이 유일하다. (값은 고정, 더블, 트리플 등등)&lt;/p&gt;
&lt;p&gt;위 방법으로 할바엔 array에 직접적으로 map 함수를 호출함이 낫다&lt;/p&gt;
&lt;p&gt;만약 우리가 callback을 먼저 받고, array를 나중에 받는면 더 나은 curried function 유틸을 제공할 수 있다. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; map &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;cb&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;token parameter&quot;&gt;array&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; array&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;cb&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; arr &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; n &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt; 
    
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; withDouble &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;double&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;withDouble&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;arr&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;withDouble&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;curried function의 인자의 순서를 결정할 때는 가장 구제척(specific) 인것 부터 덜 구체적인 인자 순서로 전달하면 된다. &lt;/p&gt;
&lt;p&gt;덜 구체적인 인자는 항상 언어의 원시 타입이다. (불리언, 행렬, 숫자, 객체 등)&lt;/p&gt;
&lt;p&gt;다음과 같은 예시를 살펴 보자&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;    &lt;span class=&quot;token comment&quot;&gt;// Most specific =&gt; least specific &lt;/span&gt;
    
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;prop&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; obj&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;key&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;만약 위 예시에서, key와 obj의 순서를 바꿔 주었다면, obj(key)와 같은 형태가 될테데 이는 obj[key]를 직접 호출하는것과 하등 차이가 없다. &lt;/p&gt;
&lt;p&gt;반면, 위와 같은 순서로 인자를 전달 함으로서, 우리는 공통의 key를 사용 하여 obj 를 탐색할 수 있다.&lt;/p&gt;
&lt;p&gt;위의 map 함수와 prop그리고 data(array)를 조합하여 다음과 같은 기능을 제공할 수 있다. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;    &lt;span class=&quot;token comment&quot;&gt;// Most specific =&gt; least specific &lt;/span&gt;
    
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;prop&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; obj&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;key&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
    
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; propName &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;prop&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;name&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; people &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; name&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Jamon&apos;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; name&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Shirley&apos;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; name&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Kent&apos;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; name&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Sarah&apos;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; name&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Ken&apos;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
    
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;propName&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;people&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// [ &apos;Jamon&apos;, &apos;Shirley&apos;, &apos;Kent&apos;, &apos;Sarah&apos;, &apos;Ken&apos; ]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;CH10. Using the Associative Property in JavaScript Functional Compositions&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Associative Property란 결합 법칙을 뜻한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Functional Compositions란 합성 함수를 뜻한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이번에는 FP에서 수학적인 결합법칙과 동등한 방식으로 곱셈이나 덧셈에서의 결합이 결과값에 영향을 미치지 않고 합성 함수에 적용되는지 보여줄 것이다. 또한 작은 합성(composition)의 조합으로 같은 큰 합성과 같은 역할을 하는지 보여줄 것이다. &lt;/p&gt;
&lt;p&gt;정리하자면, 같은 연산자들이 나열 되었을때, 우리가 조합하는 방식이 결과에 영향을 주지 않는다. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;    &lt;span class=&quot;token comment&quot;&gt;// Associative Property&lt;/span&gt;
    
    &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;
    &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;같은 방식은 합성 함수에도 적용 된다. &lt;/p&gt;
&lt;p&gt;앞서 들었던 예시에서 만들었던 &lt;code class=&quot;language-text&quot;&gt;compose&lt;/code&gt; 함수를 다르게 합성 하여도 연산의 결과는 같아질 것이다. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;    &lt;span class=&quot;token comment&quot;&gt;// Associative Property&lt;/span&gt;
    
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; withExuberance &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;compose&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
      repeat&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; 
      exclaim&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; 
      scream
    &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; str &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;I love egghead&apos;&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;withExuberance&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;str&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 예시에서 같은 기능을 제공하기 위해 부분 합성(sub-compositions)을 만들어볼 수 있다. 그럼에도 위와 같은 결과를 제공한다. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;    &lt;span class=&quot;token comment&quot;&gt;// ((repeat,exlaim),repeatExcitedly)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; repeatExcitedly &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;compose&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
      repeat&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; 
      exclaim
    &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;token function&quot;&gt;compose&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
        repeatExcitedly&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        scream 
      &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;str&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    
    &lt;span class=&quot;token comment&quot;&gt;// (repeat,(exclaim,scream))&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; screamLoudly &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;compose&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
      exclaim&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; 
      scream
    &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;token function&quot;&gt;compose&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
        repeat&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; 
        screamLoudly
      &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;str&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;순수 함수로 짜여진 코드에서 연산의 순서만 지킨다면, 어떠한 부분 함수를 하여도 연산의 결과는 같아 질 것이다. &lt;/p&gt;
&lt;h3&gt;CH11. Debug Functional Compositions with a Logging Side Effect in JavaScript&lt;/h3&gt;
&lt;p&gt;FP에서 함수를 합성하는 작업은 필연적으로 불투명한 과정을 포함한다. &lt;/p&gt;
&lt;p&gt;이 뜻은 함성 함수를 활용하는 과정에서 data의 변화를 가시화 할 수 있는 명확한 방법이 존재하지 않는다는 것이다. 생각해보면 여러개의 함수를 합성하여 결과값을 딱 내놓는 과정에서, 순차적인 data의 흐름을 명확하게 보기 어려움이 당연하다. &lt;/p&gt;
&lt;p&gt;이러한 특징은 잘 작동할때는 상관이 없지만, 디버깅 하기 어렵다는 단점이 있다. &lt;code class=&quot;language-text&quot;&gt;trace&lt;/code&gt; 함수와 같은 기능을 제공하여 우리는 pointfree programming를 지속하며 합성의 과정을 볼 수 있다. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Tacit programming, also called point-free style, is a programming paradigm in which function definitions do not identify the arguments (or “points”) on which they operate.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;trace&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;msg&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 &lt;code class=&quot;language-text&quot;&gt;trace&lt;/code&gt; 함수는 msg와 curry의 결과로 넘겨받은 현재의 인자를 인자로 받는다. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; bookTitles &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
      &lt;span class=&quot;token string&quot;&gt;&apos;The Culture Code&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token string&quot;&gt;&apos;Designing Your Life&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; 
      &lt;span class=&quot;token string&quot;&gt;&apos;Algorithms to Live By&apos;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
    
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;trace&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;msg&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; slugify &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;compose&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;token function&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;-&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token function&quot;&gt;trace&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;after lowercase&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token function&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;lowerCase&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token function&quot;&gt;trace&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;after split&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token function&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos; &apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token function&quot;&gt;trace&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;before split&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; slugs &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;slugify&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;bookTitles&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;slugs&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 예시에서 join과 map의 순서과 우리의 예상과는 달랐고, 그 결과 예상치 못한 답이 나왔다고 생각 해 보자. &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;trace&lt;/code&gt;  함수는 curried function으로서 두번의 인자를 받는다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;첫번째 호출시 인자는 이 &lt;code class=&quot;language-text&quot;&gt;trace&lt;/code&gt;  함수가 갖게 될 메시지로서 데이터의 흐름에 포함되어 있지 않은 정보라 생각하면 될거 같다.&lt;/li&gt;
&lt;li&gt;두번재 호출시 받는 인자는 어떤 값으로서 사실상 모든 값이 들어갈 수 있다. 이 값은 console.log에 찍히게 될 것 이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;여기에서 만약 우리가 다음과 같이 작성 하였다면, 매 순간 msg와 x를 명시해서 넘겨줘야 하기 때문에 코드가 훨씬 장황해질 것이다. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;trace&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;msg&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;x&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;msg&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;따라서 FP에서 compose의 기능을 잘 활용하여 인자(data)를 물 흐르듯이 넘겨주는 상상을 해보도록 하자.&lt;/p&gt;
&lt;h2&gt;한줄 정리 :&lt;/h2&gt;
&lt;p&gt;절대적인 것은 없다! 모든지 상황에 맞춰 융통성 있게, 재밌게 작성하자!&lt;/p&gt;
&lt;p&gt;이것으로 &lt;strong&gt;Just Enough Functional Programming&lt;/strong&gt; 정리가 모든 끝났다. 이제 FP에 관하여 껍질을 햝은 정도의 느낌을 받은 것 같다. 천천히 점진적으로 학습하여 FP와 FRP 등의 패러다임의 아이디어를 내 것으로 만들도록 하겠다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[스크럼과 XP (헨릭 크니버그) 나머지 절반을 읽고...]]></title><description><![CDATA[…]]></description><link>https://sukjae.github.io/daily-study/daily/2019-07-10/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/daily/2019-07-10/</guid><pubDate>Wed, 10 Jul 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;공부 이유 :&lt;/h2&gt;
&lt;p&gt;처음 스크럼이란 용어를 아틀란시안 지라를 보며 알게 되었다. 혼자만 학습하고 개발하다보니 사람들은 어떻게 협업을 할까 라는 호기심이 생겨 지라를 찾아 보았다. 그러다 애자일과 관련하여, 또 여러 개발기 등에서 스크럼이란 용어가 많이 보여 조금 더 알아보기 위해 책을 읽기 시작했다.&lt;/p&gt;
&lt;h2&gt;공부 내용 :&lt;/h2&gt;
&lt;h3&gt;특화 팀을 둘 것인가 말 것인가? (p136)&lt;/h3&gt;
&lt;p&gt;만약 3티어 아키텍쳐를 갖은 서비스가 있다고 가정하자. (client, server, database)&lt;/p&gt;
&lt;p&gt;여기에서 우리는 팀을 어떻게 나눌 수 있을까&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;컴포넌트 특화팀&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;‘클라이언트 팀’, ‘서버 팀’, ‘DB 팀’ 처럼 컴포넌트 특화 팀으로 만드는 방법이다.&lt;/p&gt;
&lt;p&gt;이 방법의 가장 큰 문제는 대부분의 스토리들이 여러 컴포넌트에 걸쳐 있다는 점이다.&lt;/p&gt;
&lt;p&gt;여러 컴포넌트에 걸쳐 있으니 각각의 컴포넌트 팀이 하나의 기능을 위해 협력 해야 하고, 이로 인해 지연이 발생할 수 있다 .&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;교차 컴포넌트 팀&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;스토리를 기준으로 팀을 나누어 독립적으로 운영한다.&lt;/p&gt;
&lt;p&gt;각 팀이 fullstack 구성원을 포함해야 하는 어려움이 있겠지만, 가장 좋은 방법 이다&lt;/p&gt;
&lt;h3&gt;스크럼의 핵심 주제는…(p171)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;스크럼의 핵심 주제는 &lt;strong&gt;‘관찰하고 적응하라’&lt;/strong&gt;다. 개발은 필연적으로 학습과 혁신, 깨우침을 동반하기 때문에, 스크럼은 개발 주기를 짧게 가져감으로써 개발된 제품과 현재 일하는 방식의 효능을 관찰하고 제품의 목표와 프로세스 실천법들을 조정해 적응할 것을 강조한다. 이 과정이 끝없이 이어진다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;한줄 정리 :&lt;/h2&gt;
&lt;p&gt;결론적으로, 스크럼 또한 인간이라는 한계를 인지하며 어느정도 융통성 있게 적용해야 한다. 절대적인 방법이 아닌 팀에 따라 다르게 적용할 수 있는 프레임워크임을 꼭 기억하자.
주기를 짧게!
항상 관찰하고 정응하며 발전하자!&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Just Enough Functional Programming - 2탄]]></title><description><![CDATA[공부 이유 : 요즘 functional programming과 reactive programming을 학습하며 다양한 Intro 강의들을 찾아 학습하고 있다. 그 중에서 오랜만에 깔끔하고 잘 만들어진 강의가 있어 정리해 보았다. [Just Enough…]]></description><link>https://sukjae.github.io/daily-study/daily/2019-07-09/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/daily/2019-07-09/</guid><pubDate>Tue, 09 Jul 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;공부 이유 :&lt;/h2&gt;
&lt;p&gt;요즘 functional programming과 reactive programming을 학습하며 다양한 Intro 강의들을 찾아 학습하고 있다. 그 중에서 오랜만에 깔끔하고 잘 만들어진 강의가 있어 정리해 보았다. &lt;a href=&quot;https://egghead.io/courses/just-enough-functional-programming-in-javascript&quot;&gt;[Just Enough Functional Programming in JavaScript]&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;공부 내용 :&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;이번 정리는 앞선 &lt;a href=&quot;https://github.com/sukjae/daily-study/blob/master/2019-07-08.md&quot;&gt;Just Enough Functional Programming - 2탄&lt;/a&gt;에 이어지는 내용이다. 순서는 상관 없지만 미리 읽어보길 바란다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;강의에서 강사는 말 그대로 Functional Programming을 바로 사용할 수 있을 정도의 적당한 레벨의 지식을 전달한다. 전체적인 느낌을 보기도 좋고, 실무에 부분 부분 적용 해 보기도 좋은 것 같다.&lt;/p&gt;
&lt;h3&gt;CH6. Create Reusable Functions with Partial Application in JavaScript&lt;/h3&gt;
&lt;p&gt;partial application을 이용하여 고정 인자를 갖은 재사용 가능한 함수를 만드는게 이번 챕터의 목적이다. 동일한 함수를 분산된 코드들에서 범용적으로 사용할 수 있는 의미의 재사용 이라기 보다는, 미시적으로 반복되어 사용될 수 있는 함수를 만든다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This lesson teaches you how arguments passed to a curried function allow us to store data in closure to be reused in our programs and applications.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Partial Application:&lt;/strong&gt;
In computer science, partial application (or partial function application) refers to the process of fixing a number of arguments to a function, producing another function of smaller &lt;strong&gt;arity&lt;/strong&gt;.
즉, 인자중 일부를 고정하여 낮은 항수를 갖는 함수를 생성하는 것 이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;예시,&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// Partial Application&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; fetch &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;node-fetch&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;getFromAPI&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;baseURL&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;endpoint&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; cb⇒ &lt;span class=&quot;token function&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;baseURL&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;endpoint&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; res&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;cb&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;data&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;err&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;message &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; getGithub &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getFromAPI&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;https://api.github.com&apos;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; getGithubUsers &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getGithub&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;/users&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; getGithubRepos &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getGithub&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;/respositories&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위와 같이 전달된 함수는 동일한 조건으로 여러번 사용될 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token function&quot;&gt;getGithubUsers&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;data&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; user&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;login&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;getGithubUsers&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;data&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; user&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;avatar_url&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;여기서 또한 눈여겨 볼 점은, 함수의 끝에 행하는 연산을 함수를 정의할 때 제공한게 아니라 함수가 생성된 뒤 제공했다는 점인것 같다.&lt;/p&gt;
&lt;p&gt;즉, 우리는 어떤 특정한 값들의 흐름에 대하여 어떤 행동을 취할 것인지 나중에 고려할 수 있다.&lt;/p&gt;
&lt;h3&gt;CH7. Eliminate Anonymous JavaScript Functions with Pointfree Programming&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;This lesson teaches you what pointfree programming is, passing a named function as an argument to avoid writing an anonymous function with interim(임시의) variables instead.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이름을 갖은 함수(named function)을 인자로서 전달 함으로서 익명 함수를 제공함을 피한다. 이러한 방식은 다음과 같은 장점들을 갖고 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Pointfree programming increases code legibility, decreases the surface area for bugs, and makes our code more composable and unit testable.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;결국, 다음과 같은 코드를 변화 시키는 것을 뜻 한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// Pointfree Programming&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; array &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
array&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// into&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; array &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;
array&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;double&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// Legibility&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위에 언급 되었듯이, 우리는 로직을 분리 함으로서 가독성에서 이득을 챙길 수 있었다.&lt;/p&gt;
&lt;p&gt;또한, 우리는 unit test를 보다 쉽게, 세부적으로 진행할 수 있게 되었다.&lt;/p&gt;
&lt;p&gt;다만, 내 생각에는 모든 함수를 다음과 같이 분리 할 필요가 있을까 싶다. 이것은 조금 더 고민 해 봐야 겠다.&lt;/p&gt;
&lt;h3&gt;CH8. Build Up Complex Functionality by Composing Simple Functions in JavaScript&lt;/h3&gt;
&lt;p&gt;FP에서 composition(합성)은 매우 중요한 패턴이다. 이러한 합성은 우리가 수학 시간에 배운 합성과 동일하게 적용 된다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Composition is the act of combining these functions so that the output of one becomes the input of the next one.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// Composition&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그러나, 이렇게 함수를 중첩하여 호출하는 방식은 쉽게 성가시게 된다. 다음 예시를 보자. 우리는 순차적인 작업을 위해서 아래처럼 함수를 중첩하여 호출하게 된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// Composition&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;scream&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; str&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;toUpperCase&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;exclaim&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;str&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;repeat&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;str&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt; &lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;str&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;repeat&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;exclaim&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;scream&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;I love egghead&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이를 해결할 방법 중 하나가 HOF이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A better way to do this would be to create a higher-order function that can accept any number of functions as arguments, and create a composition out of them.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;아래와 같이 함수들을 인자로 넘겨받는 &lt;code class=&quot;language-text&quot;&gt;compose&lt;/code&gt; 함수를 생성 함으로서 위의 기능을 똑같이 재현할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;여기서 또 중요한 부분은, 위의 partial application의 예시와 비슷하게 연산에 사용될 함수를 생성 이후에 전달하는 패턴을 사용 했다는 것이다&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;compose&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;fns&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; fns&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;reduceRight&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;acc&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; fn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;acc&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; withExuberance &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;compose&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;repeat&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; exclaim&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; scream&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;withExuberance&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;I love egghead&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 예시에서 인자로 전달되는 함수는 우측에서 좌측으로 순차적으로 제공된다. 이는 수학에서 합성을 할때 내부→외부로 순차적으로 시행한는것과 동일한 논리이다.&lt;/p&gt;
&lt;p&gt;그러나, Ramda and Lodash/FP 등과 같이 FP 코드를 작성하는데 도움을 주는 라이브러리 들은 좌측→우측으로 시행하기도 하니 주의하자.&lt;/p&gt;
&lt;h2&gt;한줄 정리 :&lt;/h2&gt;
&lt;p&gt;소프트웨어를 작성함에 있어 100% FP를 준수하며 작성할 수 없다. (console.log를 사용할 수 없는 상황이 얼마나 개발의 효율을 떨어트릴 수 있을지는 상상에 맡긴다…ㅋ)&lt;/p&gt;
&lt;p&gt;결국 FP의 방법을 왜 사용하는지를 잘 생각하며 FP와 impure function을 잘 분리하여 프로그래밍 해야 한다.&lt;/p&gt;
&lt;p&gt;(예를 들어 FP와 RP를 합쳐 FRP를 만든다던지…ㅎㅎ)&lt;/p&gt;
&lt;p&gt;절대적인 것은 없다! 모든지 상황에 맞춰 융통성 있게, 재밌게 작성하자!&lt;/p&gt;
&lt;p&gt;내일은 나머지 부분에 대한 정리를 하겠다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Just Enough Functional Programming - 1탄]]></title><description><![CDATA[공부 이유 : 요즘 functional programming과 reactive programming을 학습하며 다양한 Intro 강의들을 찾아 학습하고 있다. 그 중에서 오랜만에 깔끔하고 잘 만들어진 강의가 있어 정리해 보았다. [Just Enough…]]></description><link>https://sukjae.github.io/daily-study/daily/2019-07-08/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/daily/2019-07-08/</guid><pubDate>Mon, 08 Jul 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;공부 이유 :&lt;/h2&gt;
&lt;p&gt;요즘 functional programming과 reactive programming을 학습하며 다양한 Intro 강의들을 찾아 학습하고 있다. 그 중에서 오랜만에 깔끔하고 잘 만들어진 강의가 있어 정리해 보았다. &lt;a href=&quot;https://egghead.io/courses/just-enough-functional-programming-in-javascript&quot;&gt;[Just Enough Functional Programming in JavaScript]&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;공부 내용 :&lt;/h2&gt;
&lt;p&gt;강의에서 강사는 말 그대로 Functional Programming을 바로 사용할 수 있을 정도의 적당한 레벨의 지식을 전달한다. 전체적인 느낌을 보기도 좋고, 실무에 부분 부분 적용 해 보기도 좋은 것 같다. &lt;/p&gt;
&lt;h3&gt;CH2. Modify Functions with Higher Order Functions in JavaScript&lt;/h3&gt;
&lt;p&gt;우선 HOF는 다음과 같은 특징을 갖고 있다&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// Higher Order Functions

// 1. 함수를 인수로서 받을 수 있다 (Accepts a function as an argument)
// 2. 새로운 함수를 반환할 수 있다 (Returns a new function)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;강사는 이 HOF를 다음과 같은 코드로 보여주고 있다. &lt;/p&gt;
&lt;p&gt;코드를 해석하면 다음과 같다. &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;count라는 공용 변수를 설정하였다. 이는 클로져 덕분에 가능하다.&lt;/li&gt;
&lt;li&gt;함수를 execute 함과 동시에 초기화를 해 주었다. &lt;/li&gt;
&lt;li&gt;초기화를 진행하며 연산에 쓰일 함수를 전달 하였는데, 이 부분이  FP에서 매우 중요한 생각의 흐름이다.&lt;/li&gt;
&lt;li&gt;execute되 함수를 새로운 변수에 할당하여, 이 함수를 여러번 재사용 한다. &lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;withCount&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; count &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;
    
      &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;args&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;Call count: &lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;count&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;x&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; y&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; y
    
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; countedAdd &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;withCount&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;add&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;countedAdd&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;countedAdd&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;countedAdd&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;CH3. Avoiding Mutations in JavaScript with Immutable Data Structures&lt;/h3&gt;
&lt;p&gt;우선, mutable 과 immutable 한 data는 다음과 같은 차이점을 보이고 있다. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// Immutable Data

// Mutable = can be changed after creation 
// Immutable = can&amp;#39;t be changed after creation&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;FP에서 data 를 mutate하는 것은 안티패턴으로 여겨 지는데 이는 “breaks the purity of our functions”하기 때문이다. &lt;/p&gt;
&lt;p&gt;우리는 이를 방지 하기 위해(순수성을 께버리는 것을) 기존의 상태와 새로운 상태를 모두 포함하는 새로운 데이터를 반환한다. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;return brand new data structures that contain all the elements of the previous state of the data structure, plus our updates&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;다음과 같은 예를 생각 해 보자 .&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;    &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;MutableGlass&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token function&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;content&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; amount&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;content &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; content
        &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;amount &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; amount 
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    
      &lt;span class=&quot;token function&quot;&gt;takeDrink&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;amount &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Math&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;amount &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; value&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; mg1 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;MutableGlass&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;water&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; mg2 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; mg1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;takeDrink&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;mg1 &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; mg2&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;mg1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;amount &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; mg2&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;amount&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    
    &lt;span class=&quot;token comment&quot;&gt;//true &lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;//true&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;당연한 결과다. 하나의 생성자를 통해 생성된 인스턴스를 공유하고 있고, 동일한 인스턴스 내에 종속된 변수를 직접 건드렸고, 결과 적으로 동일한 값이다(동일한 객체이기도 하다).&lt;/p&gt;
&lt;p&gt;위와 같은 패턴은 사실 OOP에서 많이 사용되는데, 이를 FP 스타일로 변경하기 위해 완전히 새로운 인스턴스를 매 호출마다 반환하면 된다. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;    &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ImmutableGlass&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token function&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;content&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; amount&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;content &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; content
        &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;amount &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; amount
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    
      &lt;span class=&quot;token function&quot;&gt;takeDrink&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ImmutableGlass&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;content&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; Math&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;amount &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; value&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이 부분에서 나는 이 패턴이 좋은 방법 인지는 모르겠다. 단지 하나의 metaphor로서 FP의 느낌을 이해하는데 도움을 줄 뿐이다. &lt;/p&gt;
&lt;p&gt;내 생각에 이 부분에서 다음과 같은 방식이 더 깔끔할 것 같다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;method를 포함한 객체 전체를 반환하기 보다 값만 반환하여 가지고 놀던지&lt;/li&gt;
&lt;li&gt;아예 처음부터 생성자를 두번 사용해서 서로 다른 인스턴스를 만들던지&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;CH4. Refactor a Function to Use Currying in JavaScript&lt;/h3&gt;
&lt;p&gt;Currying은 앞서 작성한 글에 내 생각 대부분이 적혀 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;초기화한 함수를 공유하는데 도움이 되고&lt;/li&gt;
&lt;li&gt;다항 연산자를 받는 함수에서 항수를 낮춰 단항으로 낮출 수 있고&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;등등&lt;/p&gt;
&lt;p&gt;이 강의에서 Arity 라는 개념이 언급되는데 이는 항수로서 함수의 인자나 연산자의 개수를 말한다. 이 arity의 개수에 따라 다음과 같이 분류 되며&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// 1. unary
// 2. binary 
// 3. ternary 
// 4. quaternary&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;결국 currying의 목표 중 하나는 다음과 같다고 할 수 있다. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Thus the act of currying can be described as taking a multivariate function and turning it into a series of unary functions.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;CH5. Identify Side Effects by Comparing Pure and Impure JavaScript Functions&lt;/h3&gt;
&lt;p&gt;강의에서 순수함수에 대한 언급이 나온다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A pure function is a function that derives its output solely from its inputs, and causes no side effects in the application or outside world. The most common pure functions people have encountered are mathematical functions.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;즉 우리가 수학에서 말하는 함수가 순수 함수라 보면 된다. &lt;/p&gt;
&lt;p&gt;여기서 강사는 순수하지 않은 함수 (Impure function)들에 대한 예시를 제공한다. &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;함수가 연산을 수행할 때 받은 인자(input) 이외의 것에 영향을 받는 경우&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
    
    &lt;span class=&quot;token comment&quot;&gt;// Ex 1 - Global State &lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;COST_OF_ITEM&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;19&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;cartTotal&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;quantity&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt;
      &lt;span class=&quot;token constant&quot;&gt;COST_OF_ITEM&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; quantity 
    
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;cartTotal&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//38&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;cartTotal&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//38&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 코드에서 함수 f는 순수 함수이다. &lt;/p&gt;
&lt;p&gt;함수 cartTotal 또한 순수 함수라 오해하기 쉽고, 나는 다음과 같은 이유로 오해를 하였다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;함수 cartTotal 는 연산을 수행하기 전후로 외부에 side effect를 만들지 않는다.&lt;/li&gt;
&lt;li&gt;외부 인자가 있긴 하지만 const로 불변한 데이터이기 때문에 순수함수의 정의에서 벗어나지 않을것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;그러나 함수 cartTotal는 순수하지 않은 함수이다. 그 이유는 input이외의 다른 외부 요인으로 부터 연산의 결과가 영향을 받기 때문이다. &lt;/p&gt;
&lt;p&gt;만약 위 코드에서 외부 변수 COST&lt;em&gt;OF&lt;/em&gt;ITEM의 값을 다음과 같이 바꿨다고 가정하자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;COST_OF_ITEM&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;17&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;cartTotal&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;quantity&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt;
      &lt;span class=&quot;token constant&quot;&gt;COST_OF_ITEM&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; quantity 
    
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;cartTotal&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//34&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;cartTotal&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//34&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;함수의 인자와 함수 자체에 변화는 없었지만, 결과적으로 연산의 결과가 달라졌다. &lt;/p&gt;
&lt;p&gt;그러므로 impure function이다. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 같은 input을 받았음에도 서로 다른 output을 return하는 함수 또한 순수하지 않은 함수이다.&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;이 예는 명료하다. 매 순간 랜덤한 값을 반환 하였으므로 impure하다. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;    &lt;span class=&quot;token comment&quot;&gt;// Ex 2 - Same input, different output &lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;generateID&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt;
      Math&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;floor&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;Math&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;generateID&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;generateID&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;generateID&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 예를 조금 더 발전 시켜 햇갈리게 만들면 다음과 같다. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;    &lt;span class=&quot;token comment&quot;&gt;// Ex 2 - Same input, different output &lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;generateID&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt;
      Math&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;floor&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;Math&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;createUser&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;name&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; age&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      id&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;generateID&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      name&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      age
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;createUser&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;Kyle&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;33&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;createUser&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;Kyle&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;33&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;createUser&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;Kyle&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;33&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;첫번째 예시와 흡사 하지만, 위 예는 다른 상황을 가정한 것이다. &lt;/p&gt;
&lt;p&gt;조금 더 현실적이고 실무에서 접할 법한 예시이다. &lt;/p&gt;
&lt;p&gt;random은 무시하고, rest api에 이름 kyle, 나이 33의 유저를 가져오는 요청을 보냈다고 하자. &lt;/p&gt;
&lt;p&gt;id는 unique할 수 있지만, 이름과 나이는 중복될 수 있다. 그러므로 위 요청은 매 요청마다 서로 다른 반환값을 제공 할 것이므로 impure하다. &lt;/p&gt;
&lt;p&gt;이 예시를 통해 우리는 async한 요청을 하는 함수는 대부분 impure 하다는 것을 느낄 수 있다. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 함수가 함수 밖의 애플리케이션에 side effect를 일으켜도 순수하지 않는 함수가 된다.&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;이 예는 함수 외부의 변수에 접근하여 해당 변수에 변화를 일으키는 예시를 생각 해 볼 수 있다. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;    &lt;span class=&quot;token comment&quot;&gt;// Ex. 3 - Side Effects #1 &lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; id &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; 
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;createFoodItem&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      id&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;id&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 여기서 발생!&lt;/span&gt;
      name
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;createFoodItem&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;Cheeseburgers&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;createFoodItem&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;Fries&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;createFoodItem&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;Milkshakes&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;id&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 예시를 더 생각 해 보면 매우 중요한 결론에 도달한다. &lt;/p&gt;
&lt;p&gt;결국, 함수를 compose하지 않고 상속을 한다던지 &lt;/p&gt;
&lt;p&gt;혹은 nested(중첩된) 함수를 사용하며 local valiable를 둔다던지(이 변수가 mutable/immutable인지는 중요치 않다. 존재하여 사용 되었다면 이미 impure가 되버린다.)&lt;/p&gt;
&lt;p&gt;등의 경우를 지양해야 한다. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 마지막으로 외부에 side effect를 이르키는 것 또한 impure한 function이다&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;위에서 외부의 변수를 건들이거나 사용하는 것을 뜻 하는게 아니다. &lt;/p&gt;
&lt;p&gt;우리가 흔히 사용하는 &lt;code class=&quot;language-text&quot;&gt;console.log&lt;/code&gt; 또한 외부에 side effect를 이르키는 함수 이다.&lt;/p&gt;
&lt;p&gt;매 순간 &lt;code class=&quot;language-text&quot;&gt;console.log&lt;/code&gt; 를 사용 함으로써 우리는 treminal에 영향을 준다. 비슷한 예시로 logger같은 것들이 있다. &lt;/p&gt;
&lt;h2&gt;한줄 정리 :&lt;/h2&gt;
&lt;p&gt;소프트웨어를 작성함에 있어 100% FP를 준수하며 작성할 수 없다. (console.log를 사용할 수 없는 상황이 얼마나 개발의 효율을 떨어트릴 수 있을지는 상상에 맡긴다…ㅋ)&lt;/p&gt;
&lt;p&gt;결국 FP의 방법을 왜 사용하는지를 잘 생각하며 FP와 impure function을 잘 분리하여 프로그래밍 해야 한다. &lt;/p&gt;
&lt;p&gt;(예를 들어 FP와 RP를 합쳐 FRP를 만든다던지…ㅎㅎ)&lt;/p&gt;
&lt;p&gt;절대적인 것은 없다! 모든지 상황에 맞춰 융통성 있게, 재밌게 작성하자!&lt;/p&gt;
&lt;p&gt;내일은 나머지 부분에 대한 정리를 하겠다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[SAGA의 필요성과 특징]]></title><description><![CDATA[공부 이유 : React에서 Redux를 사용하여Async한 로직을 관리할때 자주 쓰이는 라이브러리가 redux-thunk, redux-saga, 그리고 어쩌면 redux-observable(RXJS)등 이 있을것이다. redux에서 async…]]></description><link>https://sukjae.github.io/daily-study/daily/2019-07-07/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/daily/2019-07-07/</guid><pubDate>Sun, 07 Jul 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;공부 이유 :&lt;/h2&gt;
&lt;p&gt;React에서 Redux를 사용하여Async한 로직을 관리할때 자주 쓰이는 라이브러리가 redux-thunk, redux-saga, 그리고 어쩌면 redux-observable(RXJS)등 이 있을것이다.&lt;/p&gt;
&lt;p&gt;redux에서 async를 작업하는데 다른 라이브러리들이 많이 사용되는 이유는 redux가 가지고 있는 &lt;a href=&quot;https://redux.js.org/basics/data-flow&quot;&gt;strict unidirectional data flow&lt;/a&gt; 의 성질 때문이라 예상된다.&lt;/p&gt;
&lt;p&gt;이 중에서 redux-saga를 바라보며 SAGA패턴에 대해 많이 들어 본것 같지만, 제대로 이해하고 있지 않은것 같아 유튜브 강의를 활용하여 학습하였다.&lt;/p&gt;
&lt;h2&gt;공부 내용 :&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;시작하기 앞서, SAGA 패턴은 redux에만 적용 되는 것이 아니라 전반적이 소프트웨어 아키텍쳐에 적용된다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://youtu.be/YPbGW3Fnmbc&quot;&gt;Using sagas to maintain data consistency in a microservice architecture, Chris Richardson&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;위 영상에는 Chris Richardson 씨가 monolithic 에서 micro service로의 흐름과 이에 따라 필요하게 되는 transaction 관리에 대해 설명하고 있며, 위 영상의 내용을 정리하도록 하겠다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ACID is not an option&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Transaction을 생각할때, ACID에 대한 고려는 선택이 아닌 필수임을 강조하고 있다.&lt;/p&gt;
&lt;p&gt;예를 들어 우리가 은행에서 현금을 인출하는 Transaction을 수행할때, 인출액이 잔액을 넘을 수 없음은 당연하다.&lt;/p&gt;
&lt;p&gt;이러한 로직을 다음과 같은 트랙잭션 구성으로 상상 해 볼 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;begin transaction
...
select order-total
from orders where customer-id=?
...
select credit-limit
from customers where customer-id=?
...
insert into order...
...
commit transaction&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이러한 로직은 monolithic 한 application에서는 내장된 ACID 도구들을 통해 손쉽게 관리되며,&lt;/p&gt;
&lt;p&gt;같은 고객(현금을 인출하는 사람)에 대해서 요청되는 동시 다발적인 transaction들은 serialized되어 관리 될것이다.&lt;/p&gt;
&lt;p&gt;한 곳에서 transaction이 serialized 되기 때문에 관리가 편하다.&lt;/p&gt;
&lt;p&gt;반면, micro services 아키텍쳐 에서는 서비스 끼리 losely coupled되어 있고, 이로 더불어 data는 encapsulated 되어 있으며, 이로 인하여 분산된 서비스에 존재하는 데이터들 간의 consistency를 유지하는 작업이 어려워 진다.&lt;/p&gt;
&lt;p&gt;분산된 데이터들의 consistency를 위해 distributed 된 transaction 관리 도구가 필요하며 예시로는 2phase commit등과 같은 방법이 존재한다. 다만, 이는 현대적인 기술에서는 잘 사용되지 않는다 한다.&lt;/p&gt;
&lt;p&gt;이러한 distributed 된 service에서의 data consistency를 위해 SAGA가 나온다.&lt;/p&gt;
&lt;p&gt;SAGA가 처음에 나올 때 마이크로 서비스와 같이 분산 컴퓨팅을 고려하여 나온것은 아니지만, 이의 문제를 해결하기 적합한 구조이다.&lt;/p&gt;
&lt;p&gt;SAGA 를 micro services에 적용한다면, “sequence of local transaction”으로 가능하다.&lt;/p&gt;
&lt;p&gt;즉, 각각의 서비스가 각자의 local transaction이 존재하고, Transaction과 이에 compensating transaction 에 대한 역할또한 각각의 서비스에 위임한다.&lt;/p&gt;
&lt;p&gt;즉, 하나의 긴 transaction을 여러개의 Ti로 나누고, 이에 대응하는 Ci를 생성하므로서 rollback등과 같은 기능을 제공할 수 있는 것이다.&lt;/p&gt;
&lt;p&gt;그러나 이러한 SAGA 패턴은 1. API 설계를 복잡하게 한다. 2. Business logic을 복잡하게 한다. 와 같은 단점들이 존재한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;API 설계를 복잡하게 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;예를 들어 SAGA패턴을 접목한 micro services에서 request에 대한 response은 어떻게 제공 할것인가?&lt;/p&gt;
&lt;p&gt;보통의 경우, 서비스간에 통신을 할때, 상태에 따라서 즉각적인 http response를 status code와 함께 전달 한다.&lt;/p&gt;
&lt;p&gt;그러나 micro services에서는 즉각적인 response가 힘들 수 있는데, 이는 여러개의 transaction간의 관계가 있어 어느정도 시간이 걸리기 때문이다. 이에 대한 대응으로 두가지 정도를 생각 해 볼 수 있다.&lt;/p&gt;
&lt;p&gt;option-1 : 생성된 SAGA가 종료 되었을 때 response를 보낸다.&lt;/p&gt;
&lt;p&gt;가장 손쉬운 방법이며, 연산의 결과(out come)을 반환된 response에 포함하고 있기 때문에 바로 사용이 가능하다. 또한 이 방법은 근래의 빠른 네트워크 속도로 인하여 크지 않은 latency로 반환이 가능하다.&lt;/p&gt;
&lt;p&gt;그러나, 서비스가 대기하는 유휴시간이 생겨 가용성(availability)에 손해를 입게 되며, 이는 사실상 Cloud Computing이 발전하고 있는 요즈음 크나큰 손해로 다가올 수 있다.&lt;/p&gt;
&lt;p&gt;option-2 : SAGA 생성 후 바로 Response를 보냄(추천되는 방식)&lt;/p&gt;
&lt;p&gt;이 경우에 서버의 가용성이 커진다 할 수 있겠다.&lt;/p&gt;
&lt;p&gt;이 방법을 이용하면, 일단 response를 보내는데 이 response에는 outcome과 같은 정보는 포함되지 않으며 단지 전달 여부에 대해서만 제공한다.&lt;/p&gt;
&lt;p&gt;우리가 서버에 요청을 보낼 때 “내가 요청한 것이 잘 전달 되었니?” 와 “내가 요청한 것이 잘 처리 되었니?” 두가지 중 전자에만 관심을 갖는 것이다.&lt;/p&gt;
&lt;p&gt;나는 요청을 던져 놓고, 던져놓은 요청이 처리가 잘 되는지 여부를 전달받는 것이다.&lt;/p&gt;
&lt;p&gt;이러한 패턴에는 client가 out come에 대한 결과를 보기 위해 poll/notified 되어야 하며 이는 추가적인 기능 구현이 필요해 진다.&lt;/p&gt;
&lt;p&gt;그럼에도 불구하고 option-2의 방법은 다른 서비스들에 loosely coupled 되고 highly available 한 시스템을 만들 수 있기 때문에 선호 된다. 이는 cloud computing에서 큰 빛을 바라게 된다.&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Business logic을 복잡하게 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;option2 와 같은 방법을 이요하게 되면 추가적인 기능으로 인해 복잡성이 증가 하게 되는데, 예를 들어 order를 만들때 order를 만든 것은 알게 되지만, allow되었는지 deny 되었는지 확신할 수 없게 되며 pendding과 같은 제 3의 상태가 필요하게 된다.&lt;/p&gt;
&lt;h2&gt;한줄 정리 :&lt;/h2&gt;
&lt;p&gt;micro servies와 cloud computing에서 SAGA 패턴의 매력은 더욱 커지는 것 같다. 다음 공부에선 실제 구현 에 대해 학습해 보도록 하겠다 .&lt;/p&gt;</content:encoded></item><item><title><![CDATA[함수형 프로그래밍에서 currying이 갖는 장점]]></title><description><![CDATA[공부 이유 : 함수형 프로그래밍에는 다양한 아이디어들이 조화를 이루며 나은 개발 방법을 제시한다. 그 중에서 curried functions…]]></description><link>https://sukjae.github.io/daily-study/daily/2019-07-06/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/daily/2019-07-06/</guid><pubDate>Sat, 06 Jul 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;공부 이유 :&lt;/h2&gt;
&lt;p&gt;함수형 프로그래밍에는 다양한 아이디어들이 조화를 이루며 나은 개발 방법을 제시한다. 그 중에서 curried functions을 사용하여 연쇄적인 함수를 전달하는 패턴이 많이 쓰이는데, 나는 이게 왜 장점인지 이해가 가지 않았다.&lt;/p&gt;
&lt;p&gt;(나랑 동일한 질문을 갖고 있던 다른 이의 질문을 옮겨봤다.)[&lt;a href=&quot;https://softwareengineering.stackexchange.com/questions/185585/what-is-the-advantage-of-currying&quot;&gt;https://softwareengineering.stackexchange.com/questions/185585/what-is-the-advantage-of-currying&lt;/a&gt;]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It seems to me to be just syntactic sugar that removes one set of parentheses from defining and calling the function. I’ve seen currying listed as one of the important features of a functional languages, and I’m a bit underwhelmed by it at the moment. The concept of creating a chain of functions that consume each a single parameter, instead of a function that takes a tuple seems rather complicated to use for a simple change of syntax.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Is the slightly simpler syntax the only motivation for currying, or am I missing some other advantages that are not obvious in my very simple example? Is currying just syntactic sugar?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;공부 내용 :&lt;/h2&gt;
&lt;p&gt;내가 curried 패턴을 자주 본 것은 리액트 개발을 하면서 이다. 생각해보면, HOC 패턴을 사용하면서 값을 전달받아 다음 행동을 취했다.&lt;/p&gt;
&lt;p&gt;단순히 초기값을 셋팅하기 위한 방법중 하나로 여기고 있었는데 이번 기회에 잘 정리해 볼 수 있었다.&lt;/p&gt;
&lt;p&gt;(위 질문에 대한 답변)[&lt;a href=&quot;https://softwareengineering.stackexchange.com/a/185592&quot;&gt;https://softwareengineering.stackexchange.com/a/185592&lt;/a&gt;]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;With curried functions you get easier reuse of more abstract functions, since you get to specialize.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;맞다. currying을 사용하여 초기값등을 앞에서 정의하고 추상화 시킨다면, 보다 질서있게 구현이 가능하다.&lt;/p&gt;
&lt;p&gt;이 초기값들을 동일한 함수에서 시작하였다면, 그 다음 함수의 호출에서 첫번째 함수에서 쓰였던 params를 그대로 referecn 가능하다. (클로저 때문에)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In conclusion: currying is good, because it lets you specialize/partially apply functions using a lightweight syntax and then pass these partially applied functions around to higher order function such as map or filter.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;또 다른 답변&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Currying alone is essentially useless, but having all functions curried by default makes a lot of other features much nicer to use. It’s hard to appreciate this until you’ve actually used a functional language for a while&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;또 중요한 점은, currying을 사용하여 map, filter등 고차함수에 전달하기 용이하다는 점이다.&lt;/p&gt;
&lt;h2&gt;한줄 정리 :&lt;/h2&gt;
&lt;p&gt;currying은 함수형 프로그래밍을 하는데 있어서 중요한 패턴이다. 자유 자제로, 논리적으로 나눌 수 있는 시야가 필요하다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[기업의 불합격 통보는 아무 영양가 없다]]></title><description><![CDATA[…]]></description><link>https://sukjae.github.io/daily-study/daily/2019-07-05/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/daily/2019-07-05/</guid><pubDate>Fri, 05 Jul 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;현재 나는 산업 기능 요원에 편입을 도전하고 있다.&lt;/p&gt;
&lt;p&gt;자리가 워낙 없고, 이미 기업에 내부 대기자가 존재하는 경우가 많아 취업이 순탄치 않다.&lt;/p&gt;
&lt;p&gt;그러나 되는데 까지 해보자는 마인드로 내가 좋아하는, 또 배울점이 많은 기업들 위주로 자소서를 제출하고 있다.&lt;/p&gt;
&lt;p&gt;물론 내가 부족함을 알기에 많은 기대는 하고 있지 않다. 하지만 매 기업마다 최선을 다하여 회사별로 다른 내용의 포트폴리오를 제출하려 노력하고 있다. &lt;br /&gt;&lt;/p&gt;
&lt;p&gt;내 취업 전략은, 내 부족함을 알기 때문에 내 장점을 끌어 올리는 것이다. 내 장점은 문제를 잘 찾는 것이다.&lt;/p&gt;
&lt;p&gt;각 기업의 서비스를 모두 관찰하고 테스트 하며 추가되었으면 하는 서비스들, 개선 되었음 하는 부분들을 포트폴리오의 일 부분으로서 기업에 어필하고 있다. &lt;br /&gt;&lt;/p&gt;
&lt;p&gt;문제는 내가 많은 노력을 들여 지원서를 제출하여도, 대부분의 기업에서 메일 한 통과 안타깝다는 문구의 아무 영양가 없는 내용을 보낸 다는 것이다. 지금까지 납득할 만한 배울점이 있는 탈락 통지서는 딱 한통 받아 봤다. 생각해보면 내가 각 회사를 위해 열심히 지원서를 작성 하였는데, 적어도 얻어 가는게 있어야 할것 아닌가. &lt;br /&gt;&lt;/p&gt;
&lt;p&gt;대부분 기업들이 이런식의 아무런 영양가 없는 내용을 전달한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;보내주신 입사지원서는 꼼꼼하게 검토를 진행하였습니다만, 아쉽게도 선발인원에 제한이 있어서 이번 기회에 ooo님을 모실 수 없게 된 것을 매우 안타깝게 생각합니다.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;그래도 아쉬운 사람이 한번 더 연락 하는 거다. 나는 부족한 부분을 얻고, 발전하기 위해 매 탈락 마다 담당자 분들의 피드백을 구한다.&lt;/p&gt;
&lt;p&gt;그러나 슬프게도 대부분의 인사 담당자 분들은 내부 규정을 말하며 공유를 하지 않는다.&lt;/p&gt;
&lt;h2&gt;느낀점&lt;/h2&gt;
&lt;p&gt;나는 항상 이런 상황이 이해가 안간다. 이게 우리 나라만의 문제인지는 모르겠으나, 공모전을 포함하여 모든 채용 절차에서 지원자는 을이다.&lt;/p&gt;
&lt;p&gt;지원자가 많은 노력을 들여서 회사가 좋은 인재를 선발하는데 도움을 주었으면, 회사도 지원자를 위해 무언가 도움을 줘야 하지 않는가. &lt;br /&gt;&lt;/p&gt;
&lt;p&gt;채용 결과와 관련하여 아무런 피드백을 주지 않는 기업들은 이런 곳 중 하나 일 것이라 생각한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;지원자를 전혀 생각하지 않는 회사. 회사는 지원자를 선발하는 갑의 위치.&lt;/li&gt;
&lt;li&gt;지원자를 선발할 객관적인 기준과 근거가 없는 회사. 그러므로 결과를 공유할 수 없음.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;내부 규정을 운운 하는 업체는 무언가 잘못 생각 하고 있는 것 같다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;자신 있는 명확한 평가 기준이 없으면, 지원자를 평가해선 안되고.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;명확한 평가 기준이 있는데 그게 회사의 공개된 인재상, 가치 , 비전등과 관련이 없는 것이라면 평가의 기준이 되어선 안된다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;strong&gt;한줄 정리 :&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;내가 너무 순진한 생각을 하는지 모르겠다. 하지만 나는 기업과 지원자는 동등한 위치에 있다고 본다. 기업이 우릴 선택 하듯이, 우리도 기업을 선택 하는 것이다. 기업이 지원자의 발전을 위해 최소한의 도움도 주지 않는다면, 기업은 우릴 위해 무엇을 해주는 것인가.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;기업과 지원자 모두가 발전할 수 있는 문화가 형성 된다면 좋을것 같다.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[OpsWork+Chef+CloudFormation+.. 어떻게 서로 조화를 이루나]]></title><description><![CDATA[공부 이유 : CI/CD를 위해 다양한 서비스들이 사용된다. 가장 많이 보는것은 Chef, 쿠버네티스, AWS CloudFormation, AWS OpsWork…]]></description><link>https://sukjae.github.io/daily-study/daily/2019-07-04/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/daily/2019-07-04/</guid><pubDate>Thu, 04 Jul 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;공부 이유 :&lt;/h2&gt;
&lt;p&gt;CI/CD를 위해 다양한 서비스들이 사용된다. 가장 많이 보는것은 Chef, 쿠버네티스, AWS CloudFormation, AWS OpsWork등등…&lt;/p&gt;
&lt;p&gt;문제는 이 서비스들이 어떻게 조화를 이루는지 이해가 가지 않았다.&lt;/p&gt;
&lt;p&gt;서로 비슷한 역할을 하고 있는 것 같았고(돌이켜 보면 비슷한 역할을 서로 하고 있긴 하다) 사람들은 어떻게 구분하여 사용하는지 이해가 가지 않았다.&lt;/p&gt;
&lt;h2&gt;공부 내용 :&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;CloudFomration&lt;/strong&gt;은 도면 과 같은 역할.&lt;/p&gt;
&lt;p&gt;인프라가 어떻게 구성되고 어떻게 생겨야 할지에 대한 도면, 이 도면을 이용하여 인프라를 내리고 올릴 수 있다. &lt;br /&gt;&lt;/p&gt;
&lt;p&gt;CF가 뼈대를 잡았다면, 기본 설정을 위해 Metadata,Command를 통해 인프라의 각각의 서버를 구성해야 함. &lt;br /&gt;&lt;/p&gt;
&lt;p&gt;이때 사용되는게 &lt;strong&gt;Chef&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;일일이 설정을 진행하여도 되지만, Chef cookbook등을 이용해 동일 구성요소를 손쉽게 셋팅 가능. &lt;br /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;이 과정에서 AWS차원에서 제공하는 서비스가 OpsWork.?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;그렇다면 CodePipeline 과 같은 CI/CD 도구는?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CI/CD 과정을 세분화 해야한다.&lt;/p&gt;
&lt;p&gt;각 부분마다 어떤 도구가 쓰이는지 파악해 봐야 한다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;jenkins&lt;/strong&gt; : 오케스트레이션 도구. CI/CD에 있어서 배포, 빌드, 롤백 등의 과정을 모두 다루는 도구&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AWS ECS, EKS, Kubernaties&lt;/strong&gt; : 오케스트레이션 도구, 통합 관리 도구&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Chef&lt;/strong&gt; : configuration 도구. CI/CD 과정중에 빌드등에 있어서 만들어지는 인프라에 대한 설정을 도와준다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CloudFormation&lt;/strong&gt; : CI/CD 과정중에 빌드등에 있어서 만들어지는 인프라의 구조를 정의한다. 템플렛에 일정 부분 설정을 넣을 수 있으므로 Chef 의 기능을 포함하는 듯 하지만, 더 복잡한 설정을 위해 Chef를 로컬에 설치함으로서 관리한다.&lt;/p&gt;
&lt;p&gt;AWS 의 경우에는, 컨테이너를 관리하기 위한 ECS, EKS 가 존재한다.&lt;/p&gt;
&lt;p&gt;또한, CI/CD에 있어서&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;코드를 관리하기 위한 CodeCommit&lt;/li&gt;
&lt;li&gt;빌드를 위한 CI 도구인 CodeBuild&lt;/li&gt;
&lt;li&gt;배포를 위한 CD 도구인 CodeDeploy&lt;/li&gt;
&lt;li&gt;배포 과정을 위한 CD 도구인 CodePipeline&lt;/li&gt;
&lt;li&gt;그리고 이 4가지를 한번에 제공하는 CodeStar 가 존재한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;한줄 정리 :&lt;/h2&gt;
&lt;p&gt;명확한 역할 구분을 위해서 조금 더 세분화 된 절차를 이해 할 필요가 있다. 또한 각각의 서비스가 제공하는 기능들 중 원하는 것만 조합하여 사용할 수 있는 인사이트를 기르자.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Redux vs Apollo ..?]]></title><description><![CDATA[공부 이유 : 프로그래머스에서 진행하는 온라인 스터디 내용중에 Parcel를 활용한다는 내용이 있었다. 이게 Webpack과 비교하여 어떤 장점으로 사용되나를 찾아보다 네이버에서 적용한 후기를 찾아보게 되었다. React와 Apollo, Parcel…]]></description><link>https://sukjae.github.io/daily-study/daily/2019-07-03/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/daily/2019-07-03/</guid><pubDate>Wed, 03 Jul 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;공부 이유 :&lt;/h2&gt;
&lt;p&gt;프로그래머스에서 진행하는 온라인 스터디 내용중에 Parcel를 활용한다는 내용이 있었다.&lt;/p&gt;
&lt;p&gt;이게 Webpack과 비교하여 어떤 장점으로 사용되나를 찾아보다 네이버에서 적용한 후기를 찾아보게 되었다. &lt;a href=&quot;https://d2.naver.com/helloworld/2838729&quot;&gt;React와 Apollo, Parcel 기반 서비스 개발, Naver D2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이 내용에서는 Redux+REST API → GraphQL+Apollo로의 전환을 시도한 결과를 공유하고 있다.&lt;/p&gt;
&lt;p&gt;REST API를 GraphQL을 사용하는 Apollo로 전환을 한다는 것은 이해가 가는데,&lt;/p&gt;
&lt;p&gt;어떻게 Redux와 Apollo가 서로 대체제인지 잘 이해가 가지 않았다.&lt;/p&gt;
&lt;h2&gt;공부 내용 :&lt;/h2&gt;
&lt;p&gt;생각해보면 Redux의 주 기능은&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;store를 통한 single source of truth으로 상태를 한곳으로 모으고&lt;/li&gt;
&lt;li&gt;단방향 데이터 흐름을 갖도록 강제 시키면서&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;애플리케이션의 전반적인 상태를 관리하는 용도이다.&lt;/strong&gt;
&lt;br /&gt;
반면에 apollo cli는 인터페이스로서 클라이언트와 서버단의 graphQL 통신을 돕는다.
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;클라이언트 단에서 돌아가는 프런트앤드 애플리케이션의 &lt;strong&gt;로컬 상태를 관리하기 위한 도구&lt;/strong&gt;와,&lt;/p&gt;
&lt;p&gt;클라리언트 단에서 돌아가는 프런트앤드 애플리케이션의 &lt;strong&gt;외부 통신을 돕는 도구&lt;/strong&gt;가&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;어떻게 서로 대체제로서 사용되는지 잘 이해가 가지 않았다.&lt;/strong&gt;&lt;/p&gt;
&lt;br /&gt;
내 생각에 위 내용을 따르면
&lt;p&gt;&lt;strong&gt;Redux vs apollo&lt;/strong&gt;가 아니라
&lt;strong&gt;(Universal router + REST api) vs (react router + apollo(graphQL))&lt;/strong&gt; 로 비교 되어야 하고,&lt;/p&gt;
&lt;p&gt;이를 통해 SSR 에 대처하고 뷰를 위한 값을 서버에서 가져와야 한다.
&lt;br /&gt;&lt;br /&gt;
이해가 안가던 차에 다른 사람들의 redux vs apollo 비교 글들을 보고 위 내용이 두서 없는 말장난이란 것을 알게 되었다.(d2에서 적어도 왜 저렇게 제목을 작성했는지 언급 했어야 했다…)
&lt;br /&gt;
&lt;br /&gt;
Hackernoon의 글중 &lt;a href=&quot;https://hackernoon.com/goodbye-redux-26e6a27b3a0b&quot;&gt;Goodbye Redux&lt;/a&gt; 에 따르면 다음과 같은 문장이 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;🤷‍ But how does this replace Redux?&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Another great question, thanks for asking. Simply put, &lt;strong&gt;it doesn’t&lt;/strong&gt;. However, what it does do is &lt;em&gt;encourage&lt;/em&gt; you to &lt;em&gt;not&lt;/em&gt; store all your information in the single object that Redux gives you. This is because each query is custom designed to only get data for one part of the app — not the whole thing. It would be an anti-pattern (and is simply not logical) to store information, specific to a single part of the app, in an app-wide data source.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;즉, 리덕스와 아폴로는 서로 대체제가 아니다. 단지 서로 다른 철학을 갖고 문제에 접근하는 방법들을 제시하며, apollo는 redux의 global한 single source of truth로서의 상태 관리를 안티패턴으로 여기고 다른 방법으로 접근(graphQL로 원할때마다 요청) 하도록 장려하는것이다.
&lt;br /&gt;
&lt;br /&gt;
결국 또 다른 Hackernoon의 글인 &lt;a href=&quot;https://hackernoon.com/how-graphql-replaces-redux-3fff8289221d&quot;&gt;how graphql replaces redux&lt;/a&gt; 처럼 graphqQL을 이용하면 아래와 같이 &lt;strong&gt;굳이&lt;/strong&gt; 상태 관리 도구를 사용하지 않아도 된다(물론 예외들이 존재.)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;When the client can control the exact shape of the state it needs from the server and get it all back in a single request, there’s simply not much need for state management libraries.&lt;br&gt;
&lt;br /&gt; &gt; &lt;br /&gt;
반면에 상황에 따라 redux, apollo 두개를 같이 사용할 경우도 있고, 둘중 하나만 선택해서는 구현이 힘들 경우도 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;There are also cases where you’re managing very complex state that needs trackable and consistent control: lower-level things like a client-side cache, offline syncing etc. Redux is great for these cases. In fact, some popular GraphQL libraries like Apollo can use Redux under the hood as a cache.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;한줄 정리 :&lt;/h2&gt;
&lt;p&gt;결국, fetch를 쓸까 axios를 쓸까 비교 하듯이 redux와 apollo 두개의 라이브러리를 비교 해가며 선택 한다기 보단 둘이 서로 다른 구현방법과 디자인 패턴을 가지고 있음을 이해하고 상황에 맞게 사용함이 옳다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[스크럼과 XP (헨릭 크니버그) 절반을 읽고...]]></title><description><![CDATA[…]]></description><link>https://sukjae.github.io/daily-study/daily/2019-07-02/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/daily/2019-07-02/</guid><pubDate>Tue, 02 Jul 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;공부 이유 :&lt;/h2&gt;
&lt;p&gt;처음 스크럼이란 용어를 아틀란시안 지라를 보며 알게 되었다.
혼자만 학습하고 개발하다보니 사람들은 어떻게 협업을 할까 라는 호기심이 생겨 지라를 찾아 보았다.
그러다 애자일과 관련하여, 또 여러 개발기 등에서 스크럼이란 용어가 많이 보여 조금 더 알아보기 위해 책을 읽기 시작했다.&lt;/p&gt;
&lt;h2&gt;공부 내용 :&lt;/h2&gt;
&lt;p&gt;현재 위 책을 절반정도 읽었다. 이 책은 스크럼에 대한 이해를 돕기보단 스크럼을 어떻게 활용해야 하는지에 대한 내용을 경험을 위주로 다룬다.
애초에 스크럼을 알고 있다고 가정하기 때문에 책을 읽는것을 망설였지만, 이해하기 어려운 방법론은 아닐것이라는 판단에 읽게 되었다.&lt;/p&gt;
&lt;p&gt;다음 문장들은 책속의 내용을 참조한것이며, 이에 대해 내가 느낀점을 간단히 작성하려 한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;켄 슈와버의 말에 의하면 스크럼은 방법론이 아니라 프레임워크다. 그 이야기는 스크럼이 여러분에게 정확히 무엇을 해야 하는지 알려주지 않는다는 것이다. (p1)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;즉, 스크럼은 내가 사용할 도구들의 묶음이자 사용을 편리하게 해줄 보조의 역할이지 길을 제시해주는 친구가 아니다. xp와 같은 개발론처럼 리스트를 맞춰가며 하나씩 체크 해나가는것이 아닌것 같다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;내적 품질은 논의의 대상이 될 수 없다. 어떠한 상황에서도 시스템의 품질을 유지하는 것이야말로 팀이 책임져야 할 사항이며, 이것은 &lt;strong&gt;두말할 필요 없이 그냥 협상의 대상이 아니다. 절대로&lt;/strong&gt;(p18)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;스토리는 3개의 변수를 갖는다. 범위, 추정치 그리고 중요도.
그러나 이러한 변수중에 품질은 변수가 아닌 무조건 챙겨야 할 부분이며 또 2가지로 나뉜다. 외적 품질, 내적 품질
이 부분은 장인정신을 얘기하는듯 하다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;우리가 내린 결론은 일단 스프린트 길이를 가지고서 직접 실험을 해보라는 것이다. 분석에 너무 시간을 보내지 마라. 우선 괜찮은 길이를 하나 고르고 나서 한두 번의 스프린트를 돌려보라. 그러고 나서 길이를 수정하면 된다. (p22)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;오버 엔지니어링 하지 말고, 우리가 모든 변수를 다 고려할 수 없음을 알아야 한다. 결국에 자동차를 운전하듯 좌우로 핸들을 꺾어가며 방향을 조절해야 한다. 처음부터 완벽할 순 없다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;여러분이 팀에 추정치를 물어보면 대개 그 스토리를 가장 잘 아는 사람이 제일 먼저 무심코 말하는 경향이 있다. 불행히도 그 수치는 다른 사람들의 추정치에 강한 영향을 미치게 된다. … 플래닝 포커라 불리는 방법이 있다. (p40)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;재밌는 생각인것 같다. 팀 프로젝트를 함에도 한명의 주도적인 사람이 의견을 제시하면 대부분 딸아가기 마련이다. 팀원 각자의 주관적인 생각을 합쳐 최고의 성과를 내기 위해서는 이러한 영향을 최소화 해야 한다. 그런 점에서 상대방의 패를 알 수 없는 플래닝 포커는 매우 재밌는 방법이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;회고에 있어서 가장 중요한 것은 실제로 회고가 이루어지도록 하는 것이다. … 회고는 여러분이 개선을 할 수 있는 최고의 기회이기 때문이다. (p83)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;나에게 가장 부족한 부분중에 하나이다. 첫째는 지속적인 의지가 부족한 점이고 둘째는 실패에 대한 회고가 부족하였다.
실패는 성공의 어머니라 하지만, &lt;strong&gt;회고가 없다면 그냥 실패일 뿐이다&lt;/strong&gt;. 부족한 부분을 반성하고 발전하도록 노력해야겠다.
최근에 또 느낀점은 회고를 공유하는것 또한 중요한 경험이다. 회고를 남에게 공유하기 위해서 한번 더 정리하게 되고 이로 인해 깊은 성찰을 다시금 하게 된다. 또한 다른 사람의 시각에서 또 다른 인사이트가 반영될 수 있기에 공유가 중요하다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;현실에서 항상 전력질주 할 수는 없다. 전력질주 사이에 휴식을 취해야 한다. 여러분이 늘 전력질주를 하고 있다면 실제로는 조깅하는 것일 뿐이다. (p91)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;재밌는 말이다. 백프로 공감한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;스크럼은 관리 및 조직적 실천법에 집중하는 반면 XP는 거의 대부분 실제 프로그래밍 실천법에 집중한다. 각각이 다른 영역을 다루면서 서로를 보완해 주는 것, 그것이 바로 두 방법론이 잘 들어맞는 이유다. (p103)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;방법론은 서로 독립적으로 사용되는게 아니다. 각각이 완벽한 것도 아니고 상황에 따라 융통성있게 조합하여 최고의 효과를 내기 위해 노력하는것이 가장 좋은 성과로 나오는것 같다.&lt;/p&gt;
&lt;h2&gt;한줄 정리 :&lt;/h2&gt;
&lt;p&gt;결론적으로, 스크럼 또한 인간이라는 한계를 인지하며 어느정도 융통성 있게 적용해야 한다. 절대적인 방법이 아닌 팀에 따라 다르게 적용할 수 있는 프레임워크임을 꼭 기억하자.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Snapshot]]></title><description><![CDATA[공부 이유 : TDD가 선택이 아닌 필수임을 알게된 이상 Testing에 대한 딥 다이브가 필요하였다. 그러나 UI 컴포넌트에서 어떤 테스팅 기법이 쓰이는지 상상이 안갔다. 그래서 React에서 쓰이는 테스팅 도구인 jest…]]></description><link>https://sukjae.github.io/daily-study/daily/2019-07-01/</link><guid isPermaLink="false">https://sukjae.github.io/daily-study/daily/2019-07-01/</guid><pubDate>Mon, 01 Jul 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;공부 이유 :&lt;/h2&gt;
&lt;p&gt;TDD가 선택이 아닌 필수임을 알게된 이상 Testing에 대한 딥 다이브가 필요하였다.&lt;/p&gt;
&lt;p&gt;그러나 UI 컴포넌트에서 어떤 테스팅 기법이 쓰이는지 상상이 안갔다. 그래서 React에서 쓰이는 테스팅 도구인 jest를 찾아보게 되었고, 그 중에서 UI 컴포넌트가 잘 랜더링 되었는지를 확인하기 위해 enzyme를 활용하는것을 알게 되었다. 이 enzyme를 사용해서 하드코딩 하는 방법 이외의 방법인 snapshot를 찾아보았다.&lt;/p&gt;
&lt;h2&gt;공부 내용 :&lt;/h2&gt;
&lt;p&gt;jest 에는 여러 테스팅 방법이 존재&lt;/p&gt;
&lt;p&gt;그 중에서 UI를 테스팅 하기 위해 흔히 enzyme나 react-test-renderer 등과 같이 조합하여 dom을 비교하는 방식으로 테스팅 됨&lt;/p&gt;
&lt;p&gt;여기에서 assert를 통과할 수 있는 컨포넌트를 명시적으로 표현하기 위해 하드코딩을 함&lt;/p&gt;
&lt;p&gt;문제는 처음에 어떻게 랜더링 될지 몰라 콘솔을 찍어보고 결과를 복붙하는 시간이 소요되는 방법을 하게 됨&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.notion.so/bbef4e733ba949a58fcd864b313b0298#7a3c17629e3d40a998e87056d536e356&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.notion.so/bbef4e733ba949a58fcd864b313b0298#dacc9c5d97384029ac662bc9ba95e530&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;로깅된 결과를 그대로 사용&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.notion.so/bbef4e733ba949a58fcd864b313b0298#acb0c2dabd5c4b0eb5ce062f1fcf160d&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;스냅샷을 쓰면 자동으로 전 후 dom을 비교&lt;/p&gt;
&lt;p&gt;dom을 열거되는 array의 형태로 만든 후 비교한다.&lt;/p&gt;
&lt;p&gt;따라서 string의 모임으로 표현하는 모든 방식을 사용할 수 있고&lt;/p&gt;
&lt;p&gt;이렇게 스냅샷을 사용하면 하드코딩으로 인한 코드 갱신 오류, 코드 중복 방지 등이 가능&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://youtu.be/HAuXJVI_bUs&quot;&gt;Rogelio Guzman - Jest Snapshots and Beyond - React Conf 2017&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;그러나, 아래 글에서 알 수 있듯이 스냅샷은 TDD방식에서 코드를 가이드 하기 위한 방식으로 쓰이기 보단 첫 개발 후에 코드의 유지를 위한 용도로 사용하면 적당할 듯 하다&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://jestjs.io/docs/ru/snapshot-testing#is-it-possible-to-apply-test-driven-development-principles-with-snapshot-testing&quot;&gt;Snapshot Testing · Jest&lt;/a&gt;&lt;/p&gt;</content:encoded></item></channel></rss>