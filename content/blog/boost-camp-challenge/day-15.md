---
title: 부스트캠프 2019 챌린지 15일차
date: "2019-08-02T00:00:00Z"
---

## 피어 세션 중 생각 정리

> 전날 구현한 코드에 대해 다시 한번 정리하는 시간을 갖습니다

### [WEB API 속의 Canvas API ]

- [`canvas Element`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas) 는 HTML속의 DOM 엘리먼트를 뜻합니다. (`<canvas>`로서 표현 됩니다.)
- `[canvas API`](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API) 는 Web API로 제공되는, Javascript로 HTML엘리먼트인 `<canvas>`를 조작하기 위해 제공되는 기능입니다.
- 이 `canvas API` 라는 기능은, HTML의`<canvas>` 엘리먼트와 JS를 이용하여 그래픽을 그리기 위한 수단을 제공합니다.
- 이 `<canvas>`와`canvas API` 를 더욱 쉽게 사용하기 위해 많은 개발자들은 다양한 라이브러리를 제작하였고, 이에 대한 자세한 내용은 **[다음 자료](https://developer.mozilla.org/ko/docs/Web/HTML/Canvas#%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC)**에서 확인할 수 있습니다.

### [node-canvas]

- 다수의 부스트캠프원들이 프로젝트를 진행하며 `node-canvas` 라는 API를 사용하였습니다.
- 이 `node-canvas` 는 위의 Web API 기반의 `canvas API`와 이를 더욱 편리하게 사용하는 [다른 라이브러리](https://developer.mozilla.org/ko/docs/Web/HTML/Canvas#%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC)와는 차이를 갖습니다.
- `node-canvas`는 Web API 기반의 `canvas API`를 모방하여, NodeJS의 환경에서 동일한 결과를 주는것을 목표로 합니다.
    - 아직, 완벽하게 1:1 대응으로 구현한것은 아니지만, 현재 대응 상황을 **[Compatibility Status](https://github.com/Automattic/node-canvas/wiki/Compatibility-Status)**에서 확인할 수 있습니다.
- `node-canvas`가 `canvas API`와 다른점은, `node-canvas`는 HTML DOM Element인 `<canvas>`위에 구현되지 않고, 이를 단지 모방하기 때문에 저희가 브라우저(클라이언트)에서 사용하는 `canvas API`와 `<canvas>`와는 사용 용도와 적용 방법이 다르다 생각합니다.

### [node-canvas는 왜 생겼고, 왜 많이 사용될까?]

> 이 부분부터는 저의 추측에 기반합니다.

**일단, 이에 대해 생각해보기 위해 몇가지 짚고 넘어가야 할 부분이 있습니다.**

1. `canvas API`와 `<canvas>`의 조합은 클라이언트상에서 `WebGL API`를 사용하고, 클라이언트의 리소스(그래픽을 처리하기 위한)사용합니다.
2. `canvas API`와 `<canvas>`의 조합을 사용시, 연산이 복잡해질수록, 클라이언트에게 큰 Load 주고, 이는 좋지 않은 경험을 줄 수 있습니다.
3. 현재 모던한 웹 환경은, server-side와 front-side를 구분하고 있습니다.

**위 내용들을 바탕으로, 저의 생각의 흐름을 서술하겠습니다.**

- ReactJS, VueJS, Angular 등과 같은 Node기반 FE 도구들이 많이 사용되고 있습니다.
- 위 도구들은 기본적으로 SPA의(single page application) 형태를 띄며 JS의 힘을 이용하여 화면을 랜더링 합니다.
- 조금 더 구체적으로 들어가면, Virtual DOM을 생성하여 DOM을 모방하고, 이는 JS를 활용하여 클라이언트가 사용하는 RunTime에 DOM 트리와 view가 생성 됩니다.
- 문제는, 사용자가 이 SPA를 직접 사용할때만 JS가 발동하며 DOM을 생성하기 때문에, 사용자에게 보여지는 HTML 컨텐츠의 내용과 외부에서 HTML을 직접 접근했을 떄 보여지는 내용이 다릅니다.
- 이것이 문제가 되는 이유는, HTML의 존재 이유와 연관이 있습니다.
- HTML은 의미를 갖고 있는 문서로서, 다양한 연결점을 갖고 검색엔진등이 이를 취합하여 정보 제공을 하여야 하는데,
- 겉으로만 보기엔 해당 웹 서비스에 아무런 정보가 없어 보이므로, 다른 사용자는 이 서비스의 컨텐츠에 접근이 어렵습니다. (검색엔진은 보통 HTML만 파싱해왔습니다. 현재는 다르지만.)
- 이를 해결하기 위해 위 FE 도구를 활용하여 SPA를 구현시 Server Side Rendering(SSR)을 제공하고 클라이언트에서 JS가 발동하기 전에 HTML을 구성하는 기능을 제공합니다.
- 문제는, `canvas API` 와 `canvas`를 이용한 구현시, 위에서 언급한대로 클라이언트 상에서 랜더링 된다는 단점이 있습니다.
- 만약, `canvas` & `canvas API`로 보여지는 정보들을(예를 들어 Image) 검색엔진등이 파싱하려 하면, 해당 정보는 아직 생성되지 않았기 때문에, 정보 제공이 어렵습니다.
- 이 문제를 해결하기 위해 SSR을 통하여 저장할 HTML을 생성시, node 기반으로 `node-canvas`를 활용하여 미리 이미지를 생성하고 제공할 수 있습니다.
- 또한, 이 모든 작업이 서버에서 처리 되므로 클라이언트에게 큰 부답 없이 정보를 제공할 수 있습니다.

> 이런식으로 활용되는 예시는, spritejs,two.js등이 있습니다.

### [그렇다면, `canvas`를 통해 정적인 이미지 생성이 아닌, 동적인 생성을 필요로 한다면 어떻게 해야하나]

- 위에서 언급 하였듯이, `node-canvs`를 통해 완성된 이미지를 생성할 수 있습니다.
- 이렇게 서버측에서 완성된 이미지를 클라이언트에서 동적으로 사용하기 위해 두가지 방법이 있을듯 합니다.
    1. 클라이언트 환경에서 별도로 `<canvas>`를 생성하고, 서버에서 `node-canvas`를 통해 생성된 이미지를 전달 받아 그 위에 작업 합니다.
    2. `node-canvas`에서 지속적으로 새로운 이미지를 생성하고, 클라이언트로 전달합니다.
- 동적으로 `canvas`를 활용하기위해 위 두가지 방법을 사용한다면, 특히 2번째 방법에서 많은 리소스를 사용할듯 합니다.
- 서버와의 통신을 통한 `canvas`활용시 , `<canvas>` & `canvas API`와 `websocket`을 활용하여, 클라이언트에서 그려주는 방식이 적절할것 같습니다.

## 금요일 프로젝트 중 느낀것

### 전반적인 프로젝트 흐름

오늘 우리는 `code style check`와 `best practice`를 실시간으로 보여주는 프로젝트를 하였다. 

이번에도 프런트엔드 라이브러리를 활용하지 않고,  `vanila JS`와 `jQuery` 조합으로 진행하였다. 

이번 미션에서는 서버가 필요하여 이를 구현하기 위해 `express`를 활용하였다.

전반적인 미션 만족도는 나쁘지 않았다. 초반 30분간 구현에 대한 브레인 스토밍을 마쳤고, 여기서 나온 결과가 실행 가능한 방법인지 각자 조사를 하는 시간을 20분 가졌다. 

그 후 지난번과 마찬가지로 2인 1조로 페어 프로그래밍을 하려 하였다. 

안타깝게도, 이번엔 주어진 문제가 많아 2인 1조로 팀을 짜 구현을 하긴 하였지만, 서로 다른 작업을 하였다. 

나의 경우, `form`을 생성하고, 이를 `jquery` 를 통하여 `http` 요청을 보내는 부분을 제작하였다. 

오랜만에 `jQuery` 를 만져서 그런지 약간 생소하였지만, `jQuery` 의 쉬운 문법 덕분에 큰 어려움 없이 구현할 수 있었다. 

그 후로 시간이 조금 남아서 `server` 부분을 수정하여 `/api` 를 열어주어 테스트를 하였다. 

이 또한 `node` 도 오랜만이라 좀 버벅였지만, 튜토리얼을 잘 활용하였다. 

기본적인 내용이라 그리 큰 어려움이 없었다. 

그 후 다른 분들이 각자 일을 하시는 동안, code snippet을 클라이언트에서 보여주는 라이브러리를 찾아 봤다. 

그 중에서 [ace 라이브러리](https://ace.c9.io) 가 있었는데, 이게 너무 쉽고 잘 만들어져 있어 이를 그냥 활용하면 되었다. 

그러고, 시간이 조금 더 남아 이를 view에 맞추고, 넘겨 받은 수정 코드를 표시하는 작업도 하였다. 

그러나 안타깝게도, 서버측에서 구현한 `linter` 서버가 오류가 있었다. 

`code style` 을 체킹하지 못하고, 기본적인 몇가지만 체크하고 있었다. 

우리가 구현했어야 하는 기술은, `airbnb`, `facebook` , `google` 의 `code style` 이였는데, 우리는 그런 구분이 안되고 있다는것을 나중에야 알았다 .

이 부분은 좀 아쉬워서 끝나고 남아서 약간 수정하였고, 월요일까지 다시 개인적으로 수정할 예정이다. 

## 회고

역시 금요일은 쉬엄쉬엄 할 수 있는 날이다. 

큰 스트레스 없이 프로젝트를 재밌게 구현해 볼 수 있었다.

결과와 상관없이 최선을 다했다는  부분에서 만족한다.
