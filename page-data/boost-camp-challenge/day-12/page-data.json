{"componentChunkName":"component---src-templates-blog-post-js","path":"/boost-camp-challenge/day-12/","result":{"data":{"site":{"siteMetadata":{"title":"Daily Study | Sukjae"}},"markdownRemark":{"id":"52ab044f-917d-5740-8bcd-c58dd2b85bba","excerpt":"피어 세션 중 느낀것 async/await 사용에 대한 고민 JS에서  연산자는 다음과 같은 특징을 갖고 있습니다.  await 문은 async함수의 실행을 중단시키고, Promise가 fulfill되거나 reject되기를 기다리고, 다시 async함수를 실행시킵니다. 이때  await…","html":"<h2>피어 세션 중 느낀것</h2>\n<h3>[async/await 사용에 대한 고민]</h3>\n<p>JS에서 <code class=\"language-text\">await</code> 연산자는 다음과 같은 특징을 갖고 있습니다. </p>\n<p>await 문은 async함수의 실행을 중단시키고, Promise가 fulfill되거나 reject되기를 기다리고, 다시 async함수를 실행시킵니다. 이때  await 문의 값은 Promise 에서 fulfill된 값이 됩니다.</p>\n<p>만약 Promise가 reject되면, await은 reject된 값을 throw합니다.</p>\n<p>await 연산자 다음에 나오는 문의 값이 Promise가 아니면 해당 값을 resolved Promise로 변환시킵니다.\n<a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/await\">출처: MDN web docs</a></p>\n<p>즉, <code class=\"language-text\">await</code>의 결과 <code class=\"language-text\">Promise.resolve()</code>를 반환하여 <code class=\"language-text\">pending</code> 중인 <code class=\"language-text\">Promise</code>를 반환합니다.\n이와 더불어 비동기의 특성상, 비동기의 호출순서가 비동기의 실행순서를 보장하지 않습니다.\n우리의 미션의 경우 비동기와 동기 테스트를 작성한 순서에 맞게 호출할 필요가 있었습니다. </p>\n<p>저는 모든 함수를 비동기로 바꿔줄 경우 호출 순서에 이상이 생기는 것을 보고, 비동기 작업만을 <code class=\"language-text\">async/await</code>로 기다리고자 하였습니다.\n이를 위하여 <code class=\"language-text\">try-catch</code>문 내에서 <code class=\"language-text\">await</code>를 사용하기 전에, 해당 함수의 호출이 <code class=\"language-text\">Promise</code>를 반환하는 값인지 확인 하였습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> tmp <span class=\"token operator\">=</span> <span class=\"token function\">cb</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>tmp <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>tmp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">await</span> tmp<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>[테스트 실패를 판별하기 위한 고민]</h3>\n<p>우리의 테스트 코드는 여러가지 assertion을 진행합니다.\n이 assertion 중에서 어떤 부분에서 문제가 발생했는지 확인이 필요합니다.\n예를 들어, 연산의 결과<code class=\"language-text\">Success, Success, Fail</code>이 발생 한경우, 이는  <code class=\"language-text\">Fail</code>을 반환해야 합니다. </p>\n<p>이를 구현하기 위해, 각 연산의 결과 실패시 에러를 호출 하였고, 이를 <code class=\"language-text\">try-catch</code>로 감싸 주었습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> assert <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">equal</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token operator\">...</span>args</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>args<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">===</span> args<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Test Fail'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token operator\">...</span>\n  \n<span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> tmp <span class=\"token operator\">=</span> <span class=\"token function\">cb</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>tmp <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>tmp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">await</span> tmp<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>message <span class=\"token operator\">===</span> <span class=\"token string\">'Test Fail'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    result <span class=\"token operator\">=</span> <span class=\"token constant\">RED</span> <span class=\"token operator\">+</span> <span class=\"token constant\">FAIL</span> <span class=\"token operator\">+</span> <span class=\"token constant\">RESET</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>[Jest 테스트 라이브러리]</h3>\n<blockquote>\n<p>Jest는 JavaScript를 테스트하기 위한 Framework이다.</p>\n</blockquote>\n<p>Jest는 다음과 같은 기능을 제공한다.</p>\n<ul>\n<li>Test launchers</li>\n<li>Testing structure</li>\n<li>Assertion functions</li>\n<li>Generate and display test progress and results</li>\n<li>Mocks, spies, and stubs</li>\n<li>Generate and compare snapshots</li>\n<li>Generate code coverage</li>\n</ul>\n<p><strong>[Jest 라이브러리의 특징]</strong></p>\n<p>이 중 우리는 기본적인 Assertion functions를 구현하였다.\n이외의 다양한 기능이 Jest에 존재하고, 이를 통하여 더 많은 방식의 테스트 기법 사용이 가능하다.\n특히, 우리의 경우 Unit test에만 치우쳐 테스팅을 진행 하였는데,\n위 도구를 사용하면 Integration testing, Functional testing(e2e)등 다양한 기법을 사용 가능하다. </p>\n<p><strong>[Jest 라이브러리의 기능]</strong></p>\n<p>또한, 프런트 엔드를 개발할때 UI등에 대해 테스트를 작성하는것은 무척 고된 작업이다.\n원하는 컴포넌트가 생성, 작동 하는지 확인하기위 airbnb에서 제작한 <code class=\"language-text\">enzyme</code> 을 주로 사용하는데,\n이 경우 매번 테스트를 작성할때 컴포넌트의 구조에 대한 명시가 필요하다.\n반면, jest의 snapshot과 같은 기능을 사용하면, 이에 대한 추가적인 작성 없이 동일한 결과(컴포넌트의 생성)이 기대되는지 여부를 쉽게 판별할 수 있다. </p>\n<p><strong>[Jest 와 내 코드의 동작 방식 차이]</strong></p>\n<p>jest의 동작 방식과 나의(혹은 다른 부캠원)의 작동방식 중 가장 두드러지는 차이는,\njest는 모든 테스트를 실행한 뒤 결과를 정리해서 보여준다.(리포트와 같이)\n반면, 우리의 코드는 하나의 테스트가 실행될때 마다 이에 대한 결과를 순차적으로 보여준다.\n특히, 우리의 구현에서 js코드내에 비동기 코드가 있을경우, 이 비동기 작업에 대한 결과를 기다리고, 이에 따라 사용자 또한 다음 결과를 기다리는데\njest의 경우에는 한번에 완성된 보고서를 보여주니 더욱 이용이 편리하다.</p>\n<h2>챌린지 중 느낀것</h2>\n<h3>구조에 대한 고민</h3>\n<p>항상 문제가 주어지면, 그 문제를 해결하기 위한 자료의 구조를 정의하는게 필요하다. </p>\n<p>이 자료 구조가 초반에 잘못 정의되면, 후반에 굉장히 큰 고통으로 다가오곤 한다.</p>\n<p>우리가 작성하는 함수들은 범용적으로 설계 되는 것이 아니라 주어진 문제를 해결하기 위해 제작되곤 한다. </p>\n<p>우리가 함수를 통해 받아야 할 값들과 반환값의 형태가 어느정도 정해져 있고, 이에 따라 내부의 로직이 고정되곤 한다. 이에 따라, 들어오는 값이 변하게 되면 로직도 변해야 하기에 수정에 큰 비용이 든다. (당연한 말을 길게 풀어써 봤다ㅋ)</p>\n<p>튜토리얼등만 수행하였을 때는 데이터의 구조를 정의하는게 이리도 중요한지 몰랐다. </p>\n<p>어차피 접근해봐야 2 deep level정도로만 탐색하고, 반환할테니 맘편히 객체, 배열을 사용할 수 있었다. </p>\n<p>그러나, 오늘같이 배열과 객체가 같이 사용되면서 3층 이상 떨어지는 자료를 만들게 되면 이를 사용하는데 고민을 많이 해야한다. </p>\n<p>데이터를 단순히 mutable하게 하면 편하지만, 이것은 내가 원하는 방법이 아니다. </p>\n<p>가능한 모든 데이터의 흐름을 immutable하게 가져가기 위해 노력을 하다 보니 자료 구조가 복잡해질 수록 이에 대한 데이터 변환 비용이 기하급수적으로 귀찮아 지는것 같다. </p>\n<p>결론적으로 말해서, 내일부터는 사전에 모든 명세를 꼼꼼히 살펴보고 진행해야 겠다. </p>\n<p>원래 글을 잘 못 읽고, 이해가 느려 명세만 읽다보면 시간이 다 가버리곤 한다. 그래서 코딩 테스트같은 문제를 풀때도 일단 코드를 몇자 적어보고 시작하곤 하는데, 오늘은 너무 코드만 적었던것 같다. </p>\n<h3>로직의 분리의 중요성</h3>\n<p>오늘 Model과 Controller 를 분리하여 작성 해 봤다. </p>\n<p>controller에서도 간단히 처리 됨에도 저장소와 1이라도 연관이 있으면 model에 작성하려 노력했다. </p>\n<p>이렇게 코드를 작성하니 로직이 비교적 단순해 지고, 함수의 사용이 명확해져서 재사용이 용이했다. </p>\n<p>계속 이런식으로 학습해보자.</p>\n<h3>공부를 먼저 하고 했어야…</h3>\n<p>위에도 언급했지만, 오늘은 명세를 꼼꼼히 읽어보지 못했다. 어제와 더불어 오늘도 명세가 잘 읽히지 않고 이해가 가지 않아 코드 작성을 하며 이해하려 했다. </p>\n<blockquote>\n<p>그러나, 이 접근법은 크게 잘못 되었다는 것을 집을 오며 깨달았다. </p>\n</blockquote>\n<p>결국 회사에서도 그렇지만, 어떻게 하라고 가이드 라인을 명확하게 주는 경우는 없다. </p>\n<p>항상 고민을 통해 내 스스로 가이드 라인을 만들어 가며 구현해야 하는데, 오늘의 경우에는 너무 과제 해결에만 집중했던 것 같다. 오늘 과제의 양이 많아서 제대로 보지 못했다는 것은 핑계다.</p>\n<blockquote>\n<p>하나를 배우더라도 제대로 배워 보자는 나의 마음가짐은 어디를 갔는가…</p>\n</blockquote>\n<p>오늘은 하나도 제대로 학습하지 못했다. </p>\n<p>반성하고, 내일은 오늘과 같은 실수를 범하지 말자. </p>\n<h3>테스트의 부재</h3>\n<p>첫날 나의 다짐을 어겼다. </p>\n<p>코드 작성 중반쯤 되서야 내가 TDD나 기본적인 Test 코드를 작성하고 있지 않다는 것을 자각했다. </p>\n<p>코드 작성 초반에는 오히려 빨리빨리 되는 것 같았지만, 여러 부분에서 오히려 시간이 더디어 졌고, 결과적으로 낮은 품질의 소프트웨어와 더불어 미션을 완수하지 못했다. </p>\n<p>예를 들어, 오늘 나는 간단한 코드를 계속해서 콘솔에 타이핑을 하며 테스트 하였다. </p>\n<p>이는, 콘솔을 받는 함수와 별도로 테스트 환경을 통해 인위적으로 함수들을 호출하여 통합테스트를 진행할 수 있었던 부분이였다. </p>\n<p>또한 기본적으로 유닛 테스트도 작성 하지 않으니, 문제가 생겼을 때 이에 대한 수정이 번거롭고 흐름이 잘 이해되지 않았다. </p>\n<p>항상 그렇지만, </p>\n<p>복잡할수록 태스트가 필요하다</p>\n<blockquote>\n<p>테스트에서 타협을 보지 말자</p>\n</blockquote>\n<h3>또 한번 immutable 에 대한 고민</h3>\n<p>위에서 살짝 언급했지만, immutable에 대한 고민을 계속 했다. </p>\n<p>특히 OOP의 개념보다는 함수적 사고를 갖고 프로그램을 작성하려 노력했기 때문에, 순수 함수를 작성하고자 노력했다. </p>\n<p>그러나, 원 데이터에 손상을 주지 않고 데이터를 수정하여 적용하는 로직들에서 너무 큰 복잡함이 따라 왔다. </p>\n<p>예를 들어 다음 코드를 살펴 보자…</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> store <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token operator\">...</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>store<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> x<span class=\"token punctuation\">.</span>some_name <span class=\"token operator\">!==</span> some_name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span>\n      <span class=\"token operator\">...</span>copiedOutter<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n      files<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n        <span class=\"token operator\">...</span>copiedOutter<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>files<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> x<span class=\"token punctuation\">.</span>some_other_name <span class=\"token operator\">!==</span> cf<span class=\"token punctuation\">.</span>some_other_name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">{</span>\n          <span class=\"token operator\">...</span>cf<span class=\"token punctuation\">,</span>\n          status<span class=\"token operator\">:</span> <span class=\"token string\">'in progress'</span><span class=\"token punctuation\">,</span>\n          modified_at<span class=\"token operator\">:</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>기존의 <code class=\"language-text\">store</code> 를 손상시키지 않고 shallow copy를 통하여 새로운 값을 포함하는 객체(또는 배열)을 조합하는 방식으로 작성하였다. </p>\n<p>단순 무식한 방법으로 immutable을 구현하려 하였는데, 깊이가 2단계 이상으로 들어가니 로직이 너무 복잡해 졌다 . 이 또한 <code class=\"language-text\">spread syntax</code> 덕분에 이만큼 줄어 들었음에도 아주 더티하다..</p>\n<p>만약 내가 <code class=\"language-text\">store</code> 를 변형 시키고자 했다면 단순히 해당 프로퍼티에 접근해 값을 바꿔주면 끝났을 것이다. </p>\n<p>하지만, FP의 개념을 살리면서 이를 구현하자니 너무 복잡해 졌다. </p>\n<p>아직 간단한 방법은 찾지 못했다. (<strong>라이브러리 없이 !!!!</strong>) </p>\n<p>이에 대한 고민을 더 해보고, immutablejs와 같은 도구를 한번 더 살펴봐야 겠다. </p>\n<h2>오전 시간에 느낀것</h2>\n<h3>Array 객체의 특징</h3>\n<ul>\n<li>Array.prototype.length 는 읽기 전용이 아니다. 이 값을 덮어쓰면, 인스턴스가 변해버린다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> arr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\narr <span class=\"token comment\">// [empty * 5]</span>\narr<span class=\"token punctuation\">.</span>length <span class=\"token comment\">// 5</span>\narr<span class=\"token punctuation\">.</span>length <span class=\"token operator\">=</span> <span class=\"token number\">3</span>\narr <span class=\"token comment\">// [empty * 3]</span></code></pre></div>\n<p>위처럼, 그냥 뒤의 값이 잘려 버린다. 조심하자. </p>\n<ul>\n<li>Array는 new 키워드 없이도 생성이 가능하다</li>\n</ul>\n<h3>Garbage Collection in JS</h3>\n<ul>\n<li>이 부분에 대한 책의 내용은 워낙 오래된 브라우저 기준이라 지금도 적용이 되는지 모르겠다.</li>\n<li>이 부분에 대한 나의 생각은 그냥 큰 고민없이 로직을 작성하면 어느정도 브라우저가 해결해 줄것이다…ㅎ</li>\n</ul>\n<h2>회고</h2>\n<p>오늘은 아쉬움이 많이 남는 날이다. </p>\n<p>내일은 더 발전되고 변한 나의 모습이면 좋겠다. </p>\n<blockquote>\n<p>하나를 배우더라도 제대로 배워 보자</p>\n</blockquote>\n<blockquote>\n<p>테스트에서 타협을 보지 말자</p>\n</blockquote>","frontmatter":{"title":"부스트캠프 2019 챌린지 12일차","date":"July 30, 2019"}}},"pageContext":{"slug":"/boost-camp-challenge/day-12/","previous":{"fields":{"slug":"/boost-camp-challenge/day-11/"},"frontmatter":{"title":"부스트캠프 2019 챌린지 11일차"}},"next":{"fields":{"slug":"/boost-camp-challenge/day-13/"},"frontmatter":{"title":"부스트캠프 2019 챌린지 13일차"}}}}}