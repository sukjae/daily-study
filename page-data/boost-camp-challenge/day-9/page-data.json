{"componentChunkName":"component---src-templates-blog-post-js","path":"/boost-camp-challenge/day-9/","result":{"data":{"site":{"siteMetadata":{"title":"Daily Study | Sukjae"}},"markdownRemark":{"id":"f4237315-1071-57b1-8b88-649386f22d4b","excerpt":"…","html":"<h2>피어 세션 중 느낀것</h2>\n<h3>셀 스크립트가 필요한 이유</h3>\n<ul>\n<li>다수의 반복되는 명령어를 하나의 스크립트 파일에 넣어 실행하여, 개발자의 수고를 덜어준다.</li>\n<li>다수의 반복되는 명령어를 수기로 입력시, 실수로 인하여 명령어를 잘못 입력할 수 있는데, 이를 코드로 관리 한다면 실수를 방지할 수 있다.</li>\n<li>스크립트로 사용가능한 다양한 언어들이 있는데 (예를 들어 파이썬, js 등), 이와 달리 셀 스크립트로 작성 시 셀에서 부가적인 도구 설치 없이 바로 사용이 가능하다는 장점이 있다.</li>\n</ul>\n<h3>타입스크립트가 필요한 이유</h3>\n<ul>\n<li>자바스크립트의 특성상 타입을 강하게 제한하지 않는다. 따라서 동적으로 타입이 변형되기도 하고, 이는 개발자가 원치 않은 결과로 이어지기도 한다.</li>\n<li>사용될 수 있는 타입을 정의함으로서 원치 않은 결과를 방지하고, 통일된 규격을 맞춰 여러명이 함께 코딩을할 수 있다.</li>\n<li>또한, 타입체크를 코드 작성시 실시간으로 진행하게 되면, 컴파일시 발생할 수 있는 문제들을 사전에 어느정도 방지가 가능하며 동시에 안내에 따라 타입에 대해 큰 신경 없이 코드를 작성할 수 있다.</li>\n</ul>\n<h2>챌린지 중 느낀것</h2>\n<p>오늘은 OOP에 대해 집중적으로 학습하였다.</p>\n<p>OOP개념을 다시 돌아보기엔 부족한 시간이기에 구현하기 급급하였지만,</p>\n<p>지난번에 FP로 작성하였던 코드를 다시 한번 OOP로 구현할 수 있는 좋은 기회였다.</p>\n<p>특히 옵저버 패턴에 대해 간단하기 구현할 수 있었던 점이 굉장히 도움이 되었다.</p>\n<p>또한, 지난번과 다른 자료구조를 택함으로서 로직이 훨씬 깔끔해졌다.</p>\n<h3>Observable</h3>\n<p>아직 Observable 을 제대로 이해한것은 아니다, 그러나 하나의 인스턴스를 서로 공유하면서 함수를 호출할 수 있다는 점이 새롭게 다가왔다.</p>\n<p>Observable 을 구현함에 있어서 subject와 observer를 기존의 코드와 최대한 분리하려 고민을 하였다.</p>\n<p>클래스에 subjet클래스를 상속받아서 구현하고, observer를 리스너가 위치한 코드에서 생성한 뒤 리스너가 위치한 코드에서 subject의 메소드를 호출하여 구현하였다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 이렇게 constructor 안에 메소드를 넣을 필요가 없었다.</span>\n<span class=\"token keyword\">const</span> Subject <span class=\"token operator\">=</span> <span class=\"token keyword\">class</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>observers <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function-variable function\">subscribeObserver</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">observer</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>observers<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>observer<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function-variable function\">notifyAllObservers</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>observers<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>observers<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">runFunc</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// 옵져버 == 리스너</span>\n<span class=\"token keyword\">const</span> Observer <span class=\"token operator\">=</span> <span class=\"token keyword\">class</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">func</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 여기선, 하나의 함수만 연결할 수 있다.</span>\n    <span class=\"token comment\">// 여기에 Observer에서 구현한 코드를 그대로 넣어도 똑같이 작동 했겠지만,</span>\n    <span class=\"token comment\">// 코드 내에 다른 공간에서도 이와 같은 옵져버를 사용할 수 있도록 분리 하였다.</span>\n    <span class=\"token comment\">// 즉, subject --- observer(==exe)를</span>\n    <span class=\"token comment\">// subject --- observer --- exe 로 삼등분 한 느낌이다</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>runFunc <span class=\"token operator\">=</span> func\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\nmodule<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  Subject<span class=\"token punctuation\">,</span>\n  Observer<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// Subject 부분, 옵저버가 주시해야 할 코드의 위치. 여기서 시그널을 발생시킴.</span>\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> Subject <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./Observable'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">someFunc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">subscribeObserver</span><span class=\"token punctuation\">(</span>observer1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token operator\">...</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">someAction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">...</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">notifyAllObservers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> subject <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Subject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nsomeFunc<span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span>subject<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nsomeFunc<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>constructor <span class=\"token operator\">=</span> someFunc<span class=\"token punctuation\">;</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// Observer 부분. 시그널이 반영될 코드</span>\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> Observer <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./Observable'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> someClass <span class=\"token operator\">=</span> <span class=\"token keyword\">class</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">someFunc</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function-variable function\">someAction</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token operator\">...</span>\n      <span class=\"token comment\">// 옵저버가 시그널을 발생시키면 실행되어야 할 코드.</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 실행해야 할 코드를 옵져버에 넣어 인스턴스를 생성한다.</span>\n    <span class=\"token comment\">// 이제 이 옵져버는 위 함수를 복사하여 갖고있다.(__proto__로 연결한건 아닌것 같다.)</span>\n    <span class=\"token keyword\">const</span> observer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Observer</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>someAction<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// someFunc는 넘겨받은 인스턴스이다.</span>\n    <span class=\"token comment\">// 위에서 someFunc에 prototype으로 Subject의 인스턴스인 subject를 연결 하였다.</span>\n    <span class=\"token comment\">// 이를 통해서 우리는 someFunc.__proto__.subscribeObserver() 로 접근이 가능한것 같다.</span>\n    <span class=\"token comment\">// 생각해보면, 객체를 인자로 넘길때는 레퍼렌스 참조와 같이 원래의 객체가 넘어오므로, 이 인스턴스</span>\n    <span class=\"token comment\">// 또한 위해서 만들어진 인스턴스 그 자체인듯 하다.</span>\n    someFunc<span class=\"token punctuation\">.</span><span class=\"token function\">subscribeObserver</span><span class=\"token punctuation\">(</span>observer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3>Node에서 http.get 부분…</h3>\n<p><code class=\"language-text\">http.get</code> 은 <code class=\"language-text\">axios</code> 나 <code class=\"language-text\">fetch</code> 처럼 친절하지 않다.</p>\n<p>request를 보내고, response를 받을때 받은 response는 buffer의 형태로 흐르듯 날라온다.</p>\n<p>어찌보면 http의 통신이 사실 그러하기 때문에 당연한 현상이지만, 직관적으로는 결과값은 최종값이여야 할것같다. 쉽게 사용하려면 <code class=\"language-text\">axios</code> 등을 사용하고, <code class=\"language-text\">http.get</code> 으로 간단하게 구현 하려면 다음과 같이 하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> options <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  hostname<span class=\"token operator\">:</span> <span class=\"token string\">\"localhost\"</span><span class=\"token punctuation\">,</span>\n  port<span class=\"token operator\">:</span> <span class=\"token number\">8090</span><span class=\"token punctuation\">,</span>\n  path<span class=\"token operator\">:</span> <span class=\"token string\">\"/api\"</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span>\nhttp\n  <span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">,</span> <span class=\"token parameter\">res</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> body <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span>\n    <span class=\"token comment\">// 여기서 on data 이벤트가 발생하는 동안 계속해서 buffer로 날라온다.</span>\n    res<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"data\"</span><span class=\"token punctuation\">,</span> <span class=\"token parameter\">chunk</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      body <span class=\"token operator\">+=</span> chunk\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">// 여기서 on end 이벤트가 발생하는 순간,</span>\n    <span class=\"token comment\">// 우리는 모든 response가 왔다 파악하고, 그 다음 액션을 취하면 된다.</span>\n    res<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"end\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 이제 body에는 모든 buffer가 쌓여서 하나의 데이터 뭉치가 되었다.</span>\n      <span class=\"token comment\">// 이를 바로 사용하면 된다.</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>todolist<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"error\"</span><span class=\"token punctuation\">,</span> <span class=\"token parameter\">e</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">Error: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>e<span class=\"token punctuation\">.</span>message<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h3>소통의 중요성</h3>\n<p>자바스크립트에 <code class=\"language-text\">Class</code> 는 그저 신택틱 슈거에 불가하고, 이를 기존의 함수로 구현할 수 있는것을 안다. 따라서 챌린지 미션에서 클래스에 대한 안내가 명확하지 않아 초반에 잘못된 구현을 하였다.</p>\n<p>미션에는 다음과 같은 내용이 포함되어 있었다. <code class=\"language-text\">ES Classes 형태로 구현해야 한다.</code> , <code class=\"language-text\">ES6 Classes 패턴을 사용할 수 없으며</code> , <code class=\"language-text\">ES Classes문법으로 구현한다</code> , <code class=\"language-text\">ES Classes를 사용</code></p>\n<p>그냥 단순히 생각하면 클래스를 사용 하라는 것과 사용하지 말라는 두개로 보일 수 있다. 그런데 자세히 보면 위 내용은 다른 의미를 내포할 수 있다.</p>\n<p>예를 들어, <code class=\"language-text\">Classess 형태로 구현</code> 이라는 부분은 <code class=\"language-text\">class</code> 가 제공하는 기능을 모방하여 구현 하라고 해석될 수 있다. 즉, <code class=\"language-text\">class 키워드</code> 를 사용하지 말고 <code class=\"language-text\">class 기능을 구현 하라</code> 로 볼 수 있다. <code class=\"language-text\">패턴</code> 도 같은 맥락에서 해석이 가능하다.</p>\n<p>또한, <code class=\"language-text\">Classes 문법</code> 와 <code class=\"language-text\">Classes</code> 는 <code class=\"language-text\">class 키워드</code> 를 사용하라로 표현될 수 있다.</p>\n<p>이렇듯, 단어 선택이 매우 중요함을 알 수 있다. 실제 협업을 진행할 때도 서로간의 오해가 없도록 자주 소통하는 습관을 가져야 겠다.</p>\n<h2>회고</h2>\n<h3>잘못한 부분</h3>\n<p>집에 돌아와 잘못 생각한 부분들이 있었는데, 그중 가장 큰 부분은 contructer 에 method를 넣었다는 점이였다. 그냥 메소드로 구현하고, constructer안에서 this를 바인딩 해주면 될 부분을 거추장 스럽게 작성한것 같아 아쉽다.</p>\n<h3>만족스러운 부분</h3>\n<p>오늘 한것중에 만족스러운 부분은, 구현을 함에 있어 불필요한 부부을 많이 제외했다는 점이다.</p>\n<p>예를 들어, 일전에는 JSON 파일을 입출력시 계속해서 덮어쓰었다. 이번에는 단순히 로컬 메모리에 올려서 프로그램을 수해하였다. 파일을 작성하는 코드가 메인 코드에서 사라지니 로직이 깔끔해졌다.</p>","frontmatter":{"title":"부스트캠프 2019 챌린지 9일차","date":"July 25, 2019"}}},"pageContext":{"slug":"/boost-camp-challenge/day-9/","previous":{"fields":{"slug":"/boost-camp-challenge/day-8/"},"frontmatter":{"title":"부스트캠프 2019 챌린지 8일차"}},"next":{"fields":{"slug":"/boost-camp-challenge/day-10/"},"frontmatter":{"title":"부스트캠프 2019 챌린지 10일차"}}}}}